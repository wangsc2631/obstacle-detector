<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="æ™ºèƒ½ç”Ÿæ´»åŠ©æ‰‹ - ç›²äººè¼”åŠ©å°èˆªèˆ‡ç‰©å“è­˜åˆ¥ç³»çµ±" />
  <title>ğŸ§  æ™ºèƒ½ç”Ÿæ´»åŠ©æ‰‹ - ç›²äººè¼”åŠ©å°èˆª</title>
  
  <style>
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --primary: #00b894;
      --secondary: #fd79a8;
      --accent: #6c5ce7;
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    .header {
      text-align: center;
      margin-bottom: 0;
    }
    
    .header h1 {
      margin: 0;
      font-size: 24px;
    }
    
    .header .subtitle {
      font-size: 14px;
      color: var(--muted);
      margin-top: 5px;
    }
    
    .stats-badge {
      background: rgba(255,255,255,0.2);
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 12px;
      margin-top: 8px;
      display: inline-block;
    }
    
    .camera-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera-container video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    
    .camera-container canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10; /* ç¢ºä¿åœ¨ video ä¸Šæ–¹ */
    }

    .camera-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 16px;
      z-index: 15; /* ç¢ºä¿åœ¨ canvas ä¸Šæ–¹ */
      text-align: center;
      padding: 20px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    button {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    button:active:not(:disabled) {
      transform: translateY(2px) scale(0.98);
    }
    
    .btn-primary {
      background: var(--primary);
      color: #fff;
    }
    
    .btn-danger {
      background: var(--bad);
      color: #fff;
    }
    
    .btn-secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .btn-accent {
      background: var(--accent);
      color: #fff;
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-value {
      font-weight: 800;
      font-size: 16px;
    }
    
    .voice-alert {
      background: rgba(0, 184, 148, 0.15);
      border: 1px solid rgba(0, 184, 148, 0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      margin-bottom: 15px;
    }
    
    .detection-list {
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .detection-item {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
    }
    
    .items-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin-top: 15px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .item-card {
      background: rgba(255,255,255,0.1);
      padding: 15px 10px;
      border-radius: 15px;
      text-align: center;
      border: 2px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }
    
    .item-card.highlight {
      animation: pulse 2s ease-in-out;
      border-color: var(--primary);
    }
    
    .item-name {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 5px;
      color: var(--text);
    }
    
    .item-confidence {
      font-size: 12px;
      color: var(--muted);
    }
    
    .category-tag {
      display: inline-block;
      background: var(--accent);
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 10px;
      margin-top: 5px;
    }
    
    .navigation-info {
      background: rgba(253, 203, 110, 0.15);
      border: 1px solid rgba(253, 203, 110, 0.35);
      padding: 20px;
      border-radius: 12px;
      margin: 15px 0;
      text-align: center;
    }
    
    .direction-arrow {
      font-size: 48px;
      margin: 10px 0;
      color: var(--bad);
    }
    
    .distance-display {
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
      color: var(--text);
    }
    
    .instruction-text {
      font-size: 18px;
      color: var(--text);
      margin: 10px 0;
    }
    
    .mode-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }
    
    .mode-recording { background: var(--bad); }
    .mode-identifying { background: var(--primary); }
    .mode-navigating { background: var(--accent); }
    .mode-idle { background: var(--muted); }
    
    .search-box {
      margin: 15px 0;
      padding: 15px;
      background: rgba(255,255,255,0.1);
      border-radius: 15px;
    }
    
    .search-input {
      width: 100%;
      padding: 12px;
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      font-size: 16px;
      background: rgba(255,255,255,0.1);
      color: var(--text);
    }
    
    .search-input::placeholder {
      color: var(--muted);
    }
    
    .category-filter {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    
    .category-btn {
      padding: 6px 12px;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 15px;
      font-size: 12px;
      cursor: pointer;
      color: var(--text);
    }
    
    .category-btn.active {
      background: var(--accent);
      color: white;
    }
    
    .debug-info {
      background: rgba(0,0,0,0.8);
      color: #00ff00;
      padding: 8px;
      border-radius: 5px;
      font-size: 12px;
      margin-top: 8px;
      font-family: monospace;
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    @keyframes pulse {
      0%, 100% { 
        transform: scale(1);
        box-shadow: 0 3px 10px rgba(0,0,0,0.1);
      }
      50% { 
        transform: scale(1.05);
        box-shadow: 0 5px 20px rgba(0, 184, 148, 0.4);
      }
    }
    
    .tab-container {
      display: flex;
      gap: 5px;
      margin-bottom: 15px;
    }
    
    .tab {
      flex: 1;
      padding: 12px;
      text-align: center;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
    }
    
    .tab.active {
      background: var(--accent);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .camera-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    .camera-switch {
      flex: 1;
      padding: 10px;
      background: var(--glass-strong);
      border: none;
      border-radius: 10px;
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
    }
    
    .error-message {
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      margin: 10px 0;
    }
    
    .progress-bar {
      width: 100%;
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      margin: 10px 0;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--primary);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    .navigation-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 15px;
    }
    
    .turn-instruction {
      font-size: 20px;
      font-weight: bold;
      text-align: center;
      margin: 10px 0;
      padding: 15px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
    }
    
    .safety-alert {
      background: rgba(239,68,68,0.2);
      border: 1px solid rgba(239,68,68,0.4);
      color: #fff;
      border-radius: 12px;
      padding: 12px;
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
    }
    
    .road-info {
      background: rgba(34,197,94,0.15);
      border: 1px solid rgba(34,197,94,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 12px;
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="card header">
      <h1>ğŸ§  æ™ºèƒ½ç”Ÿæ´»åŠ©æ‰‹</h1>
      <div class="subtitle">ç›²äººè¼”åŠ©å°èˆª â€¢ 1500+ç‰©å“è­˜åˆ¥</div>
      <div class="stats-badge">æ”¯æ´ 21å¤§é¡åˆ¥ â€¢ è¶…é1500ç¨®ç‰©å“</div>
    </div>

    <div class="card">
      <div class="tab-container">
        <div class="tab active" data-tab="navigation">å°èˆªæ¨¡å¼</div>
        <div class="tab" data-tab="recognition">ç‰©å“è­˜åˆ¥</div>
      </div>
    </div>

    <div id="voiceAlert" class="voice-alert">
      ç³»çµ±æº–å‚™ä¸­...
    </div>

    <div id="errorMessage" class="error-message" style="display: none;"></div>

    <div id="navigationTab" class="tab-content active">
      <div class="card">
        <div class="camera-container">
          <div id="cameraPreview" class="camera-preview">
            <div>
              <div style="font-size:48px; margin-bottom:10px;">ğŸ“·</div>
              <div>é»æ“Šã€Œé–‹å•Ÿç›¸æ©Ÿã€é–‹å§‹ä½¿ç”¨</div>
              <div style="font-size:12px; margin-top:10px; color:var(--muted);">
                é“è·¯è¾¨è­˜èˆ‡éšœç¤™ç‰©æª¢æ¸¬
              </div>
            </div>
          </div>
          <video id="video" autoplay playsinline muted></video>
        </div>
      </div>

      <div class="card">
        <div class="controls">
          <button id="btnCamera" class="btn-primary">
            <span>ğŸ“·</span>
            <span>é–‹å•Ÿç›¸æ©Ÿ</span>
          </button>
          <button id="btnStart" class="btn-primary" disabled>
            <span>ğŸ”</span>
            <span>é–‹å§‹æª¢æ¸¬</span>
          </button>
          <button id="btnTest" class="btn-secondary" disabled>
            <span>ğŸ§ª</span>
            <span>æ¸¬è©¦åŠŸèƒ½</span>
          </button>
          <button id="btnStop" class="btn-danger" disabled>
            <span>â¹ï¸</span>
            <span>åœæ­¢</span>
          </button>
        </div>

        <div class="status-grid">
          <div class="status-item">
            <div class="status-label">ç³»çµ±ç‹€æ…‹</div>
            <div class="status-value" id="status">æº–å‚™ä¸­</div>
          </div>
          <div class="status-item">
            <div class="status-label">æª¢æ¸¬æ¨¡å¼</div>
            <div class="status-value" id="detectionMode">é“è·¯è¾¨è­˜</div>
          </div>
          <div class="status-item">
            <div class="status-label">ç›¸æ©Ÿç‹€æ…‹</div>
            <div class="status-value" id="cameraStatus">æœªé–‹å•Ÿ</div>
          </div>
          <div class="status-item">
            <div class="status-label">å°èˆªç‹€æ…‹</div>
            <div class="status-value" id="navigationStatus">æœªé–‹å§‹</div>
          </div>
        </div>

        <div id="debugInfo" class="debug-info" style="display:none;"></div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 12px 0;">å°èˆªå›å®¶</h3>
        <div class="navigation-controls">
          <button class="btn-primary" onclick="startNavigationHome()" id="btnNavigateHome">
            <span>ğŸ§­</span>
            <span>é–‹å§‹å°èˆªå›å®¶</span>
          </button>
          <button class="btn-accent" onclick="openGoogleMaps()" id="btnGoogleMaps">
            <span>ğŸ—ºï¸</span>
            <span>é–‹å•ŸGoogleåœ°åœ–</span>
          </button>
          <button class="btn-secondary" onclick="simulateTurn('left')">
            <span>â†©ï¸</span>
            <span>æ¸¬è©¦å·¦è½‰</span>
          </button>
          <button class="btn-secondary" onclick="simulateTurn('right')">
            <span>â†ªï¸</span>
            <span>æ¸¬è©¦å³è½‰</span>
          </button>
        </div>
      </div>

      <div id="navigationPanel" class="navigation-info" style="display: none;">
        <div class="direction-arrow" id="directionArrow">â†‘</div>
        <div class="distance-display" id="distanceDisplay">-- å…¬å°º</div>
        <div class="turn-instruction" id="turnInstruction">
          æº–å‚™é–‹å§‹å°èˆª...
        </div>
        <div class="road-info" id="roadInfo">
          é“è·¯è¾¨è­˜ä¸­...
        </div>
        <div class="safety-alert" id="safetyAlert" style="display: none;">
          æ³¨æ„å‰æ–¹å®‰å…¨ï¼
        </div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 12px 0;">ç’°å¢ƒæª¢æ¸¬</h3>
        <div id="detectionList" class="detection-list">
          <div class="detection-item" style="text-align:center; color:var(--muted);">
            ç­‰å¾…é–‹å§‹åµæ¸¬â€¦
          </div>
        </div>
      </div>

      <div class="card">
        <h4 style="margin:0 0 8px 0;">ä½¿ç”¨èªªæ˜</h4>
        <div style="font-size:12px; color:var(--muted); line-height:1.4;">
          <div>1. é»æ“Šã€Œè¨˜éŒ„å®¶çš„ä½ç½®ã€è¨­å®šå›å®¶ç›®çš„åœ°</div>
          <div>2. é»æ“Šã€Œé–‹å§‹å°èˆªå›å®¶ã€å•Ÿå‹•èªéŸ³å°èˆª</div>
          <div>3. ç³»çµ±æœƒæä¾›è½‰å‘æŒ‡ç¤ºï¼ˆå·¦è½‰ã€å³è½‰ã€ç›´è¡Œï¼‰</div>
          <div>4. é–‹å•Ÿç›¸æ©Ÿå¯é€²è¡Œé“è·¯è¾¨è­˜èˆ‡éšœç¤™ç‰©æª¢æ¸¬</div>
          <div>5. é»æ“Šã€Œé–‹å•ŸGoogleåœ°åœ–ã€ä½¿ç”¨è©³ç´°å°èˆª</div>
        </div>
      </div>
    </div>

    <div id="recognitionTab" class="tab-content">
      <div id="modelProgress" class="card" style="display: none;">
        <div style="text-align: center; margin-bottom: 10px;">
          <div style="font-size: 18px; font-weight: bold;">æ­£åœ¨è¼‰å…¥AIæ¨¡å‹</div>
          <div style="font-size: 12px; color: var(--muted); margin-top: 5px;">è«‹ç¨å€™ï¼Œé¦–æ¬¡ä½¿ç”¨éœ€è¦è¼‰å…¥æ¨¡å‹</div>
        </div>
        <div class="progress-bar">
          <div id="progressFill" class="progress-fill"></div>
        </div>
        <div id="progressText" style="text-align: center; font-size: 12px; color: var(--muted); margin-top: 5px;">0%</div>
      </div>

      <div class="card">
        <div class="camera-container">
          <div id="recognitionCameraPreview" class="camera-preview">
            <div>
              <div style="font-size:48px; margin-bottom:10px;">ğŸ“·</div>
              <div>é»æ“Šã€Œé–‹å•Ÿç›¸æ©Ÿã€é–‹å§‹ç‰©å“è­˜åˆ¥</div>
              <div style="font-size:12px; margin-top:10px; color:var(--muted);">
                å¯è­˜åˆ¥1500+ç¨®æ—¥å¸¸ç‰©å“
              </div>
            </div>
          </div>
          <video id="recognitionVideo" autoplay playsinline muted></video>
          <canvas id="recognitionOverlayCanvas"></canvas>
        </div>
        <div class="camera-controls">
          <button class="camera-switch" onclick="switchRecognitionCamera()">
            <span>ğŸ”„</span>
            <span>åˆ‡æ›é¡é ­</span>
          </button>
        </div>
      </div>

      <div class="card">
        <div class="controls">
          <button class="btn-primary" onclick="startItemRecognition()" id="btnRecognition" disabled>
            <span>ğŸ”</span>
            <span>æ™ºèƒ½è­˜åˆ¥</span>
          </button>
          <button class="btn-accent" onclick="toggleContinuousMode()" id="continuousBtn">
            <span>ğŸ”„</span>
            <span>é€£çºŒè­˜åˆ¥</span>
          </button>
          <button class="btn-secondary" onclick="setHomeLocation()">
            <span>ğŸ </span>
            <span>è¨­å®šå®¶çš„ä½ç½®</span>
          </button>
          <button class="btn-danger" onclick="startNavigationHome()">
            <span>ğŸ§­</span>
            <span>å°èˆªå›å®¶</span>
          </button>
        </div>
      </div>

      <div class="card search-box">
        <input type="text" class="search-input" placeholder="ğŸ” æœå°‹ç‰©å“åç¨±..." onkeyup="filterItems()" id="searchInput">
        <div class="category-filter" id="categoryFilter">
          </div>
      </div>

      <div class="card">
        <div class="status-grid">
          <div class="status-item">
            <div class="status-label">ç•¶å‰æ¨¡å¼</div>
            <div class="status-value"><span class="mode-indicator" id="modeIndicator"></span><span id="currentMode">å¾…æ©Ÿä¸­</span></div>
          </div>
          <div class="status-item">
            <div class="status-label">è­˜åˆ¥ç‰©å“æ•¸</div>
            <div class="status-value" id="itemCount">0</div>
          </div>
          <div class="status-item">
            <div class="status-label">å®¶çš„ä½ç½®</div>
            <div class="status-value" id="homeStatus">æœªè¨­å®š</div>
          </div>
          <div class="status-item">
            <div class="status-label">è³‡æ–™åº«</div>
            <div class="status-value" id="databaseSize">1500+ ç‰©å“</div>
          </div>
        </div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 12px 0;">ç‰©å“è­˜åˆ¥çµæœ</h3>
        <div id="itemsContainer" class="items-grid">
          <div class="item-card" style="background: rgba(255,255,255,0.1); color: var(--muted);">
            <div class="item-name">ç­‰å¾…AIæ¨¡å‹è¼‰å…¥...</div>
            <div class="item-confidence">é¦–æ¬¡ä½¿ç”¨éœ€è¦è¼‰å…¥æ¨¡å‹</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="controls">
          <button class="btn-secondary" onclick="repeatInstruction()">
            <span>ğŸ”Š</span>
            <span>é‡è¤‡æç¤º</span>
          </button>
          <button class="btn-secondary" onclick="toggleVoice()" id="voiceToggleBtn">
            <span>ğŸ”‡</span>
            <span>é—œé–‰èªéŸ³</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <script src="itemDatabase.js"></script>
  <script>

    // --- YOLOv8 å°ˆç”¨è¨­å®š (å„ªåŒ–é…ç½®) ---
    const MODEL_INPUT_SIZE = 640;
    const CONF_THRESHOLD = 0.25; // æé«˜éˆæ•åº¦
    const IOU_THRESHOLD = 0.45;
    const DETECTION_INTERVAL = 2000; // é€£çºŒæ¨¡å¼ä¸‹çš„æª¢æ¸¬é–“éš”
    const HF_MODEL_URL = 'https://huggingface.co/wang2631/YOLOv8s-web-deployment/resolve/main/yolov8s.onnx'; // æ‚¨çš„ Hugging Face ç›´éˆ

    // --- å°èˆªç³»çµ±ç‹€æ…‹è®Šæ•¸ ---
    let isDetecting = false;
    let currentStream = null;
    let detectionInterval = null;
    let lastDetectionTime = 0;

    // --- ç‰©å“è­˜åˆ¥ç³»çµ±ç‹€æ…‹è®Šæ•¸ ---
    let recognitionStream = null;
    let recognitionCameraFacingMode = 'environment';
    let modelLoaded = false;
    let recognitionOverlayCtx = null; // æ–°å¢ Canvas Context

    // æ™ºèƒ½åŠ©æ‰‹é¡
    class SmartAssistant {
      constructor() {
        this.yoloDetector = null; // æ›¿æ›åŸä¾†çš„ this.model
        this.isRecognizing = false;
        this.continuousMode = false;
        this.voiceEnabled = true;
        this.homeLocation = null;
        this.isNavigating = false;
        this.watchId = null;
        this.lastItems = [];
        this.lastSpeechTime = 0;
        this.SPEECH_COOLDOWN = 4000;
        this.currentCategory = 'å…¨éƒ¨';
        this.continuousInterval = null;
        
        // å°èˆªç›¸é—œå±¬æ€§
        this.currentLocation = null;
        this.lastLocation = null;
        this.heading = null;
        this.agpsEnabled = false;
        this.locationHistory = [];
        this.arrivalThreshold = 20; // 20å…¬å°ºå…§è¦–ç‚ºåˆ°é”
      }

      // --- YOLOv8 åµæ¸¬é¡åˆ¥ (ç§»æ¤è‡ªä¸Šä¸€æ¬¡çš„æˆåŠŸç¨‹å¼ç¢¼) ---
      // é€™å€‹é¡åˆ¥è² è²¬æ¨¡å‹è¼‰å…¥ã€å½±åƒå‰è™•ç†ã€ONNX æ¨ç†åŠå¾Œè™•ç† NMS
      get YOLOv8Detector() {
          const cocoLabels = [ /* COCO 80 å€‹é¡åˆ¥ */
              "person", "bicycle", "car", "motorcycle", "airplane", "bus", "train", "truck", "boat", "traffic light",
              "fire hydrant", "stop sign", "parking meter", "bench", "bird", "cat", "dog", "horse", "sheep", "cow",
              "elephant", "bear", "zebra", "giraffe", "backpack", "umbrella", "handbag", "tie", "suitcase", "frisbee",
              "skis", "snowboard", "sports ball", "kite", "baseball bat", "baseball glove", "skateboard", "surfboard",
              "tennis racket", "bottle", "wine glass", "cup", "fork", "knife", "spoon", "bowl", "banana", "apple",
              "sandwich", "orange", "broccoli", "carrot", "hot dog", "pizza", "donut", "cake", "chair", "couch",
              "potted plant", "bed", "dining table", "toilet", "tv", "laptop", "mouse", "remote", "keyboard", "cell phone",
              "microwave", "oven", "toaster", "sink", "refrigerator", "book", "clock", "vase", "scissors", "teddy bear",
              "hair drier", "toothbrush"
          ];

          return class {
              constructor(modelPath) {
                  this.modelPath = modelPath;
                  this.session = null;
                  this.cocoLabels = cocoLabels;
              }

              async loadModel() {
                  try {
                      showModelProgress('æ­£åœ¨è¼‰å…¥AIæ¨¡å‹ (42.8MB)...', 10);
                      
                      this.session = await ort.InferenceSession.create(this.modelPath, {
                          executionProviders: ['wasm'], 
                          graphOptimizationLevel: 'all',
                          logLevel: 'error'
                      });

                      showModelProgress('æ¨¡å‹è¼‰å…¥å®Œæˆï¼', 100);
                      return true;

                  } catch (error) {
                      console.error('æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
                      showError('AIæ¨¡å‹è¼‰å…¥å¤±æ•—ï¼š' + error.message);
                      updateVoice('AIæ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥');
                      return false;
                  }
              }

              async preprocess(source) {
                  let tensor = tf.browser.fromPixels(source);
                  let [h, w] = tensor.shape;
                  const resizeRatio = Math.min(MODEL_INPUT_SIZE / h, MODEL_INPUT_SIZE / w);

                  const targetW = Math.round(w * resizeRatio);
                  const targetH = Math.round(h * resizeRatio);
                  
                  tensor = tf.image.resizeBilinear(tensor, [targetH, targetW]);
                  
                  const paddingW = MODEL_INPUT_SIZE - targetW;
                  const paddingH = MODEL_INPUT_SIZE - targetH;
                  
                  tensor = tf.pad(tensor, [
                    [0, paddingH], [0, paddingW], [0, 0]
                  ], 0);

                  tensor = tensor.div(255.0);
                  tensor = tensor.transpose([2, 0, 1]);
                  tensor = tensor.expandDims(0);

                  const inputData = new Float32Array(tensor.dataSync());
                  tf.dispose(tensor);

                  return { 
                    inputTensor: new ort.Tensor('float32', inputData, [1, 3, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]),
                    ratio: resizeRatio,
                    sourceWidth: w,
                    sourceHeight: h
                  };
              }

              async detect(source) {
                  if (!this.session) return [];

                  const { inputTensor, ratio, sourceWidth, sourceHeight } = await this.preprocess(source);
                  
                  const feeds = { 'images': inputTensor }; 
                  const results = await this.session.run(feeds);
                  
                  // æ³¨æ„ï¼šYOLOv8 çš„è¼¸å‡ºåç¨±é€šå¸¸æ˜¯ output0 (æˆ–é¡ä¼¼åç¨±)
                  const outputTensor = results.output0.data; 

                  return this.postprocess(outputTensor, ratio, sourceWidth, sourceHeight);
              }

              postprocess(outputData, ratio, sourceWidth, sourceHeight) {
                  // é‚Šç•Œæ¡†æ•¸é‡é€šå¸¸ç‚º 8400
                  const [numClasses, numBoxes] = [this.cocoLabels.length, 8400]; 
                  let boxes = [];
                  const boxSize = 4 + numClasses; // x, y, w, h + 80 classes = 84

                  for (let i = 0; i < numBoxes; i++) {
                    let boxData = outputData.slice(i * boxSize, (i + 1) * boxSize);
                    
                    let scores = boxData.slice(4, 4 + numClasses);
                    let maxScore = Math.max(...scores);
                    
                    if (maxScore > CONF_THRESHOLD) {
                        let classId = scores.indexOf(maxScore);
                        
                        let x = boxData[0];
                        let y = boxData[1];
                        let w = boxData[2];
                        let h = boxData[3];
                        
                        // è½‰æ›å›åŸå§‹å½±åƒåº§æ¨™
                        let xmin = (x - w / 2) / ratio;
                        let ymin = (y - h / 2) / ratio;
                        let xmax = (x + w / 2) / ratio;
                        let ymax = (y + h / 2) / ratio;

                        // è£å‰ªåˆ°å½±åƒé‚Šç•Œ
                        xmin = Math.max(0, xmin);
                        ymin = Math.max(0, ymin);
                        xmax = Math.min(sourceWidth, xmax);
                        ymax = Math.min(sourceHeight, ymax);

                        boxes.push({
                            xmin: xmin,
                            ymin: ymin,
                            xmax: xmax,
                            ymax: ymax,
                            score: maxScore,
                            classId: classId,
                            class: this.cocoLabels[classId]
                        });
                    }
                  }
                  
                  return this.nonMaxSuppression(boxes);
              }

              nonMaxSuppression(boxes) {
                  if (boxes.length === 0) return [];

                  const sortedBoxes = boxes.sort((a, b) => b.score - a.score);
                  const selected = [];

                  while (sortedBoxes.length > 0) {
                      const first = sortedBoxes[0];
                      selected.push(first);
                      
                      const iouFilter = sortedBoxes.slice(1).filter(box => {
                          const iou = this.intersectionOverUnion(first, box);
                          return iou < IOU_THRESHOLD || first.classId !== box.classId; 
                      });

                      sortedBoxes.splice(0, sortedBoxes.length, ...iouFilter);
                  }

                  return selected;
              }

              intersectionOverUnion(box1, box2) {
                  const xA = Math.max(box1.xmin, box2.xmin);
                  const yA = Math.max(box1.ymin, box2.ymin);
                  const xB = Math.min(box1.xmax, box2.xmax);
                  const yB = Math.min(box1.ymax, box2.ymax);

                  const intersection = Math.max(0, xB - xA) * Math.max(0, yB - yA);
                  
                  const area1 = (box1.xmax - box1.xmin) * (box1.ymax - box1.ymin);
                  const area2 = (box2.xmax - box2.xmin) * (box2.ymax - box2.ymin);
                  
                  if (area1 <= 0 || area2 <= 0) return 0;

                  return intersection / (area1 + area2 - intersection);
              }
          }
      }

      // åˆå§‹åŒ–AIæ¨¡å‹ (æ”¹ç‚ºè¼‰å…¥ YOLOv8)
      async initModel() {
        try {
          updateVoice('æ­£åœ¨æº–å‚™æ™ºèƒ½è­˜åˆ¥ç³»çµ±...');
          showModelProgress('æ­£åœ¨åˆå§‹åŒ– ONNX Runtime å¼•æ“...', 10);
          
          if (typeof tf === 'undefined' || typeof ort === 'undefined') {
            throw new Error('å¿…è¦å‡½å¼åº« (TensorFlow/ONNX Runtime) è¼‰å…¥å¤±æ•—');
          }

          await tf.ready();
          
          showModelProgress('è¼‰å…¥ YOLOv8s æ¨¡å‹ (42.8MB)...', 30);
          
          this.yoloDetector = new this.YOLOv8Detector(HF_MODEL_URL);
          const success = await this.yoloDetector.loadModel();
          
          if (!success) {
            throw new Error('YOLOv8 æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯åŠç›´éˆ');
          }

          // åˆå§‹åŒ–ç¹ªåœ–ç’°å¢ƒ
          const overlayCanvas = document.getElementById('recognitionOverlayCanvas');
          recognitionOverlayCtx = overlayCanvas.getContext('2d');
          
          hideModelProgress();
          modelLoaded = true;
          updateVoice(`ç³»çµ±æº–å‚™å®Œæˆï¼å¯è­˜åˆ¥${Object.keys(itemNames).length}ç¨®ç‰©å“`);
          this.updateModeIndicator('idle');
          this.initCategoryFilter();
          
          document.getElementById('btnRecognition').disabled = false;
          document.getElementById('continuousBtn').disabled = false;
          
          document.getElementById('itemsContainer').innerHTML = `
            <div class="item-card" style="background: rgba(255,255,255,0.1); color: var(--muted); grid-column: 1/-1;">
              <div class="item-name">AIæ¨¡å‹è¼‰å…¥å®Œæˆ</div>
              <div class="item-confidence">é»æ“Šã€Œæ™ºèƒ½è­˜åˆ¥ã€é–‹å§‹ç‰©å“è­˜åˆ¥</div>
            </div>
          `;
          
        } catch (error) {
          console.error('æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
          modelLoaded = false;
          hideModelProgress();
          showError('AIæ¨¡å‹è¼‰å…¥å¤±æ•—ï¼š' + error.message);
          updateVoice('AIæ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥å¾Œé‡æ–°æ•´ç†é é¢');
        }
      }

      // åˆå§‹åŒ–åˆ†é¡ç¯©é¸å™¨
      initCategoryFilter() {
        // ... (ä¿æŒä¸è®Š)
      }

      // è¨­å®šåˆ†é¡
      setCategory(category) {
        // ... (ä¿æŒä¸è®Š)
      }

      // ç¯©é¸é¡¯ç¤ºçš„ç‰©å“
      filterDisplayedItems() {
        // ... (ä¿æŒä¸è®Š)
      }

      // é–‹å§‹ç‰©å“è­˜åˆ¥ (æ”¹ç‚ºä½¿ç”¨ YOLOv8)
      async startItemRecognition() {
        if (!modelLoaded || this.isRecognizing) {
          showError('AIæ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆæˆ–æ­£åœ¨è­˜åˆ¥ä¸­');
          updateVoice('ç³»çµ±å°šæœªæº–å‚™å¥½ï¼Œè«‹ç¨å€™');
          return;
        }

        const video = await this.setupRecognitionCamera();
        if (!video) return;

        this.isRecognizing = true;
        this.updateModeIndicator('identifying');
        updateVoice('é–‹å§‹è­˜åˆ¥ç‰©å“ï¼Œè«‹å°‡é¡é ­å°æº–æƒ³èªè­˜çš„ç‰©å“');
        this.clearOverlay();

        try {
          const predictions = await this.yoloDetector.detect(video);
          this.processRecognitionResults(predictions);
          this.drawBoundingBoxes(predictions, video); // ç¹ªè£½é‚Šç•Œæ¡†
        } catch (error) {
          console.error('è­˜åˆ¥å¤±æ•—:', error);
          updateVoice('è­˜åˆ¥å¤±æ•—ï¼Œè«‹é‡è©¦');
          showError('ç‰©å“è­˜åˆ¥å¤±æ•—ï¼š' + error.message);
        }

        this.isRecognizing = false;
        this.updateModeIndicator('idle');
      }

      // åˆ‡æ›é€£çºŒè­˜åˆ¥æ¨¡å¼
      async toggleContinuousMode() {
        if (this.continuousMode) {
          this.stopContinuousMode();
        } else {
          await this.startContinuousMode();
        }
      }

      // é–‹å§‹é€£çºŒè­˜åˆ¥
      async startContinuousMode() {
        if (!modelLoaded) {
          showError('AIæ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆï¼Œè«‹ç¨å€™å†è©¦');
          updateVoice('ç³»çµ±å°šæœªæº–å‚™å¥½ï¼Œè«‹ç­‰å¾…æ¨¡å‹è¼‰å…¥');
          return;
        }

        const video = await this.setupRecognitionCamera();
        if (!video) return;

        this.continuousMode = true;
        this.updateModeIndicator('identifying');
        updateVoice('é–‹å•Ÿé€£çºŒè­˜åˆ¥æ¨¡å¼ï¼Œç³»çµ±æœƒæŒçºŒå‘Šè¨´æ‚¨çœ‹åˆ°çš„ç‰©å“');
        
        document.getElementById('continuousBtn').innerHTML = 
          '<span>â¹ï¸</span><span>åœæ­¢è­˜åˆ¥</span>';

        this.continuousRecognition(video);
      }

      // åœæ­¢é€£çºŒè­˜åˆ¥
      stopContinuousMode() {
        this.continuousMode = false;
        this.updateModeIndicator('idle');
        updateVoice('å·²åœæ­¢é€£çºŒè­˜åˆ¥');
        
        document.getElementById('continuousBtn').innerHTML = 
          '<span>ğŸ”„</span><span>é€£çºŒè­˜åˆ¥</span>';

        if (this.continuousInterval) {
          clearTimeout(this.continuousInterval);
          this.continuousInterval = null;
          this.clearOverlay();
        }
      }

      // é€£çºŒè­˜åˆ¥å¾ªç’°
      async continuousRecognition(video) {
        if (!this.continuousMode) return;
        
        // ä½¿ç”¨è¨ˆæ™‚å™¨ä¾†æ§åˆ¶åµæ¸¬é–“éš”
        if (this.isRecognizing) {
           this.continuousInterval = setTimeout(() => this.continuousRecognition(video), 100);
           return;
        }
        
        this.isRecognizing = true;
        this.clearOverlay();

        try {
          const predictions = await this.yoloDetector.detect(video);
          this.processRecognitionResults(predictions);
          this.drawBoundingBoxes(predictions, video);
          
        } catch (error) {
          console.error('é€£çºŒè­˜åˆ¥éŒ¯èª¤:', error);
        } finally {
          this.isRecognizing = false;
          this.continuousInterval = setTimeout(() => this.continuousRecognition(video), DETECTION_INTERVAL);
        }
      }

      // è™•ç†è­˜åˆ¥çµæœ (ä½¿ç”¨ YOLOv8 æ ¼å¼)
      processRecognitionResults(predictions) {
        // predictions æ ¼å¼: [{ class: '...', score: ..., xmin: ..., ... }]
        const highConfidenceItems = predictions
          .filter(pred => itemNames[pred.class])
          .map(pred => ({
            class: pred.class,
            name: itemNames[pred.class], // å¾ itemDatabase è½‰æ›
            confidence: pred.score,
            category: itemCategories[pred.class]
          }))
          .filter((item, index, array) => 
            array.findIndex(i => i.class === item.class) === index
          )
          .sort((a, b) => b.confidence - a.confidence)
          .slice(0, 8);

        this.lastItems = highConfidenceItems;
        this.filterDisplayedItems();
        this.provideItemVoiceGuidance(highConfidenceItems);
      }

      // ç¹ªè£½é‚Šç•Œæ¡†
      drawBoundingBoxes(detections, video) {
          if (!recognitionOverlayCtx) return;

          const canvas = recognitionOverlayCtx.canvas;
          // å°‡ Canvas å°ºå¯¸èˆ‡ Video å°ºå¯¸åŒæ­¥
          if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
          }

          recognitionOverlayCtx.clearRect(0, 0, canvas.width, canvas.height);
          recognitionOverlayCtx.strokeStyle = '#00B894';
          recognitionOverlayCtx.lineWidth = 3;
          recognitionOverlayCtx.font = '18px Arial';
          recognitionOverlayCtx.fillStyle = '#00B894';

          detections.forEach(detection => {
              const x = detection.xmin;
              const y = detection.ymin;
              const w = detection.xmax - detection.xmin;
              const h = detection.ymax - detection.ymin;
              
              const name = itemNames[detection.class] || detection.class;

              // ç¹ªè£½é‚Šç•Œæ¡†
              recognitionOverlayCtx.beginPath();
              recognitionOverlayCtx.rect(x, y, w, h);
              recognitionOverlayCtx.stroke();

              // ç¹ªè£½æ¨™ç±¤ (ç¢ºä¿æ¨™ç±¤åœ¨é‚Šç•Œå…§)
              const label = `${name} (${(detection.score * 100).toFixed(1)}%)`;
              // ç¹ªè£½èƒŒæ™¯ (å¯é¸)
              recognitionOverlayCtx.fillStyle = '#00B894';
              recognitionOverlayCtx.fillRect(x, y > 20 ? y - 25 : y + h + 5, recognitionOverlayCtx.measureText(label).width + 10, 20);
              
              recognitionOverlayCtx.fillStyle = 'white';
              recognitionOverlayCtx.fillText(label, x + 5, y > 20 ? y - 10 : y + h + 20);
              
              recognitionOverlayCtx.strokeStyle = '#00B894'; // æ¢å¾©é‚Šç•Œæ¡†é¡è‰²
          });
      }
      
      clearOverlay() {
          if (recognitionOverlayCtx) {
              recognitionOverlayCtx.clearRect(0, 0, recognitionOverlayCtx.canvas.width, recognitionOverlayCtx.canvas.height);
          }
      }

      // æ›´æ–°ç‰©å“é¡¯ç¤º
      updateItemsDisplay(items) {
        // ... (ä¿æŒä¸è®Š)
      }

      // æä¾›ç‰©å“èªéŸ³æç¤º
      provideItemVoiceGuidance(items) {
        // ... (ä¿æŒä¸è®Š)
      }

      // è¨­å®šå®¶çš„ä½ç½®
      async setHomeLocation() {
        // ... (ä¿æŒä¸è®Š)
      }

      // é–‹å§‹çœŸå¯¦å°èˆªå›å®¶
      startNavigationHome() {
        // ... (ä¿æŒä¸è®Š)
      }

      // é–‹å§‹å¯¦æ™‚ä½ç½®è¿½è¹¤
      startRealTimeTracking() {
        // ... (ä¿æŒä¸è®Š)
      }

      // å¯¦æ™‚å°èˆªæ›´æ–°
      updateRealTimeNavigation(position) {
        // ... (ä¿æŒä¸è®Š)
      }

      // è¨ˆç®—å…©é»é–“è·é›¢ (å…¬å°º)
      calculateDistance(point1, point2) {
        // ... (ä¿æŒä¸è®Š)
      }

      // è¨ˆç®—æ–¹ä½è§’
      calculateBearing(point1, point2) {
        // ... (ä¿æŒä¸è®Š)
      }

      // æ›´æ–°å°èˆªé¡¯ç¤º
      updateNavigationDisplay(step) {
        // ... (ä¿æŒä¸è®Š)
      }

      // æä¾›é“è·¯å®‰å…¨è³‡è¨Š
      provideRoadSafetyInfo() {
        // ... (ä¿æŒä¸è®Š)
      }

      // åœæ­¢å°èˆª
      stopNavigation() {
        // ... (ä¿æŒä¸è®Š)
      }

      // é–‹å•ŸGoogle Mapså°èˆª
      openGoogleMapsNavigation() {
        // ... (ä¿æŒä¸è®Š)
      }


      // åˆå§‹åŒ– AGPS è¼”åŠ©å®šä½
      async initAGPS() {
        // ... (ä¿æŒä¸è®Š)
      }

      // æ›´æ–°å¯¦æ™‚å°èˆªé¡¯ç¤º
      updateRealNavigationDisplay(distance, bearing) {
        // ... (ä¿æŒä¸è®Š)
      }

      // æ ¹æ“šæ–¹ä½è§’ç²å–æ–¹å‘è³‡è¨Š
      getDirectionFromBearing(bearing) {
        // ... (ä¿æŒä¸è®Š)
      }

      // æ›´æ–°é“è·¯è³‡è¨Š
      updateRoadInfo() {
        // ... (ä¿æŒä¸è®Š)
      }

      // å¯¦æ™‚èªéŸ³æŒ‡å¼•
      provideRealTimeGuidance(distance, bearing) {
        // ... (ä¿æŒä¸è®Š)
      }

      // åˆ°é”ç›®çš„åœ°
      arriveAtDestination() {
        // ... (ä¿æŒä¸è®Š)
      }

      // è™•ç†å°èˆªéŒ¯èª¤
      handleNavigationError(error) {
        // ... (ä¿æŒä¸è®Š)
      }

      // ç²å–åœ°ç†å®šä½éŒ¯èª¤
      getGeolocationError(error) {
        // ... (ä¿æŒä¸è®Š)
      }
      
      // è¨­ç½®ç‰©å“è­˜åˆ¥ç›¸æ©Ÿ
      async setupRecognitionCamera() {
        const video = document.getElementById('recognitionVideo');
        const overlayCanvas = document.getElementById('recognitionOverlayCanvas');

        try {
          if (recognitionStream) {
            recognitionStream.getTracks().forEach(track => track.stop());
          }
          
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { 
              facingMode: recognitionCameraFacingMode,
              width: { ideal: 640 },
              height: { ideal: 480 }
            }
          });
          
          recognitionStream = stream;
          video.srcObject = stream;
          document.getElementById('recognitionCameraPreview').style.display = 'none';
          this.clearOverlay(); // æ¸…é™¤èˆŠçš„é‚Šç•Œæ¡†

          return new Promise((resolve) => {
            video.onloadedmetadata = () => { 
              video.play();
              // è¨­ç½® Canvas å°ºå¯¸èˆ‡ Video å°ºå¯¸åŒæ­¥
              overlayCanvas.width = video.videoWidth;
              overlayCanvas.height = video.videoHeight;
              resolve(video); 
            };
          });
        } catch (error) {
          updateVoice('ç„¡æ³•é–‹å•Ÿç›¸æ©Ÿ');
          console.error('ç›¸æ©Ÿé–‹å•Ÿå¤±æ•—:', error);
          showError('ç„¡æ³•é–‹å•Ÿç›¸æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­å®š');
          return null;
        }
      }

      // æ›´æ–°æ¨¡å¼æŒ‡ç¤ºå™¨
      updateModeIndicator(mode) {
        // ... (ä¿æŒä¸è®Š)
      }

      // è¼‰å…¥å„²å­˜çš„ä½ç½®
      loadSavedLocations() {
        // ... (ä¿æŒä¸è®Š)
      }
    }

    // å…¨åŸŸè®Šæ•¸
    const assistant = new SmartAssistant();
    let voiceEnabled = true;

    // åˆå§‹åŒ–
    function init() {
      // ... (ä¿æŒä¸è®Š)
      // åˆå§‹åŒ–AGPS
      setTimeout(() => {
        assistant.initAGPS().then(() => {
          assistant.initModel();
        });
      }, 1000);
    }

    // åˆå§‹åŒ–æ¨™ç±¤ç³»çµ±
    function initTabSystem() {
      // ... (ä¿æŒä¸è®Š)
    }

    // å°èˆªç³»çµ±å‡½æ•¸
    function initEventListeners() {
      // ... (ä¿æŒä¸è®Š)
    }

    // ç›¸æ©Ÿè¨­ç½®
    async function setupCamera() {
      // ... (ä¿æŒä¸è®Š)
    }

    // Start detection
    function startDetection() {
      // ... (ä¿æŒä¸è®Š)
    }

    // æ¸¬è©¦æª¢æ¸¬
    function testDetection() {
      // ... (ä¿æŒä¸è®Š)
    }


    // åœæ­¢æª¢æ¸¬
    function stopDetection() {
      // ... (ä¿æŒä¸è®Š)
    }

    // æ›´æ–°æª¢æ¸¬é¡¯ç¤º
    function updateDetectionDisplay(obstacles) {
      // ... (ä¿æŒä¸è®Š)
    }

    function clearDetectionDisplay() {
      // ... (ä¿æŒä¸è®Š)
    }

    // å°èˆªç›¸é—œå‡½æ•¸
    function startNavigationHome() {
      assistant.startNavigationHome();
    }

    function openGoogleMaps() {
      assistant.openGoogleMapsNavigation();
    }


    function setHomeLocation() {
      assistant.setHomeLocation().catch(error => {
        updateVoice(error);
        showError(error);
      });
    }

    // åˆ‡æ›ç‰©å“è­˜åˆ¥ç›¸æ©Ÿ
    function switchRecognitionCamera() {
      // ... (ä¿æŒä¸è®Š)
    }

    // å·¥å…·å‡½æ•¸
    function updateVoice(message) {
      // ... (ä¿æŒä¸è®Š)
    }

    function updateStatus(status) {
      // ... (ä¿æŒä¸è®Š)
    }

    function updateCameraStatus(status) {
      // ... (ä¿æŒä¸è®Š)
    }

    function updateDetectionStatus(status) {
      // ... (ä¿æŒä¸è®Š)
    }

    function showDebugInfo(message) {
      // ... (ä¿æŒä¸è®Š)
    }

    function showError(message) {
      // ... (ä¿æŒä¸è®Š)
    }

    function hideError() {
      // ... (ä¿æŒä¸è®Š)
    }

    function showModelProgress(message, percent) {
      // ... (ä¿æŒä¸è®Š)
    }

    function hideModelProgress() {
      // ... (ä¿æŒä¸è®Š)
    }

    // åŒ…è£å‡½æ•¸
    function startItemRecognition() {
      assistant.startItemRecognition();
    }

    function toggleContinuousMode() {
      assistant.toggleContinuousMode();
    }

    function toggleVoice() {
      // ... (ä¿æŒä¸è®Š)
    }

    function repeatInstruction() {
      // ... (ä¿æŒä¸è®Š)
    }

    function filterItems() {
      assistant.filterDisplayedItems();
    }

    // é é¢è¼‰å…¥æ™‚åˆå§‹åŒ–
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>