<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆªç³»çµ± - å³æ™‚éšœç¤™ç‰©æª¢æ¸¬èˆ‡GPSè¿”èˆª" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</title>
  
  <!-- PWA æ”¯æŒ -->
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§­</text></svg>">
  
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    /* ä¿æŒåŸæœ‰çš„ CSS æ¨£å¼ä¸è®Š */
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    
    @media (min-width: 920px) {
      .app {
        grid-template-columns: 6fr 4fr;
      }
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    header.card {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: clamp(18px, 5vw, 24px);
      margin: 0;
      font-weight: 700;
    }
    
    header .tips {
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    
    @media (min-width: 768px) {
      header .tips {
        display: block;
      }
    }
    
    .camera {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
    }
    
    .camera video, .camera canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    
    .camera video {
      transform: scaleX(-1);
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    @media (min-width: 480px) {
      .controls {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .primary {
      background: var(--good);
      color: #fff;
    }
    
    .warning {
      background: var(--warn);
      color: #fff;
    }
    
    .danger {
      background: var(--bad);
      color: #fff;
    }
    
    .secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, 1fr);
      margin-bottom: 12px;
    }
    
    @media (min-width: 480px) {
      .status {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .k {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .v {
      font-weight: 800;
      font-size: clamp(14px, 4vw, 16px);
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .list {
      max-height: 200px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
      padding-right: 4px;
      -webkit-overflow-scrolling: touch;
    }
    
    .chip {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }
    
    .module-tag {
      display: inline-block;
      background: var(--warn);
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 10px;
      margin-left: 8px;
      font-weight: 600;
    }
    
    .gps-active {
      background: var(--good) !important;
    }
    
    .emergency-alert {
      animation: pulse 1s infinite;
      border: 2px solid var(--bad);
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    .obstacle-warning {
      background: rgba(245,158,11,0.3);
      border: 2px solid var(--warn);
    }
    
    .danger-warning {
      background: rgba(239,68,68,0.3);
      border: 2px solid var(--bad);
    }
    
    @keyframes pulse {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
      100% {
        opacity: 1;
      }
    }
    
    @keyframes loading {
      0% {
        background-position: 200% 0;
      }
      100% {
        background-position: -200% 0;
      }
    }
    
    /* æ‰‹æ©Ÿå„ªåŒ– */
    @media (max-width: 480px) {
      body {
        padding: 8px;
      }
      
      .panel {
        padding: 12px;
      }
      
      button.btn {
        padding: 14px 10px;
        font-size: 13px;
        min-height: 50px;
      }
      
      .status-item {
        padding: 10px;
      }
      
      .voice-alert {
        padding: 14px;
        min-height: 55px;
        font-size: 14px;
      }
    }
    
    /* é˜²æ­¢æ–‡å­—é¸æ“‡ */
    .no-select {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body class="no-select">
  <div class="app">
    <header class="card">
      <h1>ğŸ§­ ç›²äººè¼”åŠ©å°èˆª</h1>
      <div class="tips">å®‰å…¨å‡ºè¡Œ Â· éšœç¤™æª¢æ¸¬ Â· GPSå°èˆª</div>
    </header>

    <section class="card camera">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
    </section>

    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">ç³»çµ±åˆå§‹åŒ–ä¸­â€¦</div>
      
      <!-- ä¸»è¦æ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnStart" class="btn primary">é–‹å§‹æª¢æ¸¬</button>
        <button id="btnVoice" class="btn warning">èªéŸ³é–‹å•Ÿ</button>
        <button id="btnMode" class="btn primary">æ­¥è¡Œæ¨¡å¼</button>
        <button id="btnStop" class="btn danger">åœæ­¢</button>
      </div>
      
      <!-- å°èˆªæ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnSetHome" class="btn primary">è¨­å®šå®¶çš„ä½ç½®</button>
        <button id="btnReturnHome" class="btn warning">ä¸€éµè¿”èˆª</button>
        <button id="btnLoadModule" class="btn primary">åˆ‡æ›ç’°å¢ƒ</button>
        <button id="btnEmergency" class="btn danger">ç·Šæ€¥æ±‚åŠ©</button>
      </div>

      <!-- ç‹€æ…‹è³‡è¨Š -->
      <div class="status">
        <div class="status-item">
          <div class="k">ç³»çµ±ç‹€æ…‹</div>
          <div class="v" id="status">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="k">åµæ¸¬é€Ÿåº¦</div>
          <div class="v" id="fps">â€”</div>
        </div>
        <div class="status-item">
          <div class="k">éšœç¤™ç‰©æ•¸</div>
          <div class="v" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="k">æœ€è¿‘è·é›¢</div>
          <div class="v" id="closestDistance">â€” å…¬å°º</div>
        </div>
      </div>
      
      <div class="status">
        <div class="status-item">
          <div class="k">GPSç‹€æ…‹</div>
          <div class="v" id="gpsStatus">æœªé€£æ¥</div>
        </div>
        <div class="status-item">
          <div class="k">è·å®¶è·é›¢</div>
          <div class="v" id="homeDistance">--</div>
        </div>
        <div class="status-item">
          <div class="k">ç•¶å‰ç’°å¢ƒ</div>
          <div class="v" id="currentModule">æˆ¶å¤–</div>
        </div>
        <div class="status-item">
          <div class="k">èªéŸ³ç‹€æ…‹</div>
          <div class="v" id="voiceStatus">é–‹å•Ÿ</div>
        </div>
      </div>
    </section>

    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">
        å³æ™‚åµæ¸¬ <span id="activeModuleTag" class="module-tag">æˆ¶å¤–æ¨¡å¼</span>
      </h3>
      <div id="detectionList" class="list">
        <div class="chip" style="text-align:center; color:var(--muted);">
          ç­‰å¾…é–‹å§‹åµæ¸¬â€¦
        </div>
      </div>
      <footer>
        å°ˆç‚ºè¦–éšœæœ‹å‹è¨­è¨ˆ Â· å®‰å…¨å‡ºè¡Œä¼´ä¾¶<br>
        è«‹åœ¨å…‰ç·šå……è¶³ç’°å¢ƒä½¿ç”¨ä»¥ç²å¾—æœ€ä½³æ•ˆæœ
      </footer>
    </aside>
  </div>

  <script>
    /**********************
     * 1) åƒæ•¸å€ - ä½¿ç”¨å¯è¨ªå•çš„æ¨¡å‹
     **********************/
    // ä½¿ç”¨ CDN ä¸Šçš„æ¨¡å‹ï¼Œé¿å… CORS å•é¡Œ
    const MODEL_URL = 'https://cdn.jsdelivr.net/gh/ultralytics/assets@main/yolov8n.onnx';
    // å‚™ç”¨æ¨¡å‹ URL
    const BACKUP_MODEL_URL = 'https://models.roboflow.com/object-detection/yolov8n/1/model.onnx';
    // æœ¬åœ°æ¨¡å‹ URLï¼ˆå¦‚æœå·²ä¸‹è½½æ¨¡å‹æ–‡ä»¶ï¼‰
    const LOCAL_MODEL_URL = '/yolov8n.onnx';
    
    const INPUT_SIZE = 640;
    const SCORE_THR_BASE = 0.35;
    const IOU_THR = 0.5;

    const TARGET_FPS = 15;
    const INTERVAL = 1000 / TARGET_FPS;

    // COCO80 é¡åˆ¥ï¼ˆè‹±â†’ä¸­ï¼‰
    const coco80 = [
      'person','bicycle','car','motorcycle','airplane','bus','train','truck','boat','traffic light',
      'fire hydrant','stop sign','parking meter','bench','bird','cat','dog','horse','sheep','cow',
      'elephant','bear','zebra','giraffe','backpack','umbrella','handbag','tie','suitcase','frisbee',
      'skis','snowboard','sports ball','kite','baseball bat','baseball glove','skateboard','surfboard','tennis racket','bottle',
      'wine glass','cup','fork','knife','spoon','bowl','banana','apple','sandwich','orange',
      'broccoli','carrot','hot dog','pizza','donut','cake','chair','couch','potted plant','bed',
      'dining table','toilet','tv','laptop','mouse','remote','keyboard','cell phone','microwave','oven',
      'toaster','sink','refrigerator','book','clock','vase','scissors','teddy bear','hair drier','toothbrush'
    ];
    
    const zhMap = {
      'person':'è¡Œäºº','bicycle':'è‡ªè¡Œè»Š','car':'æ±½è»Š','motorcycle':'æ‘©æ‰˜è»Š','airplane':'é£›æ©Ÿ','bus':'å…¬è»Š','train':'ç«è»Š','truck':'å¡è»Š','boat':'èˆ¹','traffic light':'ç´…ç¶ ç‡ˆ',
      'fire hydrant':'æ¶ˆé˜²æ “','stop sign':'åœæ­¢æ¨™èªŒ','parking meter':'åœè»Šè¨ˆæ™‚å™¨','bench':'é•·æ¤…','bird':'é³¥','cat':'è²“','dog':'ç‹—','horse':'é¦¬','sheep':'ç¶¿ç¾Š','cow':'ç‰›',
      'elephant':'å¤§è±¡','bear':'ç†Š','zebra':'æ–‘é¦¬','giraffe':'é•·é ¸é¹¿','backpack':'èƒŒåŒ…','umbrella':'é›¨å‚˜','handbag':'æ‰‹æåŒ…','tie':'é ˜å¸¶','suitcase':'è¡Œæç®±','frisbee':'é£›ç›¤',
      'skis':'æ»‘é›ªæ¿','snowboard':'å–®æ¿æ»‘é›ª','sports ball':'çƒ','kite':'é¢¨ç®','baseball bat':'æ£’çƒæ£’','baseball glove':'æ£’çƒæ‰‹å¥—','skateboard':'æ»‘æ¿','surfboard':'è¡æµªæ¿','tennis racket':'ç¶²çƒæ‹','bottle':'ç“¶å­',
      'wine glass':'ç´…é…’æ¯','cup':'æ¯å­','fork':'å‰å­','knife':'åˆ€å­','spoon':'æ¹¯åŒ™','bowl':'ç¢—','banana':'é¦™è•‰','apple':'è˜‹æœ','sandwich':'ä¸‰æ˜æ²»','orange':'æ©˜å­',
      'broccoli':'èŠ±æ¤°èœ','carrot':'ç´…è˜¿è””','hot dog':'ç†±ç‹—','pizza':'æŠ«è–©','donut':'ç”œç”œåœˆ','cake':'è›‹ç³•','chair':'æ¤…å­','couch':'æ²™ç™¼','potted plant':'ç›†æ ½','bed':'åºŠ',
      'dining table':'é¤æ¡Œ','toilet':'é¦¬æ¡¶','tv':'é›»è¦–','laptop':'ç­†é›»','mouse':'æ»‘é¼ ','remote':'é™æ§å™¨','keyboard':'éµç›¤','cell phone':'æ‰‹æ©Ÿ','microwave':'å¾®æ³¢çˆ','oven':'çƒ¤ç®±',
      'toaster':'çƒ¤éºµåŒ…æ©Ÿ','sink':'æ°´æ§½','refrigerator':'å†°ç®±','book':'æ›¸','clock':'æ™‚é˜','vase':'èŠ±ç“¶','scissors':'å‰ªåˆ€','teddy bear':'æ³°è¿ªç†Š','hair drier':'å¹é¢¨æ©Ÿ','toothbrush':'ç‰™åˆ·'
    };

    const MODE_PROFILE = { 
      walking: { nearM: 4, highObjM: 8, scoreThr: 0.45 }, 
      navigate: { nearM: 6, highObjM: 10, scoreThr: 0.4 } 
    };

    /**********************
     * 2) ç’°å¢ƒæ¨¡çµ„ç³»çµ±
     **********************/
    const environmentModules = {
      outdoor: {
        name: 'æˆ¶å¤–å°èˆª',
        objects: {
          'car': { name: 'æ±½è»Š', danger: 'high', voice: 'å‰æ–¹æœ‰æ±½è»Šï¼Œè«‹ä¿æŒå®‰å…¨è·é›¢' },
          'motorcycle': { name: 'æ‘©æ‰˜è»Š', danger: 'high', voice: 'æ³¨æ„ï¼å‰æ–¹æœ‰æ‘©æ‰˜è»Š' },
          'bus': { name: 'å…¬è»Š', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å…¬è»Š' },
          'truck': { name: 'å¡è»Š', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å¡è»Š' },
          'bicycle': { name: 'è…³è¸è»Š', danger: 'medium', voice: 'å‰æ–¹æœ‰è…³è¸è»Š' },
          'traffic light': { name: 'ç´…ç¶ ç‡ˆ', danger: 'medium', voice: 'å‰æ–¹æœ‰ç´…ç¶ ç‡ˆï¼Œè«‹æ³¨æ„äº¤é€šè™ŸèªŒ' },
          'stop sign': { name: 'åœæ­¢æ¨™èªŒ', danger: 'medium', voice: 'åœæ­¢æ¨™èªŒï¼Œè«‹åœè»Šè§€å¯Ÿ' },
          'person': { name: 'è¡Œäºº', danger: 'medium', voice: 'å‰æ–¹æœ‰è¡Œäºº' },
          'bench': { name: 'å…¬è»Šç«™', danger: 'low', voice: 'å…¬è»Šç«™' },
          'fire hydrant': { name: 'æ¶ˆé˜²æ “', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¶ˆé˜²æ “' },
          'bird': { name: 'é³¥', danger: 'low', voice: 'å‰æ–¹æœ‰å°é³¥' },
          'dog': { name: 'ç‹—', danger: 'medium', voice: 'å‰æ–¹æœ‰ç‹—ï¼Œè«‹å°å¿ƒ' },
          'cat': { name: 'è²“', danger: 'low', voice: 'å‰æ–¹æœ‰è²“' }
        },
        voiceMessages: {
          'high': 'è­¦å‘Šï¼å‰æ–¹æœ‰å±éšªéšœç¤™ç‰©',
          'medium': 'æ³¨æ„ï¼å‰æ–¹æœ‰éšœç¤™ç‰©',
          'low': 'å‰æ–¹æœ‰éšœç¤™ç‰©'
        },
        triggers: ['car', 'motorcycle', 'bus', 'traffic light', 'stop sign', 'person']
      },
      kitchen: {
        name: 'å»šæˆ¿ç’°å¢ƒ',
        objects: {
          'knife': { name: 'åˆ€å­', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰åˆ€å­ï¼Œé‹’åˆ©ç‰©å“è«‹å°å¿ƒ' },
          'cup': { name: 'æ¯å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¯å­ï¼Œè«‹å°å¿ƒæ‹¿å–' },
          'fork': { name: 'å‰å­', danger: 'medium', voice: 'å‰æ–¹æœ‰å‰å­ï¼Œè«‹æ³¨æ„å°–é½’' },
          'spoon': { name: 'æ¹¯åŒ™', danger: 'low', voice: 'å‰æ–¹æœ‰æ¹¯åŒ™' },
          'bowl': { name: 'ç¢—', danger: 'medium', voice: 'å‰æ–¹æœ‰ç¢—' },
          'oven': { name: 'çƒ¤ç®±', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰çƒ¤ç®±ï¼Œé«˜æº«è¨­å‚™è«‹å°å¿ƒ' },
          'microwave': { name: 'å¾®æ³¢çˆ', danger: 'high', voice: 'æ³¨æ„ï¼å‰æ–¹æœ‰å¾®æ³¢çˆ' },
          'refrigerator': { name: 'å†°ç®±', danger: 'medium', voice: 'å‰æ–¹æœ‰å†°ç®±' },
          'sink': { name: 'æ°´æ§½', danger: 'medium', voice: 'å‰æ–¹æœ‰æ°´æ§½' },
          'bottle': { name: 'ç“¶å­', danger: 'medium', voice: 'å‰æ–¹æœ‰ç“¶å­' },
          'toaster': { name: 'çƒ¤éºµåŒ…æ©Ÿ', danger: 'medium', voice: 'å‰æ–¹æœ‰çƒ¤éºµåŒ…æ©Ÿ' }
        },
        voiceMessages: {
          'high': 'å»šæˆ¿è­¦å‘Šï¼å‰æ–¹æœ‰å±éšªç‰©å“',
          'medium': 'å»šæˆ¿æ³¨æ„ï¼å‰æ–¹æœ‰ç‰©å“',
          'low': 'å»šæˆ¿å‰æ–¹æœ‰ç‰©å“'
        },
        triggers: ['knife', 'oven', 'microwave', 'cup', 'bottle']
      },
      bathroom: {
        name: 'æµ´å®¤ç’°å¢ƒ',
        objects: {
          'toilet': { name: 'é¦¬æ¡¶', danger: 'medium', voice: 'å‰æ–¹æœ‰é¦¬æ¡¶' },
          'sink': { name: 'æ´—æ‰‹å°', danger: 'medium', voice: 'å‰æ–¹æœ‰æ´—æ‰‹å°' },
          'bottle': { name: 'æ´—é«®ç²¾', danger: 'low', voice: 'å‰æ–¹æœ‰æ´—é«®ç²¾' },
          'toothbrush': { name: 'ç‰™åˆ·', danger: 'low', voice: 'å‰æ–¹æœ‰ç‰™åˆ·' },
          'hair drier': { name: 'å¹é¢¨æ©Ÿ', danger: 'medium', voice: 'å‰æ–¹æœ‰å¹é¢¨æ©Ÿ' }
        },
        voiceMessages: {
          'high': 'æµ´å®¤è­¦å‘Šï¼å°å¿ƒæ»‘å€’',
          'medium': 'æµ´å®¤æ³¨æ„å‰æ–¹',
          'low': 'æµ´å®¤ç‰©å“'
        },
        triggers: ['toilet', 'sink', 'bottle']
      },
      office: {
        name: 'è¾¦å…¬å®¤ç’°å¢ƒ',
        objects: {
          'chair': { name: 'è¾¦å…¬æ¤…', danger: 'medium', voice: 'å‰æ–¹æœ‰è¾¦å…¬æ¤…ï¼Œè«‹æ³¨æ„æ—‹è½‰' },
          'laptop': { name: 'ç­†é›»', danger: 'low', voice: 'å‰æ–¹æœ‰ç­†é›»' },
          'keyboard': { name: 'éµç›¤', danger: 'low', voice: 'å‰æ–¹æœ‰éµç›¤' },
          'mouse': { name: 'æ»‘é¼ ', danger: 'low', voice: 'å‰æ–¹æœ‰æ»‘é¼ ' },
          'book': { name: 'æ–‡ä»¶', danger: 'low', voice: 'å‰æ–¹æœ‰æ–‡ä»¶' },
          'cell phone': { name: 'æ‰‹æ©Ÿ', danger: 'low', voice: 'å‰æ–¹æœ‰æ‰‹æ©Ÿ' },
          'clock': { name: 'æ™‚é˜', danger: 'low', voice: 'å‰æ–¹æœ‰æ™‚é˜' }
        },
        voiceMessages: {
          'high': 'è¾¦å…¬å®¤è­¦å‘Šï¼',
          'medium': 'è¾¦å…¬å®¤æ³¨æ„',
          'low': 'è¾¦å…¬å®¤ç‰©å“'
        },
        triggers: ['chair', 'laptop', 'desk']
      },
      hospital: {
        name: 'é†«é™¢ç’°å¢ƒ',
        objects: {
          'person': { name: 'é†«è­·äººå“¡', danger: 'low', voice: 'å‰æ–¹æœ‰é†«è­·äººå“¡' },
          'chair': { name: 'å€™è¨ºæ¤…', danger: 'medium', voice: 'å‰æ–¹æœ‰å€™è¨ºæ¤…' },
          'bed': { name: 'ç—…åºŠ', danger: 'medium', voice: 'å‰æ–¹æœ‰ç—…åºŠ' },
          'bench': { name: 'ç­‰å€™æ¤…', danger: 'medium', voice: 'å‰æ–¹æœ‰ç­‰å€™æ¤…' }
        },
        voiceMessages: {
          'high': 'é†«é™¢è­¦å‘Šï¼è«‹å°å¿ƒ',
          'medium': 'é†«é™¢æ³¨æ„',
          'low': 'é†«é™¢è¨­æ–½'
        },
        triggers: ['person', 'chair', 'bed']
      },
      supermarket: {
        name: 'è¶…å¸‚ç’°å¢ƒ',
        objects: {
          'person': { name: 'é¡§å®¢', danger: 'medium', voice: 'å‰æ–¹æœ‰é¡§å®¢' },
          'bottle': { name: 'å•†å“', danger: 'low', voice: 'å‰æ–¹æœ‰å•†å“æ¶' },
          'cart': { name: 'è³¼ç‰©è»Š', danger: 'medium', voice: 'å‰æ–¹æœ‰è³¼ç‰©è»Š' },
          'bench': { name: 'è²¨æ¶', danger: 'medium', voice: 'å‰æ–¹æœ‰è²¨æ¶' }
        },
        voiceMessages: {
          'high': 'è¶…å¸‚è­¦å‘Šï¼',
          'medium': 'è¶…å¸‚æ³¨æ„',
          'low': 'è¶…å¸‚å•†å“'
        },
        triggers: ['person', 'bottle']
      }
    };

    /**********************
     * 3) GPSå°èˆªç³»çµ±
     **********************/
    class GPSNavigator {
      constructor() {
        this.homePosition = null;
        this.currentPosition = null;
        this.isTracking = false;
        this.watchId = null;
        this.returnHomeInterval = null;
        this.loadHomePosition();
      }

      loadHomePosition() {
        const saved = localStorage.getItem('homePosition');
        if (saved) {
          this.homePosition = JSON.parse(saved);
          updateGPSStatus('å°±ç·’');
        }
      }

      setHomePosition() {
        if (!navigator.geolocation) {
          updateVoice('æ‚¨çš„è£ç½®ä¸æ”¯æ´GPSå®šä½');
          return;
        }

        updateVoice('æ­£åœ¨ç²å–ç•¶å‰ä½ç½®...');
        navigator.geolocation.getCurrentPosition(
          (position) => {
            this.homePosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              timestamp: new Date().toISOString()
            };
            localStorage.setItem('homePosition', JSON.stringify(this.homePosition));
            updateVoice(`å®¶çš„ä½ç½®å·²è¨˜éŒ„ï¼ç¶“åº¦: ${this.homePosition.lng.toFixed(6)}, ç·¯åº¦: ${this.homePosition.lat.toFixed(6)}`);
            updateGPSStatus('å·²è¨­å®šå®¶');
            document.getElementById('btnSetHome').classList.add('gps-active');
          },
          (error) => {
            let errorMsg = 'ç„¡æ³•ç²å–ä½ç½®ï¼š';
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMsg += 'è«‹å…è¨±ä½ç½®æ¬Šé™';
                break;
              case error.POSITION_UNAVAILABLE:
                errorMsg += 'ä½ç½®è³‡è¨Šä¸å¯ç”¨';
                break;
              case error.TIMEOUT:
                errorMsg += 'å®šä½è«‹æ±‚è¶…æ™‚';
                break;
              default:
                errorMsg += 'æœªçŸ¥éŒ¯èª¤';
            }
            updateVoice(errorMsg);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          }
        );
      }

      startReturnHome() {
        if (!this.homePosition) {
          updateVoice('è«‹å…ˆè¨­å®šå®¶çš„ä½ç½®');
          return;
        }

        this.isTracking = true;
        updateVoice('é–‹å§‹è¿”èˆªå°èˆªï¼Œè«‹è·Ÿéš¨èªéŸ³æŒ‡å¼•');
        updateGPSStatus('è¿”èˆªä¸­');
        document.getElementById('btnReturnHome').classList.add('gps-active');

        // é–‹å§‹ç›£è½ä½ç½®
        this.watchId = navigator.geolocation.watchPosition(
          (position) => {
            this.currentPosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              accuracy: position.coords.accuracy
            };
            this.updateNavigation();
          },
          (error) => {
            updateVoice('GPSä¿¡è™Ÿä¸ç©©å®š');
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 3000
          }
        );

        // æ¯10ç§’æ›´æ–°ä¸€æ¬¡å°èˆª
        this.returnHomeInterval = setInterval(() => {
          if (this.currentPosition) {
            this.updateNavigation();
          }
        }, 10000);
      }

      updateNavigation() {
        const navInfo = this.calculateNavigation();
        if (!navInfo) return;

        const { distance, bearing, direction } = navInfo;
        document.getElementById('homeDistance').textContent = `${distance}m`;

        // èªéŸ³å°èˆªé‚è¼¯
        if (distance < 20) {
          updateVoice(`å·²åˆ°é”å®¶é™„è¿‘ï¼Œè·é›¢${Math.round(distance)}å…¬å°º`);
          this.stopReturnHome();
        } else if (distance < 100) {
          updateVoice(`å³å°‡åˆ°å®¶ï¼Œè·é›¢${Math.round(distance)}å…¬å°ºï¼Œè«‹å‘${direction}å‰é€²`);
        } else {
          updateVoice(`è·å®¶${Math.round(distance)}å…¬å°ºï¼Œè«‹å‘${direction}å‰é€²`);
        }
      }

      calculateNavigation() {
        if (!this.currentPosition || !this.homePosition) return null;

        const R = 6371000; // åœ°çƒåŠå¾‘(å…¬å°º)
        const Ï†1 = this.currentPosition.lat * Math.PI/180;
        const Ï†2 = this.homePosition.lat * Math.PI/180;
        const Î”Ï† = (this.homePosition.lat - this.currentPosition.lat) * Math.PI/180;
        const Î”Î» = (this.homePosition.lng - this.currentPosition.lng) * Math.PI/180;

        const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                  Math.cos(Ï†1) * Math.cos(Ï†2) *
                  Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = Math.round(R * c);

        const y = Math.sin(Î”Î») * Math.cos(Ï†2);
        const x = Math.cos(Ï†1) * Math.sin(Ï†2) -
                  Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î”Î»);
        const Î¸ = Math.atan2(y, x);
        const bearing = (Î¸ * 180/Math.PI + 360) % 360;

        const direction = this.getDirectionFromBearing(bearing);
        return { distance, bearing, direction };
      }

      getDirectionFromBearing(bearing) {
        const directions = ['åŒ—', 'æ±åŒ—', 'æ±', 'æ±å—', 'å—', 'è¥¿å—', 'è¥¿', 'è¥¿åŒ—'];
        const index = Math.round(bearing / 45) % 8;
        return directions[index];
      }

      stopReturnHome() {
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
          this.watchId = null;
        }
        if (this.returnHomeInterval) {
          clearInterval(this.returnHomeInterval);
          this.returnHomeInterval = null;
        }
        this.isTracking = false;
        updateGPSStatus('å°±ç·’');
        document.getElementById('btnReturnHome').classList.remove('gps-active');
        updateVoice('è¿”èˆªå°èˆªçµæŸ');
      }

      getCurrentLocation() {
        return new Promise((resolve, reject) => {
          if (!navigator.geolocation) {
            reject(new Error('GPS not supported'));
            return;
          }

          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          });
        });
      }
    }

    /**********************
     * 4) ç‹€æ…‹è®Šæ•¸
     **********************/
    let session = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let currentMode = 'walking';
    let lastTick = 0;
    let frames = 0;
    let lastFpsTs = 0;
    let lastSpeechAt = 0;
    let lastSaid = {cls: null, at: 0};
    let currentEnvironment = 'outdoor';
    let gpsNavigator = new GPSNavigator();

    /**********************
     * 5) åˆå§‹åŒ– / ç›¸æ©Ÿ
     **********************/
    async function initModel() {
      try {
        updateVoice('æ­£åœ¨åˆå§‹åŒ– ONNX Runtime Webâ€¦');
        ort.env.wasm.numThreads = 2;
        const opts = { executionProviders: ['wasm'] }; // ä½¿ç”¨ WASM ç¢ºä¿å…¼å®¹æ€§
        
        updateVoice('è¼‰å…¥ YOLOv8n æ¨¡å‹â€¦');
        
        // é¡¯ç¤ºè¼‰å…¥é€²åº¦
        const voiceAlert = document.getElementById('voiceAlert');
        voiceAlert.classList.add('loading');
        
        try {
          session = await ort.InferenceSession.create(MODEL_URL, opts);
        } catch (e) {
          console.log('ä¸»è¦æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œå˜—è©¦å‚™ç”¨æ¨¡å‹:', e);
          updateVoice('ä¸»è¦æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œå˜—è©¦è¼‰å…¥å‚™ç”¨æ¨¡å‹â€¦');
          try {
            session = await ort.InferenceSession.create(BACKUP_MODEL_URL, opts);
          } catch (backupError) {
            console.log('å‚™ç”¨æ¨¡å‹ä¹Ÿå¤±æ•—:', backupError);
            updateVoice('å‚™ç”¨æ¨¡å‹ä¹Ÿå¤±æ•—ï¼Œå˜—è©¦è¼‰å…¥æœ¬åœ°æ¨¡å‹â€¦');
            try {
              session = await ort.InferenceSession.create(LOCAL_MODEL_URL, opts);
            } catch (localError) {
              console.log('æœ¬åœ°æ¨¡å‹ä¹Ÿå¤±æ•—:', localError);
              throw new Error('æ‰€æœ‰æ¨¡å‹æºéƒ½ç„¡æ³•è¼‰å…¥ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥æˆ–ç¢ºä¿æœ¬åœ°æ¨¡å‹æª”æ¡ˆå­˜åœ¨');
            }
          }
        }
        
        // ç§»é™¤è¼‰å…¥å‹•ç•«
        voiceAlert.classList.remove('loading');
        updateVoice('æ¨¡å‹è¼‰å…¥å®Œæˆï¼é»æ“Šã€Œé–‹å§‹æª¢æ¸¬ã€é–‹å§‹ä½¿ç”¨');
        
        // åˆå§‹åŒ–äº‹ä»¶ç›£è½
        initEventListeners();
      } catch (e) {
        console.error('æ¨¡å‹è¼‰å…¥éŒ¯èª¤:', e); 
        updateVoice('æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼š' + e.message);
        document.getElementById('voiceAlert').classList.remove('loading');
        
        // æä¾›éŒ¯èª¤è§£æ±ºå»ºè­°
        if (e.message.includes('Failed to fetch')) {
          updateVoice('æ¨¡å‹ä¸‹è¼‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥æˆ–åˆ·æ–°é é¢é‡è©¦');
        }
      }
    }

    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnMode').addEventListener('click', toggleMode);
      document.getElementById('btnSetHome').addEventListener('click', () => gpsNavigator.setHomePosition());
      document.getElementById('btnReturnHome').addEventListener('click', () => gpsNavigator.startReturnHome());
      document.getElementById('btnLoadModule').addEventListener('click', loadEnvironmentModule);
      document.getElementById('btnEmergency').addEventListener('click', emergencyAlert);
    }

    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment', 
            width: { ideal: 1280 }, 
            height: { ideal: 720 } 
          }, 
          audio: false 
        });
        video.srcObject = stream; 
        await new Promise((resolve) => {
          video.onloadedmetadata = () => { resolve(video); };
        }); 
        return video;
      } catch (e) { 
        console.error('ç›¸æ©ŸéŒ¯èª¤:', e); 
        updateVoice('ç„¡æ³•å­˜å–ç›¸æ©Ÿï¼Œè«‹ç¢ºèªæ¬Šé™/HTTPS'); 
        return null; 
      }
    }

    /**********************
     * 6) ä¸»æµç¨‹ï¼ˆæ¨è«–ï¼‰
     **********************/
    async function startDetection() {
      if (!session) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆï¼Œè«‹ç¨å€™');
        return;
      }
      const video = await setupCamera(); 
      if (!video) return;
      isDetecting = true; 
      updateStatus('æª¢æ¸¬ä¸­'); 
      updateVoice('é–‹å§‹éšœç¤™ç‰©æª¢æ¸¬â€¦');
      await runOnce(video);
      requestAnimationFrame((ts) => loop(video, ts));
    }

    function stopDetection() {
      isDetecting = false; 
      updateStatus('å·²åœæ­¢');
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      updateVoice('æª¢æ¸¬å·²åœæ­¢');
      gpsNavigator.stopReturnHome();
    }

    async function loop(video, ts = 0) {
      if (!isDetecting) return;
      if (ts - lastTick >= INTERVAL) {
        const { predictions, frameW } = await runOnce(video);
        processPredictions(predictions, frameW);
        draw(predictions);

        frames++; 
        if (!lastFpsTs) {
          lastFpsTs = ts;
        } else if (ts - lastFpsTs >= 500) {
          document.getElementById('fps').textContent = Math.round(frames * 1000 / (ts - lastFpsTs));
          frames = 0; 
          lastFpsTs = ts;
        }
        lastTick = ts;
      }
      requestAnimationFrame((n) => loop(video, n));
    }

    async function runOnce(video) {
      try {
        const frame = captureFrame(video);
        const { predictions, frameW } = await inference(frame);
        return { predictions, frameW };
      } catch (error) {
        console.error('æ¨ç†éŒ¯èª¤:', error);
        return { predictions: [], frameW: 640 };
      }
    }

    function captureFrame(video) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const { videoWidth: w, videoHeight: h } = video;
      canvas.width = INPUT_SIZE;
      canvas.height = INPUT_SIZE;
      
      // è¨ˆç®—ç¸®æ”¾ä¸¦ä¿æŒæ¯”ä¾‹
      const scale = INPUT_SIZE / Math.max(w, h);
      const scaledW = w * scale;
      const scaledH = h * scale;
      const xOffset = (INPUT_SIZE - scaledW) / 2;
      const yOffset = (INPUT_SIZE - scaledH) / 2;
      
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, INPUT_SIZE, INPUT_SIZE);
      ctx.drawImage(video, xOffset, yOffset, scaledW, scaledH);
      
      return ctx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
    }

    async function inference(imageData) {
      const [inferenceTensor, frameW] = preprocess(imageData);
      const feeds = { [session.inputNames[0]]: inferenceTensor };
      const results = await session.run(feeds);
      const predictions = postprocess(results, frameW);
      return { predictions, frameW };
    }

    function preprocess(imageData, modelWidth = INPUT_SIZE, modelHeight = INPUT_SIZE) {
      const { data, width, height } = imageData;
      const frameW = width;
      
      const input = new Float32Array(3 * modelWidth * modelHeight);
      let means = [0.485, 0.456, 0.406];
      let stds = [0.229, 0.224, 0.225];
      
      for (let c = 0; c < 3; c++) {
        for (let h = 0; h < modelHeight; h++) {
          for (let w = 0; w < modelWidth; w++) {
            let index = h * modelWidth + w;
            let pixel = data[index * 4 + c]; // RGBA
            input[c * modelWidth * modelHeight + h * modelWidth + w] = (pixel / 255.0 - means[c]) / stds[c];
          }
        }
      }
      
      const tensor = new ort.Tensor('float32', input, [1, 3, modelWidth, modelHeight]);
      return [tensor, frameW];
    }

    function postprocess(results, frameW) {
      const output = results[session.outputNames[0]];
      const predictions = [];
      const scoreThr = MODE_PROFILE[currentMode].scoreThr;
      
      for (let idx = 0; idx < output.dims[1]; idx++) {
        const data = output.data.slice(idx * output.dims[2], (idx + 1) * output.dims[2]);
        const scores = data.slice(4);
        const maxScore = Math.max(...scores);
        
        if (maxScore < scoreThr) continue;
        
        const classId = scores.indexOf(maxScore);
        if (classId >= coco80.length) continue;
        
        // è½‰æ›ç‚ºåƒç´ åº§æ¨™
        let [x, y, w, h] = data.slice(0, 4);
        x = (x - w / 2) * frameW;
        y = (y - h / 2) * frameW;
        w = w * frameW;
        h = h * frameW;
        
        // è¨ˆç®—è·é›¢ï¼ˆç°¡åŒ–ä¼°ç®—ï¼‰
        const distance = estimateDistance(w, h, classId);
        
        predictions.push({
          class: coco80[classId],
          score: maxScore,
          bbox: [x, y, w, h],
          distance: distance
        });
      }
      
      // NMS éæ¥µå¤§å€¼æŠ‘åˆ¶
      return nonMaxSuppression(predictions, IOU_THR);
    }

    function estimateDistance(width, height, classId) {
      // æ ¹æ“šç‰©é«”é¡åˆ¥å’Œåƒç´ å¤§å°ä¼°ç®—è·é›¢
      const className = coco80[classId];
      const pixelArea = width * height;
      
      // ä¸åŒç‰©é«”çš„åƒè€ƒå¤§å°ï¼ˆç¶“é©—å€¼ï¼‰
      const referenceSizes = {
        'person': 10000,     // äºº
        'car': 50000,        // æ±½è»Š
        'bicycle': 15000,    // è‡ªè¡Œè»Š
        'chair': 8000,       // æ¤…å­
        'bottle': 2000       // ç“¶å­
      };
      
      const refSize = referenceSizes[className] || 10000;
      const distance = Math.sqrt(refSize / pixelArea) * 10; // å…¬å°º
      
      return Math.min(distance, 50); // æœ€å¤§è·é›¢é™åˆ¶
    }

    function nonMaxSuppression(predictions, iouThr) {
      predictions.sort((a, b) => b.score - a.score);
      const selected = [];
      
      while (predictions.length > 0) {
        const current = predictions[0];
        selected.push(current);
        
        predictions = predictions.filter(pred => {
          const iou = calculateIOU(current.bbox, pred.bbox);
          return iou < iouThr;
        });
      }
      
      return selected;
    }

    function calculateIOU(box1, box2) {
      const [x1, y1, w1, h1] = box1;
      const [x2, y2, w2, h2] = box2;
      
      const xi1 = Math.max(x1, x2);
      const yi1 = Math.max(y1, y2);
      const xi2 = Math.min(x1 + w1, x2 + w2);
      const yi2 = Math.min(y1 + h1, y2 + h2);
      
      const interArea = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);
      const box1Area = w1 * h1;
      const box2Area = w2 * h2;
      
      return interArea / (box1Area + box2Area - interArea);
    }

    /**********************
     * 7) é æ¸¬è™•ç†èˆ‡ç¹ªåœ–
     **********************/
    function processPredictions(predictions, frameW) {
      const module = environmentModules[currentEnvironment];
      const relevantPredictions = predictions.filter(p => module.objects[p.class]);
      
      // æ›´æ–°éšœç¤™ç‰©è¨ˆæ•¸
      document.getElementById('obstacleCount').textContent = relevantPredictions.length;
      
      // æ‰¾åˆ°æœ€è¿‘éšœç¤™ç‰©
      let closestDistance = Infinity;
      let closestObject = null;
      
      relevantPredictions.forEach(pred => {
        if (pred.distance < closestDistance) {
          closestDistance = pred.distance;
          closestObject = pred;
        }
      });
      
      // æ›´æ–°æœ€è¿‘è·é›¢é¡¯ç¤º
      const distanceElement = document.getElementById('closestDistance');
      if (closestObject) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' å…¬å°º';
        
        // æ ¹æ“šè·é›¢æ·»åŠ è­¦å‘Šæ¨£å¼
        if (closestDistance < 2) {
          distanceElement.parentElement.classList.add('danger-warning');
        } else if (closestDistance < 5) {
          distanceElement.parentElement.classList.add('obstacle-warning');
        } else {
          distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
        }
      } else {
        distanceElement.textContent = 'â€” å…¬å°º';
        distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
      }
      
      // èªéŸ³è­¦å‘Š
      if (closestObject && voiceEnabled) {
        const now = Date.now();
        const cooldown = closestObject.distance < 3 ? 2000 : 4000;
        
        if (now - lastSpeechAt > cooldown) {
          const objConfig = module.objects[closestObject.class];
          let voiceMsg = objConfig.voice;
          
          if (closestObject.distance < 2) {
            voiceMsg = `ç·Šæ€¥ï¼${objConfig.name}éå¸¸æ¥è¿‘ï¼Œåƒ…${closestObject.distance.toFixed(1)}å…¬å°º`;
          } else if (closestObject.distance < 5) {
            voiceMsg = `æ³¨æ„ï¼${objConfig.name}æ¥è¿‘ï¼Œè·é›¢${closestObject.distance.toFixed(1)}å…¬å°º`;
          }
          
          updateVoice(voiceMsg);
          lastSpeechAt = now;
          lastSaid = { cls: closestObject.class, at: now };
        }
      }
      
      // æ›´æ–°åµæ¸¬åˆ—è¡¨
      updateDetectionList(relevantPredictions);
    }

    function updateDetectionList(predictions) {
      const list = document.getElementById('detectionList');
      const module = environmentModules[currentEnvironment];
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="chip" style="text-align:center; color:var(--muted);">æœªåµæ¸¬åˆ°éšœç¤™ç‰©</div>';
        return;
      }
      
      // æŒ‰è·é›¢æ’åº
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        const objConfig = module.objects[pred.class];
        const dangerLevel = objConfig ? objConfig.danger : 'low';
        const dangerColors = {
          'high': 'var(--bad)',
          'medium': 'var(--warn)', 
          'low': 'var(--good)'
        };
        
        return `
          <div class="chip" style="border-left: 4px solid ${dangerColors[dangerLevel]}">
            <strong>${objConfig ? objConfig.name : pred.class}</strong><br>
            è·é›¢: ${pred.distance.toFixed(1)}å…¬å°º | ç½®ä¿¡åº¦: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    function draw(predictions) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const video = document.getElementById('video');
      
      if (!video.videoWidth) return;
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // ç¹ªè£½é æ¸¬æ¡†
      predictions.forEach(pred => {
        const module = environmentModules[currentEnvironment];
        if (!module.objects[pred.class]) return;
        
        const [x, y, w, h] = pred.bbox;
        const objConfig = module.objects[pred.class];
        
        // æ ¹æ“šå±éšªç­‰ç´šé¸æ“‡é¡è‰²
        let color;
        switch(objConfig.danger) {
          case 'high': color = '#ef4444'; break;
          case 'medium': color = '#f59e0b'; break;
          default: color = '#22c55e';
        }
        
        // ç¹ªè£½é‚Šæ¡†
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        // ç¹ªè£½èƒŒæ™¯æ¨™ç±¤
        const label = `${objConfig.name} ${pred.distance.toFixed(1)}m`;
        ctx.font = '16px Arial';
        const textWidth = ctx.measureText(label).width;
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y - 25, textWidth + 10, 25);
        
        // ç¹ªè£½æ–‡å­—
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 5, y - 7);
      });
    }

    /**********************
     * 8) å·¥å…·å‡½æ•¸
     **********************/
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      // èªéŸ³åˆæˆ
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel(); // å–æ¶ˆä¹‹å‰çš„èªéŸ³
        
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateGPSStatus(status) {
      document.getElementById('gpsStatus').textContent = status;
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const status = document.getElementById('voiceStatus');
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        status.textContent = 'é–‹å•Ÿ';
        button.textContent = 'èªéŸ³é—œé–‰';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('èªéŸ³æç¤ºå·²é–‹å•Ÿ');
      } else {
        status.textContent = 'é—œé–‰';
        button.textContent = 'èªéŸ³é–‹å•Ÿ';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleMode() {
      const button = document.getElementById('btnMode');
      currentMode = currentMode === 'walking' ? 'navigate' : 'walking';
      
      if (currentMode === 'walking') {
        button.textContent = 'å°èˆªæ¨¡å¼';
        updateVoice('åˆ‡æ›åˆ°æ­¥è¡Œæ¨¡å¼');
      } else {
        button.textContent = 'æ­¥è¡Œæ¨¡å¼';
        updateVoice('åˆ‡æ›åˆ°å°èˆªæ¨¡å¼');
      }
    }

    function loadEnvironmentModule() {
      const environments = Object.keys(environmentModules);
      const currentIndex = environments.indexOf(currentEnvironment);
      const nextIndex = (currentIndex + 1) % environments.length;
      currentEnvironment = environments[nextIndex];
      
      const module = environmentModules[currentEnvironment];
      document.getElementById('currentModule').textContent = module.name;
      document.getElementById('activeModuleTag').textContent = module.name;
      
      updateVoice(`åˆ‡æ›åˆ°${module.name}ç’°å¢ƒ`);
    }

    function emergencyAlert() {
      const button = document.getElementById('btnEmergency');
      button.classList.add('emergency-alert');
      
      updateVoice('ç·Šæ€¥æ±‚åŠ©ï¼æ­£åœ¨ç™¼é€ä½ç½®è³‡è¨Šçµ¦ç·Šæ€¥è¯çµ¡äºº');
      
      // æ¨¡æ“¬ç™¼é€ç·Šæ€¥è¨Šæ¯
      if (gpsNavigator.currentPosition) {
        const { lat, lng } = gpsNavigator.currentPosition;
        console.log(`ç·Šæ€¥ä½ç½®ç™¼é€: ç·¯åº¦ ${lat.toFixed(6)}, ç¶“åº¦ ${lng.toFixed(6)}`);
      }
      
      // 5ç§’å¾Œæ¢å¾©æŒ‰éˆ•
      setTimeout(() => {
        button.classList.remove('emergency-alert');
      }, 5000);
    }

    /**********************
     * 9) åˆå§‹åŒ–æ‡‰ç”¨
     **********************/
    window.addEventListener('DOMContentLoaded', () => {
      // è¨­ç½®åˆå§‹ç‹€æ…‹
      updateStatus('åˆå§‹åŒ–ä¸­');
      updateVoice('ç›²äººè¼”åŠ©å°èˆªç³»çµ±å•Ÿå‹•ä¸­...');
      
      // åˆå§‹åŒ–æ¨¡å‹
      initModel();
      
      // è¨­ç½®ç›¸æ©Ÿé è¦½ï¼ˆä¸é–‹å§‹æª¢æ¸¬ï¼‰
      setupCamera().then(video => {
        if (video) {
          updateStatus('æº–å‚™å°±ç·’');
          updateVoice('ç³»çµ±æº–å‚™å®Œæˆï¼Œè«‹é»æ“Šé–‹å§‹æª¢æ¸¬');
        }
      });
    });

    // é˜²æ­¢é é¢ä¼‘çœ 
    let wakeLock = null;
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('Wake Lock å·²å•Ÿç”¨');
        }
      } catch (err) {
        console.log('Wake Lock å¤±æ•—:', err.message);
      }
    }

    // ç•¶é é¢å¯è¦‹æ™‚é‡æ–°è«‹æ±‚ Wake Lock
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && isDetecting) {
        await requestWakeLock();
      }
    });

    // å•Ÿå‹•æ™‚è«‹æ±‚ Wake Lock
    requestWakeLock();
  </script>
</body>
</html>