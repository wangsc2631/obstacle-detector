<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="盲人輔助導航系統 - 即時障礙物檢測與GPS返航" />
  <title>🧭 盲人輔助導航系統</title>
  
  <!-- PWA 支持 -->
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🧭</text></svg>">
  
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    /* 保持原有的 CSS 樣式不變 */
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    
    @media (min-width: 920px) {
      .app {
        grid-template-columns: 6fr 4fr;
      }
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    header.card {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: clamp(18px, 5vw, 24px);
      margin: 0;
      font-weight: 700;
    }
    
    header .tips {
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    
    @media (min-width: 768px) {
      header .tips {
        display: block;
      }
    }
    
    .camera {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
    }
    
    .camera video, .camera canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    
    .camera video {
      transform: scaleX(-1);
    }
    
    /* 添加一个类来控制是否镜像 */
    .camera.video-mirrored video {
      transform: scaleX(-1);
    }
    
    .camera.video-normal video {
      transform: scaleX(1);
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    @media (min-width: 480px) {
      .controls {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .primary {
      background: var(--good);
      color: #fff;
    }
    
    .warning {
      background: var(--warn);
      color: #fff;
    }
    
    .danger {
      background: var(--bad);
      color: #fff;
    }
    
    .secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, 1fr);
      margin-bottom: 12px;
    }
    
    @media (min-width: 480px) {
      .status {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .k {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .v {
      font-weight: 800;
      font-size: clamp(14px, 4vw, 16px);
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .list {
      max-height: 200px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
      padding-right: 4px;
      -webkit-overflow-scrolling: touch;
    }
    
    .chip {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }
    
    .module-tag {
      display: inline-block;
      background: var(--warn);
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 10px;
      margin-left: 8px;
      font-weight: 600;
    }
    
    .gps-active {
      background: var(--good) !important;
    }
    
    .emergency-alert {
      animation: pulse 1s infinite;
      border: 2px solid var(--bad);
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    .obstacle-warning {
      background: rgba(245,158,11,0.3);
      border: 2px solid var(--warn);
    }
    
    .danger-warning {
      background: rgba(239,68,68,0.3);
      border: 2px solid var(--bad);
    }
    
    /* 障碍物避让可视化 */
    .obstacle-map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    
    .obstacle-point {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--bad);
      transform: translate(-50%, -50%);
    }
    
    @keyframes pulse {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
      100% {
        opacity: 1;
      }
    }
    
    @keyframes loading {
      0% {
        background-position: 200% 0;
      }
      100% {
        background-position: -200% 0;
      }
    }
    
    /* 手機優化 */
    @media (max-width: 480px) {
      body {
        padding: 8px;
      }
      
      .panel {
        padding: 12px;
      }
      
      button.btn {
        padding: 14px 10px;
        font-size: 13px;
        min-height: 50px;
      }
      
      .status-item {
        padding: 10px;
      }
      
      .voice-alert {
        padding: 14px;
        min-height: 55px;
        font-size: 14px;
      }
    }
    
    /* 防止文字選擇 */
    .no-select {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body class="no-select">
  <div class="app">
    <header class="card">
      <h1>🧭 盲人輔助導航</h1>
      <div class="tips">安全出行 · 障礙檢測 · GPS導航</div>
    </header>

    <section class="card camera">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
      <div id="obstacleMap" class="obstacle-map"></div>
    </section>

    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">系統初始化中…</div>
      
      <!-- 主要控制按鈕 -->
      <div class="controls">
        <button id="btnStart" class="btn primary">開始檢測</button>
        <button id="btnVoice" class="btn warning">語音開啟</button>
        <button id="btnMode" class="btn primary">步行模式</button>
        <button id="btnStop" class="btn danger">停止</button>
      </div>
      
      <!-- 新增镜像控制按钮 -->
      <div class="controls">
        <button id="btnMirror" class="btn secondary">鏡像畫面</button>
        <button id="btnDebug" class="btn secondary">調試模式</button>
        <button id="btnTest" class="btn primary">測試檢測</button>
        <button id="btnObstacleAvoidance" class="btn secondary">避障功能</button>
        <button id="btnModelTest" class="btn secondary">模型測試</button>
      </div>
      
      <!-- 導航控制按鈕 -->
      <div class="controls">
        <button id="btnSetHome" class="btn primary">設定家的位置</button>
        <button id="btnReturnHome" class="btn warning">一鍵返航</button>
        <button id="btnLoadModule" class="btn primary">切換環境</button>
        <button id="btnEmergency" class="btn danger">緊急求助</button>
      </div>

      <!-- 狀態資訊 -->
      <div class="status">
        <div class="status-item">
          <div class="k">系統狀態</div>
          <div class="v" id="status">準備中</div>
        </div>
        <div class="status-item">
          <div class="k">偵測速度</div>
          <div class="v" id="fps">—</div>
        </div>
        <div class="status-item">
          <div class="k">障礙物數</div>
          <div class="v" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="k">最近距離</div>
          <div class="v" id="closestDistance">— 公尺</div>
        </div>
      </div>
      
      <div class="status">
        <div class="status-item">
          <div class="k">GPS狀態</div>
          <div class="v" id="gpsStatus">未連接</div>
        </div>
        <div class="status-item">
          <div class="k">距家距離</div>
          <div class="v" id="homeDistance">--</div>
        </div>
        <div class="status-item">
          <div class="k">當前環境</div>
          <div class="v" id="currentModule">戶外</div>
        </div>
        <div class="status-item">
          <div class="k">語音狀態</div>
          <div class="v" id="voiceStatus">開啟</div>
        </div>
      </div>
    </section>

    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">
        即時偵測 <span id="activeModuleTag" class="module-tag">戶外模式</span>
      </h3>
      <div id="detectionList" class="list">
        <div class="chip" style="text-align:center; color:var(--muted);">
          等待開始偵測…
        </div>
      </div>
      <footer>
        專為視障朋友設計 · 安全出行伴侶<br>
        請在光線充足環境使用以獲得最佳效果
      </footer>
    </aside>
  </div>

  <script>
    /**********************
     * 1) 參數區 - 使用可訪問的模型
     **********************/
    // 使用 CDN 上的模型，避免 CORS 問題
    const MODEL_URL = 'https://cdn.jsdelivr.net/gh/ultralytics/assets@main/yolov8n.onnx';
    // 備用模型 URL
    const BACKUP_MODEL_URL = 'https://models.roboflow.com/object-detection/yolov8n/1/model.onnx';
    // 本地模型 URL（如果已下载模型文件）
    const LOCAL_MODEL_URL = './yolov8n.onnx';
    
    const INPUT_SIZE = 640;
    const SCORE_THR_BASE = 0.35;
    const IOU_THR = 0.5;

    const TARGET_FPS = 15;
    const INTERVAL = 1000 / TARGET_FPS;

    // COCO80 類別（英→中）
    const coco80 = [
      'person','bicycle','car','motorcycle','airplane','bus','train','truck','boat','traffic light',
      'fire hydrant','stop sign','parking meter','bench','bird','cat','dog','horse','sheep','cow',
      'elephant','bear','zebra','giraffe','backpack','umbrella','handbag','tie','suitcase','frisbee',
      'skis','snowboard','sports ball','kite','baseball bat','baseball glove','skateboard','surfboard','tennis racket','bottle',
      'wine glass','cup','fork','knife','spoon','bowl','banana','apple','sandwich','orange',
      'broccoli','carrot','hot dog','pizza','donut','cake','chair','couch','potted plant','bed',
      'dining table','toilet','tv','laptop','mouse','remote','keyboard','cell phone','microwave','oven',
      'toaster','sink','refrigerator','book','clock','vase','scissors','teddy bear','hair drier','toothbrush'
    ];
    
    const zhMap = {
      'person':'行人','bicycle':'自行車','car':'汽車','motorcycle':'摩托車','airplane':'飛機','bus':'公車','train':'火車','truck':'卡車','boat':'船','traffic light':'紅綠燈',
      'fire hydrant':'消防栓','stop sign':'停止標誌','parking meter':'停車計時器','bench':'長椅','bird':'鳥','cat':'貓','dog':'狗','horse':'馬','sheep':'綿羊','cow':'牛',
      'elephant':'大象','bear':'熊','zebra':'斑馬','giraffe':'長頸鹿','backpack':'背包','umbrella':'雨傘','handbag':'手提包','tie':'領帶','suitcase':'行李箱','frisbee':'飛盤',
      'skis':'滑雪板','snowboard':'單板滑雪','sports ball':'球','kite':'風箏','baseball bat':'棒球棒','baseball glove':'棒球手套','skateboard':'滑板','surfboard':'衝浪板','tennis racket':'網球拍','bottle':'瓶子',
      'wine glass':'紅酒杯','cup':'杯子','fork':'叉子','knife':'刀子','spoon':'湯匙','bowl':'碗','banana':'香蕉','apple':'蘋果','sandwich':'三明治','orange':'橘子',
      'broccoli':'花椰菜','carrot':'紅蘿蔔','hot dog':'熱狗','pizza':'披薩','donut':'甜甜圈','cake':'蛋糕','chair':'椅子','couch':'沙發','potted plant':'盆栽','bed':'床',
      'dining table':'餐桌','toilet':'馬桶','tv':'電視','laptop':'筆電','mouse':'滑鼠','remote':'遙控器','keyboard':'鍵盤','cell phone':'手機','microwave':'微波爐','oven':'烤箱',
      'toaster':'烤麵包機','sink':'水槽','refrigerator':'冰箱','book':'書','clock':'時鐘','vase':'花瓶','scissors':'剪刀','teddy bear':'泰迪熊','hair drier':'吹風機','toothbrush':'牙刷'
    };

    const MODE_PROFILE = { 
      walking: { nearM: 4, highObjM: 8, scoreThr: 0.45 }, 
      navigate: { nearM: 6, highObjM: 10, scoreThr: 0.4 } 
    };

    /**********************
     * 2) 環境模組系統
     **********************/
    const environmentModules = {
      outdoor: {
        name: '戶外導航',
        objects: {
          'car': { name: '汽車', danger: 'high', voice: '前方有汽車，請保持安全距離' },
          'motorcycle': { name: '摩托車', danger: 'high', voice: '注意！前方有摩托車' },
          'bus': { name: '公車', danger: 'high', voice: '警告！前方有公車' },
          'truck': { name: '卡車', danger: 'high', voice: '警告！前方有卡車' },
          'bicycle': { name: '腳踏車', danger: 'medium', voice: '前方有腳踏車' },
          'traffic light': { name: '紅綠燈', danger: 'medium', voice: '前方有紅綠燈，請注意交通號誌' },
          'stop sign': { name: '停止標誌', danger: 'medium', voice: '停止標誌，請停車觀察' },
          'person': { name: '行人', danger: 'medium', voice: '前方有行人' },
          'bench': { name: '公車站', danger: 'low', voice: '公車站' },
          'fire hydrant': { name: '消防栓', danger: 'medium', voice: '前方有消防栓' },
          'bird': { name: '鳥', danger: 'low', voice: '前方有小鳥' },
          'dog': { name: '狗', danger: 'medium', voice: '前方有狗，請小心' },
          'cat': { name: '貓', danger: 'low', voice: '前方有貓' }
        },
        voiceMessages: {
          'high': '警告！前方有危險障礙物',
          'medium': '注意！前方有障礙物',
          'low': '前方有障礙物'
        },
        triggers: ['car', 'motorcycle', 'bus', 'traffic light', 'stop sign', 'person']
      },
      kitchen: {
        name: '廚房環境',
        objects: {
          'knife': { name: '刀子', danger: 'high', voice: '警告！前方有刀子，鋒利物品請小心' },
          'cup': { name: '杯子', danger: 'medium', voice: '前方有杯子，請小心拿取' },
          'fork': { name: '叉子', danger: 'medium', voice: '前方有叉子，請注意尖齒' },
          'spoon': { name: '湯匙', danger: 'low', voice: '前方有湯匙' },
          'bowl': { name: '碗', danger: 'medium', voice: '前方有碗' },
          'oven': { name: '烤箱', danger: 'high', voice: '警告！前方有烤箱，高溫設備請小心' },
          'microwave': { name: '微波爐', danger: 'high', voice: '注意！前方有微波爐' },
          'refrigerator': { name: '冰箱', danger: 'medium', voice: '前方有冰箱' },
          'sink': { name: '水槽', danger: 'medium', voice: '前方有水槽' },
          'bottle': { name: '瓶子', danger: 'medium', voice: '前方有瓶子' },
          'toaster': { name: '烤麵包機', danger: 'medium', voice: '前方有烤麵包機' }
        },
        voiceMessages: {
          'high': '廚房警告！前方有危險物品',
          'medium': '廚房注意！前方有物品',
          'low': '廚房前方有物品'
        },
        triggers: ['knife', 'oven', 'microwave', 'cup', 'bottle']
      },
      bathroom: {
        name: '浴室環境',
        objects: {
          'toilet': { name: '馬桶', danger: 'medium', voice: '前方有馬桶' },
          'sink': { name: '洗手台', danger: 'medium', voice: '前方有洗手台' },
          'bottle': { name: '洗髮精', danger: 'low', voice: '前方有洗髮精' },
          'toothbrush': { name: '牙刷', danger: 'low', voice: '前方有牙刷' },
          'hair drier': { name: '吹風機', danger: 'medium', voice: '前方有吹風機' }
        },
        voiceMessages: {
          'high': '浴室警告！小心滑倒',
          'medium': '浴室注意前方',
          'low': '浴室物品'
        },
        triggers: ['toilet', 'sink', 'bottle']
      },
      office: {
        name: '辦公室環境',
        objects: {
          'chair': { name: '辦公椅', danger: 'medium', voice: '前方有辦公椅，請注意旋轉' },
          'laptop': { name: '筆電', danger: 'low', voice: '前方有筆電' },
          'keyboard': { name: '鍵盤', danger: 'low', voice: '前方有鍵盤' },
          'mouse': { name: '滑鼠', danger: 'low', voice: '前方有滑鼠' },
          'book': { name: '文件', danger: 'low', voice: '前方有文件' },
          'cell phone': { name: '手機', danger: 'low', voice: '前方有手機' },
          'clock': { name: '時鐘', danger: 'low', voice: '前方有時鐘' }
        },
        voiceMessages: {
          'high': '辦公室警告！',
          'medium': '辦公室注意',
          'low': '辦公室物品'
        },
        triggers: ['chair', 'laptop', 'desk']
      },
      hospital: {
        name: '醫院環境',
        objects: {
          'person': { name: '醫護人員', danger: 'low', voice: '前方有醫護人員' },
          'chair': { name: '候診椅', danger: 'medium', voice: '前方有候診椅' },
          'bed': { name: '病床', danger: 'medium', voice: '前方有病床' },
          'bench': { name: '等候椅', danger: 'medium', voice: '前方有等候椅' }
        },
        voiceMessages: {
          'high': '醫院警告！請小心',
          'medium': '醫院注意',
          'low': '醫院設施'
        },
        triggers: ['person', 'chair', 'bed']
      },
      supermarket: {
        name: '超市環境',
        objects: {
          'person': { name: '顧客', danger: 'medium', voice: '前方有顧客' },
          'bottle': { name: '商品', danger: 'low', voice: '前方有商品架' },
          'cart': { name: '購物車', danger: 'medium', voice: '前方有購物車' },
          'bench': { name: '貨架', danger: 'medium', voice: '前方有貨架' }
        },
        voiceMessages: {
          'high': '超市警告！',
          'medium': '超市注意',
          'low': '超市商品'
        },
        triggers: ['person', 'bottle']
      }
    };

    /**********************
     * 3) GPS導航系統
     **********************/
    class GPSNavigator {
      constructor() {
        this.homePosition = null;
        this.currentPosition = null;
        this.isTracking = false;
        this.watchId = null;
        this.returnHomeInterval = null;
        this.loadHomePosition();
      }

      loadHomePosition() {
        const saved = localStorage.getItem('homePosition');
        if (saved) {
          this.homePosition = JSON.parse(saved);
          updateGPSStatus('就緒');
        }
      }

      setHomePosition() {
        if (!navigator.geolocation) {
          updateVoice('您的裝置不支援GPS定位');
          return;
        }

        updateVoice('正在獲取當前位置...');
        navigator.geolocation.getCurrentPosition(
          (position) => {
            this.homePosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              timestamp: new Date().toISOString()
            };
            localStorage.setItem('homePosition', JSON.stringify(this.homePosition));
            updateVoice(`家的位置已記錄！經度: ${this.homePosition.lng.toFixed(6)}, 緯度: ${this.homePosition.lat.toFixed(6)}`);
            updateGPSStatus('已設定家');
            document.getElementById('btnSetHome').classList.add('gps-active');
          },
          (error) => {
            let errorMsg = '無法獲取位置：';
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMsg += '請允許位置權限';
                break;
              case error.POSITION_UNAVAILABLE:
                errorMsg += '位置資訊不可用';
                break;
              case error.TIMEOUT:
                errorMsg += '定位請求超時';
                break;
              default:
                errorMsg += '未知錯誤';
            }
            updateVoice(errorMsg);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          }
        );
      }

      startReturnHome() {
        if (!this.homePosition) {
          updateVoice('請先設定家的位置');
          return;
        }

        this.isTracking = true;
        updateVoice('開始返航導航，請跟隨語音指引');
        updateGPSStatus('返航中');
        document.getElementById('btnReturnHome').classList.add('gps-active');

        // 開始監聽位置
        this.watchId = navigator.geolocation.watchPosition(
          (position) => {
            this.currentPosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              accuracy: position.coords.accuracy
            };
            this.updateNavigation();
          },
          (error) => {
            updateVoice('GPS信號不穩定');
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 3000
          }
        );

        // 每10秒更新一次導航
        this.returnHomeInterval = setInterval(() => {
          if (this.currentPosition) {
            this.updateNavigation();
          }
        }, 10000);
      }

      updateNavigation() {
        const navInfo = this.calculateNavigation();
        if (!navInfo) return;

        const { distance, bearing, direction } = navInfo;
        document.getElementById('homeDistance').textContent = `${distance}m`;

        // 語音導航邏輯
        if (distance < 20) {
          updateVoice(`已到達家附近，距離${Math.round(distance)}公尺`);
          this.stopReturnHome();
        } else if (distance < 100) {
          updateVoice(`即將到家，距離${Math.round(distance)}公尺，請向${direction}前進`);
        } else {
          updateVoice(`距家${Math.round(distance)}公尺，請向${direction}前進`);
        }
      }

      calculateNavigation() {
        if (!this.currentPosition || !this.homePosition) return null;

        const R = 6371000; // 地球半徑(公尺)
        const φ1 = this.currentPosition.lat * Math.PI/180;
        const φ2 = this.homePosition.lat * Math.PI/180;
        const Δφ = (this.homePosition.lat - this.currentPosition.lat) * Math.PI/180;
        const Δλ = (this.homePosition.lng - this.currentPosition.lng) * Math.PI/180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = Math.round(R * c);

        const y = Math.sin(Δλ) * Math.cos(φ2);
        const x = Math.cos(φ1) * Math.sin(φ2) -
                  Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
        const θ = Math.atan2(y, x);
        const bearing = (θ * 180/Math.PI + 360) % 360;

        const direction = this.getDirectionFromBearing(bearing);
        return { distance, bearing, direction };
      }

      getDirectionFromBearing(bearing) {
        const directions = ['北', '東北', '東', '東南', '南', '西南', '西', '西北'];
        const index = Math.round(bearing / 45) % 8;
        return directions[index];
      }

      stopReturnHome() {
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
          this.watchId = null;
        }
        if (this.returnHomeInterval) {
          clearInterval(this.returnHomeInterval);
          this.returnHomeInterval = null;
        }
        this.isTracking = false;
        updateGPSStatus('就緒');
        document.getElementById('btnReturnHome').classList.remove('gps-active');
        updateVoice('返航導航結束');
      }

      getCurrentLocation() {
        return new Promise((resolve, reject) => {
          if (!navigator.geolocation) {
            reject(new Error('GPS not supported'));
            return;
          }

          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          });
        });
      }
    }

    /**********************
     * 4) 狀態變數
     **********************/
    let session = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let currentMode = 'walking';
    let lastTick = 0;
    let frames = 0;
    let lastFpsTs = 0;
    let lastSpeechAt = 0;
    let lastSaid = {cls: null, at: 0};
    let currentEnvironment = 'outdoor';
    let gpsNavigator = new GPSNavigator();
    let obstacleAvoidanceEnabled = false; // 避障功能开关
    let obstacleMap = []; // 障碍物地图

    /**********************
     * 5) 初始化 / 相機
     **********************/
    async function initModel() {
      try {
        // 檢查 ONNX Runtime 是否正確加載
        if (!ort) {
          throw new Error('ONNX Runtime Web 未正確加載');
        }
        
        console.log('ONNX Runtime 版本:', ort.version);
        updateVoice('正在初始化 ONNX Runtime Web…');
        ort.env.wasm.numThreads = 2;
        ort.env.wasm.simd = true;  // 啟用 SIMD 支持
        ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/';
        const opts = { executionProviders: ['wasm'] }; // 使用 WASM 確保兼容性
        
        updateVoice('載入 YOLOv8n 模型…');
        
        // 顯示載入進度
        const voiceAlert = document.getElementById('voiceAlert');
        voiceAlert.classList.add('loading');
        
        try {
          console.log('嘗試加載主模型:', MODEL_URL);
          session = await ort.InferenceSession.create(MODEL_URL, opts);
        } catch (e) {
          console.log('主要模型載入失敗:', e);
          updateVoice('主要模型載入失敗，嘗試載入備用模型…');
          try {
            console.log('嘗試載入備用模型:', BACKUP_MODEL_URL);
            session = await ort.InferenceSession.create(BACKUP_MODEL_URL, opts);
          } catch (backupError) {
            console.log('備用模型也失敗:', backupError);
            updateVoice('備用模型也失敗，嘗試載入本地模型…');
            try {
              console.log('嘗試載入本地模型:', LOCAL_MODEL_URL);
              session = await ort.InferenceSession.create(LOCAL_MODEL_URL, opts);
            } catch (localError) {
              console.log('本地模型也失敗:', localError);
              updateVoice('所有模型源都無法載入，請檢查網路連接或確保本地模型檔案存在');
              throw new Error('所有模型源都無法載入: ' + localError.message);
            }
          }
        }
        
        // 移除載入動畫
        voiceAlert.classList.remove('loading');
        updateVoice('模型載入完成！點擊「開始檢測」開始使用');
        console.log('模型載入成功');
        console.log('模型輸入名稱:', session.inputNames);
        console.log('模型輸出名稱:', session.outputNames);
        
        // 初始化事件監聽
        initEventListeners();
      } catch (e) {
        console.error('模型載入錯誤:', e); 
        updateVoice('模型載入失敗：' + e.message);
        document.getElementById('voiceAlert').classList.remove('loading');
        
        // 提供錯誤解決建議
        if (e.message.includes('Failed to fetch')) {
          updateVoice('模型下載失敗，請檢查網路連接或刷新頁面重試');
        } else if (e.message.includes('already closed')) {
          updateVoice('模型會話已關閉，請刷新頁面重試');
        } else if (e.message.includes('Not Found') || e.message.includes('404')) {
          updateVoice('模型文件未找到，請確認模型URL是否正確');
        } else if (e.message.includes('CORS')) {
          updateVoice('跨域請求錯誤，請檢查模型來源是否允許跨域訪問');
        } else {
          updateVoice('模型載入出現未知錯誤，請查看控制台獲取詳細資訊');
        }
      }
    }

    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnMode').addEventListener('click', toggleMode);
      document.getElementById('btnSetHome').addEventListener('click', () => gpsNavigator.setHomePosition());
      document.getElementById('btnReturnHome').addEventListener('click', () => gpsNavigator.startReturnHome());
      document.getElementById('btnLoadModule').addEventListener('click', loadEnvironmentModule);
      document.getElementById('btnEmergency').addEventListener('click', emergencyAlert);
      document.getElementById('btnMirror').addEventListener('click', toggleMirror);
      document.getElementById('btnDebug').addEventListener('click', toggleDebug);
      
      // 添加避障功能按钮事件处理
      const obstacleBtn = document.getElementById('btnObstacleAvoidance');
      if (obstacleBtn) {
        obstacleBtn.addEventListener('click', toggleObstacleAvoidance);
      }
      
      // 添加测试按钮（如果存在）
      const testBtn = document.getElementById('btnTest');
      if (testBtn) {
        testBtn.addEventListener('click', testMode);
      }
      
      // 添加模型测试按钮（如果存在）
      const modelTestBtn = document.getElementById('btnModelTest');
      if (modelTestBtn) {
        modelTestBtn.addEventListener('click', testModelInference);
      }
    }
    
    // 添加摄像头预览测试函数
    async function testCameraPreview() {
      updateVoice('測試攝像頭預覽');
      console.log('測試攝像頭預覽');
      
      try {
        // 获取摄像头权限
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment', 
            width: { ideal: 1280 }, 
            height: { ideal: 720 } 
          }, 
          audio: false 
        });
        
        const video = document.getElementById('video');
        video.srcObject = stream;
        
        // 等待视频加载完成
        await new Promise((resolve) => {
          video.onloadedmetadata = () => { 
            console.log('視頻加載完成');
            updateVoice('視頻預覽正常');
            resolve();
          };
        });
        
        // 显示一些基本信息
        console.log(`視頻尺寸: ${video.videoWidth}x${video.videoHeight}`);
        console.log(`鏡像狀態: ${video.style.transform}`);
        
      } catch (error) {
        console.error('攝像頭測試錯誤:', error);
        updateVoice('無法訪問攝像頭，請檢查權限設置');
      }
    }

    // 添加测试模式函数
    async function testMode() {
      updateVoice('進入測試模式');
      console.log('進入測試模式');
      
      // 启用调试模式
      debugMode = true;
      const debugBtn = document.getElementById('btnDebug');
      if (debugBtn) {
        debugBtn.textContent = '調試關閉';
        debugBtn.classList.remove('secondary');
        debugBtn.classList.add('warning');
      }
      
      // 启动摄像头
      const video = await setupCamera();
      if (!video) {
        updateVoice('無法啟動攝像頭');
        return;
      }
      
      updateVoice('攝像頭已啟動，正在測試檢測功能');
      console.log('攝像頭已啟動');
      
      // 执行几次检测以测试功能
      for (let i = 0; i < 3; i++) {
        await new Promise(resolve => setTimeout(resolve, 1000)); // 等待1秒
        updateVoice(`執行第 ${i + 1} 次檢測`);
        console.log(`執行第 ${i + 1} 次檢測`);
        
        try {
          const { predictions, frameW } = await runOnce(video);
          console.log(`第 ${i + 1} 次檢測結果:`, predictions);
          
          // 显示结果
          draw(predictions);
          
          if (predictions.length > 0) {
            const objNames = predictions.map(p => p.class).join(', ');
            updateVoice(`第 ${i + 1} 次檢測到: ${objNames}`);
          } else {
            updateVoice(`第 ${i + 1} 次未檢測到物體`);
    // 添加模型测试函数
    async function testModelInference() {
      if (!session) {
        updateVoice('模型尚未載入完成');
        console.log('模型尚未載入完成');
        return;
      }
      
      updateVoice('開始模型測試');
      console.log('模型輸入名稱:', session.inputNames);
      console.log('模型輸出名稱:', session.outputNames);
      
      // 创建一个测试张量（全零张量）
      const testTensor = new ort.Tensor('float32', new Float32Array(3 * 640 * 640).fill(0), [1, 3, 640, 640]);
      const feeds = { [session.inputNames[0]]: testTensor };
      
      try {
        updateVoice('執行模型推理測試');
        console.log('執行模型推理測試...');
        const results = await session.run(feeds);
        console.log('推理結果:', results);
        console.log('輸出張量形狀:', results[session.outputNames[0]].dims);
        updateVoice('模型推理測試完成，檢查控制台日誌');
      } catch (error) {
        console.error('模型推理測試失敗:', error);
        updateVoice('模型推理測試失敗，檢查控制台日誌');
      }
    }

    // 添加测试函数，用于测试
    async function testDetection() {
      if (!session) {
        updateVoice('模型尚未載入完成');
        console.log('模型尚未載入完成');
        return;
      }
      
      const video = document.getElementById('video');
      if (!video.srcObject) {
        updateVoice('請先啟動攝像頭');
        console.log('請先啟動攝像頭');
        return;
      }
      
      updateVoice('開始測試模式');
      console.log('開始測試模式');
      
      // 设置调试模式
      debugMode = true;
      document.getElementById('btnDebug').textContent = '調試關閉';
      
      // 设置测试次数
      const testCount = 10;
      for (let i = 0; i < testCount; i++) {
        try {
          const { predictions, frameW } = await runOnce(video);
          console.log(`第 ${i + 1} 次檢測結果:`, predictions);
          
          // 处理预测结果
          processPredictions(predictions, frameW);
          draw(predictions);
          
          if (predictions.length > 0) {
            updateVoice(`第 ${i + 1} 次檢測到 ${predictions.length} 個物體`);
          } else {
            updateVoice(`第 ${i + 1} 次未檢測到物體`);
          }
        } catch (error) {
          console.error(`第 ${i + 1} 次檢測錯誤:`, error);
          updateVoice(`第 ${i + 1} 次檢測出現錯誤`);
        }
      }
      
      updateVoice('測試模式完成，請檢查控制台日誌');
    }

    // 添加手动检测函数，用于测试
    async function manualDetection() {
      if (!session) {
        updateVoice('模型尚未載入完成');
        console.log('模型尚未載入完成');
        return;
      }
      
      const video = document.getElementById('video');
      if (!video.srcObject) {
        updateVoice('請先啟動攝像頭');
        console.log('請先啟動攝像頭');
        return;
      }
      
      updateVoice('執行單次檢測');
      console.log('執行單次檢測');
      
      try {
        const { predictions, frameW } = await runOnce(video);
        console.log('檢測結果:', predictions);
        
        // 处理预测结果
        processPredictions(predictions, frameW);
        draw(predictions);
        
        if (predictions.length > 0) {
          updateVoice(`檢測到 ${predictions.length} 個物體`);
        } else {
          updateVoice('未檢測到物體');
        }
      } catch (error) {
        console.error('檢測錯誤:', error);
        updateVoice('檢測過程出現錯誤');
      }
    }

    // 添加摄像头测试函数
    async function testCameraAndDetection() {
      updateVoice('開始測試攝像頭和檢測功能');
      console.log('開始測試攝像頭和檢測功能');
      
      // 设置调试模式
      debugMode = true;
      document.getElementById('btnDebug').textContent = '調試關閉';
      document.getElementById('btnDebug').classList.remove('secondary');
      document.getElementById('btnDebug').classList.add('warning');
      
      // 启动摄像头
      const video = await setupCamera(); 
      if (!video) {
        updateVoice('無法訪問攝像頭');
        return;
      }
      
      updateVoice('攝像頭已啟動，開始測試檢測');
      console.log('攝像頭已啟動');
      
      try {
        // 测试一次检测
        const { predictions, frameW } = await runOnce(video);
        console.log('測試檢測完成，結果:', predictions);
        
        if (predictions.length > 0) {
          updateVoice(`檢測測試成功，檢測到${predictions.length}個物體`);
        } else {
          updateVoice('檢測測試完成，未檢測到物體，請確保畫面中有物體');
        }
        
        // 显示检测结果
        draw(predictions);
      } catch (error) {
        console.error('測試過程中出現錯誤:', error);
        updateVoice('測試過程中出現錯誤');
      }
    }

    // 添加镜像控制功能
    function toggleMirror() {
      const cameraElement = document.querySelector('.camera');
      const button = document.getElementById('btnMirror');
      
      // 移除可能存在的类
      cameraElement.classList.remove('video-mirrored', 'video-normal');
      
      // 切换镜像状态
      if (document.getElementById('video').style.transform === 'scaleX(-1)' || 
          !document.getElementById('video').style.transform) {
        // 当前是镜像状态，切换到正常状态
        document.getElementById('video').style.transform = 'scaleX(1)';
        button.textContent = '鏡像畫面';
        updateVoice('已關閉鏡像');
      } else {
        // 当前是正常状态，切换到镜像状态
        document.getElementById('video').style.transform = 'scaleX(-1)';
        button.textContent = '正常畫面';
        updateVoice('已開啟鏡像');
      }
    }

    // 添加调试模式功能
    let debugMode = false;
    function toggleDebug() {
      debugMode = !debugMode;
      const button = document.getElementById('btnDebug');
      
      if (debugMode) {
        button.textContent = '調試關閉';
        button.classList.remove('secondary');
        button.classList.add('warning');
        updateVoice('已開啟調試模式');
      } else {
        button.textContent = '調試模式';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('已關閉調試模式');
      }
    }

    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment', 
            width: { ideal: 1280 }, 
            height: { ideal: 720 } 
          }, 
          audio: false 
        });
        video.srcObject = stream; 
        await new Promise((resolve) => {
          video.onloadedmetadata = () => { resolve(video); };
        }); 
        
        // 默认设置为镜像（前置摄像头常用）
        video.style.transform = 'scaleX(-1)';
        
        return video;
      } catch (e) { 
        console.error('相機錯誤:', e); 
        updateVoice('無法存取相機，請確認權限/HTTPS'); 
        return null; 
      }
    }

    /**********************
     * 6) 主流程（推論）
     **********************/
    async function startDetection() {
      if (!session) {
        updateVoice('模型尚未載入完成，請稍候');
        return;
      }
      const video = await setupCamera(); 
      if (!video) return;
      isDetecting = true; 
      updateStatus('檢測中'); 
      updateVoice('開始障礙物檢測…');
      await runOnce(video);
      requestAnimationFrame((ts) => loop(video, ts));
    }

    function stopDetection() {
      isDetecting = false; 
      updateStatus('已停止');
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      updateVoice('檢測已停止');
      gpsNavigator.stopReturnHome();
    }

    async function loop(video, ts = 0) {
      if (!isDetecting) return;
      if (ts - lastTick >= INTERVAL) {
        const { predictions, frameW } = await runOnce(video);
        processPredictions(predictions, frameW);
        draw(predictions);

        frames++; 
        if (!lastFpsTs) {
          lastFpsTs = ts;
        } else if (ts - lastFpsTs >= 500) {
          document.getElementById('fps').textContent = Math.round(frames * 1000 / (ts - lastFpsTs));
          frames = 0; 
          lastFpsTs = ts;
        }
        lastTick = ts;
      }
      requestAnimationFrame((n) => loop(video, n));
    }

    async function runOnce(video) {
      try {
        const frame = captureFrame(video);
        const { predictions, frameW } = await inference(frame);
        
        // 在调试模式下输出检测信息
        if (debugMode) {
          console.log('檢測結果:', predictions);
          if (predictions.length > 0) {
            console.log('檢測到物體數量:', predictions.length);
            predictions.forEach((pred, index) => {
              console.log(`物體 ${index + 1}: ${pred.class}, 置信度: ${pred.score.toFixed(2)}, 距離: ${pred.distance.toFixed(2)}m`);
            });
          } else {
            console.log('未檢測到任何物體');
          }
        }
        
        return { predictions, frameW };
      } catch (error) {
        console.error('推理錯誤:', error);
        if (debugMode) {
          updateVoice('推理過程出現錯誤，請查看控制台');
        }
        return { predictions: [], frameW: 640 };
      }
    }

    function captureFrame(video) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const { videoWidth: w, videoHeight: h } = video;
      canvas.width = INPUT_SIZE;
      canvas.height = INPUT_SIZE;
      
      // 計算縮放並保持比例
      const scale = INPUT_SIZE / Math.max(w, h);
      const scaledW = w * scale;
      const scaledH = h * scale;
      const xOffset = (INPUT_SIZE - scaledW) / 2;
      const yOffset = (INPUT_SIZE - scaledH) / 2;
      
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, INPUT_SIZE, INPUT_SIZE);
      ctx.drawImage(video, xOffset, yOffset, scaledW, scaledH);
      
      // 在调试模式下输出帧信息
      if (debugMode) {
        console.log(`視頻尺寸: ${w}x${h}, 縮放後: ${scaledW}x${scaledH}`);
      }
      
      return ctx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
    }

    async function inference(imageData) {
      if (!session) {
        if (debugMode) {
          console.error('模型會話未初始化');
          updateVoice('模型會話未初始化');
        }
        return { predictions: [], frameW: 640 };
      }
      
      const [inferenceTensor, frameW] = preprocess(imageData);
      const feeds = { [session.inputNames[0]]: inferenceTensor };
      
      if (debugMode) {
        console.log('開始模型推理...');
      }
      
      try {
        const results = await session.run(feeds);
        const predictions = postprocess(results, frameW);
        
        if (debugMode) {
          console.log('推理完成，檢測到結果數量:', predictions.length);
        }
        
        return { predictions, frameW };
      } catch (error) {
        console.error('模型推理錯誤:', error);
        if (debugMode) {
          updateVoice('模型推理出現錯誤');
        }
        return { predictions: [], frameW };
      }
    }

    function preprocess(imageData, modelWidth = INPUT_SIZE, modelHeight = INPUT_SIZE) {
      const { data, width, height } = imageData;
      const frameW = width;
      
      const input = new Float32Array(3 * modelWidth * modelHeight);
      let means = [0.485, 0.456, 0.406];
      let stds = [0.229, 0.224, 0.225];
      
      for (let c = 0; c < 3; c++) {
        for (let h = 0; h < modelHeight; h++) {
          for (let w = 0; w < modelWidth; w++) {
            let index = h * modelWidth + w;
            let pixel = data[index * 4 + c]; // RGBA
            input[c * modelWidth * modelHeight + h * modelWidth + w] = (pixel / 255.0 - means[c]) / stds[c];
          }
        }
      }
      
      const tensor = new ort.Tensor('float32', input, [1, 3, modelWidth, modelHeight]);
      return [tensor, frameW];
    }

    function postprocess(results, frameW) {
      const output = results[session.outputNames[0]];
      const predictions = [];
      const scoreThr = MODE_PROFILE[currentMode].scoreThr;
      
      for (let idx = 0; idx < output.dims[1]; idx++) {
        const data = output.data.slice(idx * output.dims[2], (idx + 1) * output.dims[2]);
        const scores = data.slice(4);
        const maxScore = Math.max(...scores);
        
        if (maxScore < scoreThr) continue;
        
        const classId = scores.indexOf(maxScore);
        if (classId >= coco80.length) continue;
        
        // 轉換為像素座標
        let [x, y, w, h] = data.slice(0, 4);
        x = (x - w / 2) * frameW;
        y = (y - h / 2) * frameW;
        w = w * frameW;
        h = h * frameW;
        
        // 計算距離（簡化估算）
        const distance = estimateDistance(w, h, classId);
        
        predictions.push({
          class: coco80[classId],
          score: maxScore,
          bbox: [x, y, w, h],
          distance: distance
        });
      }
      
      // NMS 非極大值抑制
      return nonMaxSuppression(predictions, IOU_THR);
    }

    function estimateDistance(width, height, classId) {
      // 根據物體類別和像素大小估算距離
      const className = coco80[classId];
      const pixelArea = width * height;
      
      // 不同物體的參考大小（經驗值）
      const referenceSizes = {
        'person': 10000,     // 人
        'car': 50000,        // 汽車
        'bicycle': 15000,    // 自行車
        'chair': 8000,       // 椅子
        'bottle': 2000       // 瓶子
      };
      
      const refSize = referenceSizes[className] || 10000;
      const distance = Math.sqrt(refSize / pixelArea) * 10; // 公尺
      
      return Math.min(distance, 50); // 最大距離限制
    }

    function nonMaxSuppression(predictions, iouThr) {
      predictions.sort((a, b) => b.score - a.score);
      const selected = [];
      
      while (predictions.length > 0) {
        const current = predictions[0];
        selected.push(current);
        
        predictions = predictions.filter(pred => {
          const iou = calculateIOU(current.bbox, pred.bbox);
          return iou < iouThr;
        });
      }
      
      return selected;
    }

    function calculateIOU(box1, box2) {
      const [x1, y1, w1, h1] = box1;
      const [x2, y2, w2, h2] = box2;
      
      const xi1 = Math.max(x1, x2);
      const yi1 = Math.max(y1, y2);
      const xi2 = Math.min(x1 + w1, x2 + w2);
      const yi2 = Math.min(y1 + h1, y2 + h2);
      
      const interArea = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);
      const box1Area = w1 * h1;
      const box2Area = w2 * h2;
      
      return interArea / (box1Area + box2Area - interArea);
    }

    /**********************
     * 7) 預測處理與繪圖
     **********************/
    function processPredictions(predictions, frameW) {
      const module = environmentModules[currentEnvironment];
      const relevantPredictions = predictions.filter(p => module.objects[p.class]);
      
      // 更新障礙物計數
      document.getElementById('obstacleCount').textContent = relevantPredictions.length;
      
      // 找到最近障礙物
      let closestDistance = Infinity;
      let closestObject = null;
      
      relevantPredictions.forEach(pred => {
        if (pred.distance < closestDistance) {
          closestDistance = pred.distance;
          closestObject = pred;
        }
      });
      
      // 更新最近距離顯示
      const distanceElement = document.getElementById('closestDistance');
      if (closestObject) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' 公尺';
        
        // 根據距離添加警告樣式
        if (closestDistance < 2) {
          distanceElement.parentElement.classList.add('danger-warning');
        } else if (closestDistance < 5) {
          distanceElement.parentElement.classList.add('obstacle-warning');
        } else {
          distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
        }
      } else {
        distanceElement.textContent = '— 公尺';
        distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
      }
      
      // 語音警告
      if (closestObject && voiceEnabled) {
        const now = Date.now();
        const cooldown = closestObject.distance < 3 ? 2000 : 4000;
        
        if (now - lastSpeechAt > cooldown) {
          const objConfig = module.objects[closestObject.class];
          let voiceMsg = objConfig.voice;
          
          if (closestObject.distance < 2) {
            voiceMsg = `緊急！${objConfig.name}非常接近，僅${closestObject.distance.toFixed(1)}公尺`;
          } else if (closestObject.distance < 5) {
            voiceMsg = `注意！${objConfig.name}接近，距離${closestObject.distance.toFixed(1)}公尺`;
          }
          
          updateVoice(voiceMsg);
          lastSpeechAt = now;
          lastSaid = { cls: closestObject.class, at: now };
        }
      }
      
      // 避障分析和可视化
      if (obstacleAvoidanceEnabled) {
        const video = document.getElementById('video');
        visualizeObstacles(relevantPredictions, video.videoWidth, video.videoHeight);
        provideObstacleAvoidanceGuidance(relevantPredictions);
      }
      
      // 更新偵測列表
      updateDetectionList(relevantPredictions);
    }

    function updateDetectionList(predictions) {
      const list = document.getElementById('detectionList');
      const module = environmentModules[currentEnvironment];
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="chip" style="text-align:center; color:var(--muted);">未偵測到障礙物</div>';
        return;
      }
      
      // 按距離排序
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        const objConfig = module.objects[pred.class];
        const dangerLevel = objConfig ? objConfig.danger : 'low';
        const dangerColors = {
          'high': 'var(--bad)',
          'medium': 'var(--warn)', 
          'low': 'var(--good)'
        };
        
        return `
          <div class="chip" style="border-left: 4px solid ${dangerColors[dangerLevel]}">
            <strong>${objConfig ? objConfig.name : pred.class}</strong><br>
            距離: ${pred.distance.toFixed(1)}公尺 | 置信度: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    function draw(predictions) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const video = document.getElementById('video');
      
      if (!video.videoWidth) return;
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 如果在调试模式下，绘制整个画面的边框
      if (debugMode) {
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
        
        // 显示画面信息
        ctx.font = '16px Arial';
        ctx.fillStyle = 'rgba(0, 255, 255, 0.7)';
        ctx.fillText(`畫面尺寸: ${canvas.width}x${canvas.height}`, 10, 30);
        ctx.fillText(`檢測到物體: ${predictions.length}`, 10, 60);
      }
      
      // 繪製預測框
      predictions.forEach(pred => {
        const module = environmentModules[currentEnvironment];
        if (!module.objects[pred.class]) return;
        
        const [x, y, w, h] = pred.bbox;
        const objConfig = module.objects[pred.class];
        
        // 根據危險等級選擇顏色
        let color;
        switch(objConfig.danger) {
          case 'high': color = '#ef4444'; break;
          case 'medium': color = '#f59e0b'; break;
          default: color = '#22c55e';
        }
        
        // 繪製邊框
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        // 繪製背景標籤
        const label = `${objConfig.name} ${pred.distance.toFixed(1)}m`;
        ctx.font = '16px Arial';
        const textWidth = ctx.measureText(label).width;
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y - 25, textWidth + 10, 25);
        
        // 繪製文字
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 5, y - 7);
        
        // 如果在调试模式下，绘制额外的调试信息
        if (debugMode) {
          // 绘制中心点
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x + w/2, y + h/2, 5, 0, 2 * Math.PI);
          ctx.fill();
          
          // 显示详细信息
          const details = `置信度: ${(pred.score * 100).toFixed(1)}%`;
          ctx.font = '14px Arial';
          const detailsWidth = ctx.measureText(details).width;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(x, y + h, detailsWidth + 10, 20);
          ctx.fillStyle = 'white';
          ctx.fillText(details, x + 5, y + h + 15);
        }
      });
      
      // 如果在调试模式下且没有检测到物体，显示提示信息
      if (debugMode && predictions.length === 0) {
        ctx.font = '20px Arial';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText('未檢測到物體', canvas.width/2, canvas.height/2);
        ctx.textAlign = 'left';
      }
    }

    /**********************
     * 8) 工具函數
     **********************/
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      // 語音合成
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel(); // 取消之前的語音
        
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateGPSStatus(status) {
      document.getElementById('gpsStatus').textContent = status;
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const status = document.getElementById('voiceStatus');
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        status.textContent = '開啟';
        button.textContent = '語音關閉';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('語音提示已開啟');
      } else {
        status.textContent = '關閉';
        button.textContent = '語音開啟';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleMode() {
      const button = document.getElementById('btnMode');
      currentMode = currentMode === 'walking' ? 'navigate' : 'walking';
      
      if (currentMode === 'walking') {
        button.textContent = '導航模式';
        updateVoice('切換到步行模式');
      } else {
        button.textContent = '步行模式';
        updateVoice('切換到導航模式');
      }
    }

    function loadEnvironmentModule() {
      const environments = Object.keys(environmentModules);
      const currentIndex = environments.indexOf(currentEnvironment);
      const nextIndex = (currentIndex + 1) % environments.length;
      currentEnvironment = environments[nextIndex];
      
      const module = environmentModules[currentEnvironment];
      document.getElementById('currentModule').textContent = module.name;
      document.getElementById('activeModuleTag').textContent = module.name;
      
      updateVoice(`切換到${module.name}環境`);
    }

    function emergencyAlert() {
      const button = document.getElementById('btnEmergency');
      button.classList.add('emergency-alert');
      
      updateVoice('緊急求助！正在發送位置資訊給緊急聯絡人');
      
      // 模擬發送緊急訊息
      if (gpsNavigator.currentPosition) {
        const { lat, lng } = gpsNavigator.currentPosition;
        console.log(`緊急位置發送: 緯度 ${lat.toFixed(6)}, 經度 ${lng.toFixed(6)}`);
      }
      
      // 5秒後恢復按鈕
      setTimeout(() => {
        button.classList.remove('emergency-alert');
      }, 5000);
    }

    // 添加避障功能切换函数
    function toggleObstacleAvoidance() {
      obstacleAvoidanceEnabled = !obstacleAvoidanceEnabled;
      const button = document.getElementById('btnObstacleAvoidance');
      
      if (obstacleAvoidanceEnabled) {
        button.textContent = '關閉避障';
        button.classList.remove('secondary');
        button.classList.add('primary');
        updateVoice('避障功能已開啟');
      } else {
        button.textContent = '避障功能';
        button.classList.remove('primary');
        button.classList.add('secondary');
        updateVoice('避障功能已關閉');
      }
    }

    // 障碍物避让建议函数
    function provideObstacleAvoidanceGuidance(predictions) {
      if (predictions.length === 0) return;
      
      // 按距离排序，优先处理最近的障碍物
      predictions.sort((a, b) => a.distance - b.distance);
      const closestObstacle = predictions[0];
      
      // 获取障碍物的中文名称
      const module = environmentModules[currentEnvironment];
      const objConfig = module.objects[closestObstacle.class];
      const obstacleName = objConfig ? objConfig.name : closestObstacle.class;
      
      // 根据距离提供避让建议
      if (closestObstacle.distance < 1.5) {
        updateVoice(`緊急避讓！${obstacleName}距離僅${closestObstacle.distance.toFixed(1)}米，請立即停止並尋找安全路線`);
      } else if (closestObstacle.distance < 3) {
        updateVoice(`注意避讓！${obstacleName}距離${closestObstacle.distance.toFixed(1)}米，建議減速並準備避讓`);
      }
    }

    // 分析障碍物并提供避障建议
    function analyzeObstaclesForAvoidance(predictions, frameW, frameH) {
      if (!obstacleAvoidanceEnabled || predictions.length === 0) return;
      
      // 清空之前的障碍物地图
      obstacleMap = [];
      
      // 分析每个检测到的障碍物
      predictions.forEach(pred => {
        const [x, y, w, h] = pred.bbox;
        const centerX = x + w/2;
        const centerY = y + h/2;
        
        // 根据障碍物在画面中的位置判断方向
        const horizontalPosition = centerX / frameW; // 0 = 最左, 1 = 最右
        const verticalPosition = centerY / frameH;   // 0 = 最上, 1 = 最下
        
        // 根据距离判断紧急程度
        const isClose = pred.distance < 3;  // 3米内为近距离
        const isVeryClose = pred.distance < 1.5; // 1.5米内为非常近
        
        obstacleMap.push({
          class: pred.class,
          distance: pred.distance,
          horizontalPosition: horizontalPosition,
          verticalPosition: verticalPosition,
          isClose: isClose,
          isVeryClose: isVeryClose,
          centerX: centerX,
          centerY: centerY,
          width: w,
          height: h
        });
      });
      
      // 提供避障建议
      provideAvoidanceGuidance();
    }
    
    // 提供避障指导
    function provideAvoidanceGuidance() {
      if (obstacleMap.length === 0) return;
      
      // 按距离排序，优先处理最近的障碍物
      obstacleMap.sort((a, b) => a.distance - b.distance);
      const closestObstacle = obstacleMap[0];
      
      // 获取障碍物的中文名称
      const module = environmentModules[currentEnvironment];
      const objConfig = module.objects[closestObstacle.class];
      const obstacleName = objConfig ? objConfig.name : closestObstacle.class;
      
      // 根据障碍物位置提供指导
      let guidance = "";
      
      if (closestObstacle.isVeryClose) {
        // 非常近的障碍物，需要立即避让
        if (closestObstacle.horizontalPosition < 0.3) {
          guidance = `緊急！左側有${obstacleName}，距離僅${closestObstacle.distance.toFixed(1)}米，請向右轉`;
        } else if (closestObstacle.horizontalPosition > 0.7) {
          guidance = `緊急！右側有${obstacleName}，距離僅${closestObstacle.distance.toFixed(1)}米，請向左轉`;
        } else {
          guidance = `緊急！前方有${obstacleName}，距離僅${closestObstacle.distance.toFixed(1)}米，請停止前進並尋找其他路線`;
        }
      } else if (closestObstacle.isClose) {
        // 较近的障碍物，建议避让
        if (closestObstacle.horizontalPosition < 0.4) {
          guidance = `注意！左側有${obstacleName}，距離${closestObstacle.distance.toFixed(1)}米，建議稍向右轉`;
        } else if (closestObstacle.horizontalPosition > 0.6) {
          guidance = `注意！右側有${obstacleName}，距離${closestObstacle.distance.toFixed(1)}米，建議稍向左轉`;
        } else {
          guidance = `前方有${obstacleName}，距離${closestObstacle.distance.toFixed(1)}米，建議減速並準備避讓`;
        }
      } else {
        // 较远的障碍物，提前提醒
        if (closestObstacle.horizontalPosition < 0.4) {
          guidance = `左側遠處有${obstacleName}，距離${closestObstacle.distance.toFixed(1)}米，請注意行進路線`;
        } else if (closestObstacle.horizontalPosition > 0.6) {
          guidance = `右側遠處有${obstacleName}，距離${closestObstacle.distance.toFixed(1)}米，請注意行進路線`;
        } else {
          guidance = `前方遠