<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="盲人輔助導航系統 - 即時障礙物檢測與GPS返航" />
  <title>🧭 盲人輔助導航系統</title>
  
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    header.card {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: clamp(18px, 5vw, 24px);
      margin: 0;
      font-weight: 700;
    }
    
    .camera {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera video, .camera canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    /* 移除所有鏡像轉換 */
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .primary {
      background: var(--good);
      color: #fff;
    }
    
    .warning {
      background: var(--warn);
      color: #fff;
    }
    
    .danger {
      background: var(--bad);
      color: #fff;
    }
    
    .secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, 1fr);
      margin-bottom: 12px;
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .k {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .v {
      font-weight: 800;
      font-size: clamp(14px, 4vw, 16px);
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .list {
      max-height: 200px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
      padding-right: 4px;
    }
    
    .chip {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .debug-panel {
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="card">
      <h1>🧭 盲人輔助導航</h1>
      <div class="tips">安全出行 · 障礙檢測</div>
    </header>

    <section class="card camera">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
    </section>

    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">系統初始化中…</div>
      
      <div class="controls">
        <button id="btnStart" class="btn primary">開始檢測</button>
        <button id="btnStop" class="btn danger">停止檢測</button>
        <button id="btnVoice" class="btn secondary">語音關閉</button>
        <button id="btnDebug" class="btn warning">顯示除錯</button>
      </div>

      <div class="status">
        <div class="status-item">
          <div class="k">系統狀態</div>
          <div class="v" id="status">準備中</div>
        </div>
        <div class="status-item">
          <div class="k">偵測速度</div>
          <div class="v" id="fps">—</div>
        </div>
        <div class="status-item">
          <div class="k">障礙物數</div>
          <div class="v" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="k">最近距離</div>
          <div class="v" id="closestDistance">— 公尺</div>
        </div>
      </div>

      <div id="debugPanel" class="debug-panel" style="display: none;">
        <div><strong>除錯資訊:</strong></div>
        <div id="debugInfo">等待開始偵測...</div>
      </div>
    </section>

    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">即時偵測結果</h3>
      <div id="detectionList" class="list">
        <div class="chip" style="text-align:center; color:var(--muted);">
          等待開始偵測…
        </div>
      </div>
    </aside>
  </div>

  <script>
    // 簡化的模型配置
    const MODEL_URL = 'https://raw.githubusercontent.com/ultralytics/assets/main/yolov8n.onnx';
    const INPUT_SIZE = 640;
    const SCORE_THRESHOLD = 0.25; // 降低門檻提高檢測率
    const IOU_THRESHOLD = 0.45;

    // COCO 類別名稱
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light',
      'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
      'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee',
      'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle',
      'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange',
      'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed',
      'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven',
      'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    // 重要障礙物類別
    const IMPORTANT_CLASSES = ['person', 'car', 'motorcycle', 'bus', 'truck', 'bicycle', 'chair', 'bench', 'bed', 'couch'];

    let session = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let debugMode = false;

    // 初始化模型
    async function initModel() {
      try {
        updateVoice('正在載入 AI 模型...');
        updateDebugInfo('開始載入模型...');
        
        // 設定 ONNX Runtime
        ort.env.wasm.numThreads = 1;
        
        updateDebugInfo('建立推理會話...');
        session = await ort.InferenceSession.create(MODEL_URL, {
          executionProviders: ['wasm']
        });
        
        updateDebugInfo(`模型載入成功！輸入形狀: ${session.inputNames[0]}`);
        updateVoice('模型載入完成！點擊開始檢測');
        updateStatus('準備就緒');
        
      } catch (error) {
        console.error('模型載入失敗:', error);
        updateDebugInfo(`模型載入錯誤: ${error.message}`);
        updateVoice('模型載入失敗，請檢查網路連接');
      }
    }

    // 設定相機
    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }, 
          audio: false 
        });
        
        video.srcObject = stream;
        
        return new Promise((resolve) => {
          video.onloadedmetadata = () => {
            video.play().then(() => {
              updateDebugInfo(`相機就緒: ${video.videoWidth}x${video.videoHeight}`);
              resolve(video);
            });
          };
        });
      } catch (error) {
        console.error('相機錯誤:', error);
        updateDebugInfo(`相機錯誤: ${error.message}`);
        updateVoice('無法存取相機');
        return null;
      }
    }

    // 開始檢測
    async function startDetection() {
      if (!session) {
        updateVoice('模型尚未載入');
        return;
      }

      const video = await setupCamera();
      if (!video) return;

      isDetecting = true;
      updateStatus('檢測中');
      updateVoice('開始障礙物檢測');

      // 開始檢測循環
      detectFrame(video);
    }

    // 停止檢測
    function stopDetection() {
      isDetecting = false;
      updateStatus('已停止');
      
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      
      updateVoice('檢測已停止');
    }

    // 主檢測循環
    async function detectFrame(video) {
      if (!isDetecting) return;

      const startTime = performance.now();

      try {
        // 1. 捕捉畫面
        const imageData = captureFrame(video);
        
        // 2. 預處理
        const inputTensor = preprocess(imageData);
        
        // 3. 推理
        const outputs = await session.run({ [session.inputNames[0]]: inputTensor });
        
        // 4. 後處理
        const predictions = postprocess(outputs, video.videoWidth, video.videoHeight);
        
        // 5. 處理結果
        processPredictions(predictions);
        
        // 6. 繪製結果
        drawPredictions(predictions, video);
        
        // 更新 FPS
        updateFPS(performance.now() - startTime);

      } catch (error) {
        console.error('檢測錯誤:', error);
        updateDebugInfo(`檢測錯誤: ${error.message}`);
      }

      // 繼續下一幀
      if (isDetecting) {
        setTimeout(() => detectFrame(video), 100); // 10 FPS
      }
    }

    // 捕捉畫面
    function captureFrame(video) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      // 正常繪製，不翻轉
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    // 預處理
    function preprocess(imageData) {
      const { data, width, height } = imageData;
      const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
      
      // 簡單的預處理：調整大小 + 歸一化
      for (let c = 0; c < 3; c++) {
        for (let h = 0; h < INPUT_SIZE; h++) {
          for (let w = 0; w < INPUT_SIZE; w++) {
            // 計算對應的原圖座標
            const srcX = Math.floor(w * width / INPUT_SIZE);
            const srcY = Math.floor(h * height / INPUT_SIZE);
            const srcIndex = (srcY * width + srcX) * 4;
            
            const pixelValue = data[srcIndex + c] / 255.0; // 歸一化到 [0,1]
            input[c * INPUT_SIZE * INPUT_SIZE + h * INPUT_SIZE + w] = pixelValue;
          }
        }
      }
      
      return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
    }

    // 後處理
    function postprocess(outputs, originalWidth, originalHeight) {
      const predictions = [];
      const output = outputs[session.outputNames[0]];
      
      if (!output || !output.data) {
        return predictions;
      }

      const outputData = output.data;
      const numDetections = output.dims[1];
      const numClasses = output.dims[2] - 4;

      updateDebugInfo(`檢測輸出: ${numDetections}個檢測, 數據長度: ${outputData.length}`);

      for (let i = 0; i < numDetections; i++) {
        const offset = i * (numClasses + 4);
        const [x, y, width, height, ...scores] = Array.from(outputData.slice(offset, offset + numClasses + 4));
        
        // 找到最高分數的類別
        const maxScore = Math.max(...scores);
        const classId = scores.indexOf(maxScore);

        if (maxScore > SCORE_THRESHOLD && classId < CLASS_NAMES.length) {
          // 轉換座標到原圖尺寸
          const scaleX = originalWidth / INPUT_SIZE;
          const scaleY = originalHeight / INPUT_SIZE;
          
          const bbox = [
            (x - width / 2) * scaleX,  // x
            (y - height / 2) * scaleY, // y
            width * scaleX,            // width
            height * scaleY            // height
          ];

          predictions.push({
            class: CLASS_NAMES[classId],
            score: maxScore,
            bbox: bbox,
            distance: estimateDistance(bbox[2], bbox[3], CLASS_NAMES[classId])
          });
        }
      }

      updateDebugInfo(`過濾後檢測: ${predictions.length}個物體`);
      return nonMaxSuppression(predictions, IOU_THRESHOLD);
    }

    // 非極大值抑制
    function nonMaxSuppression(predictions, iouThreshold) {
      predictions.sort((a, b) => b.score - a.score);
      const selected = [];

      while (predictions.length > 0) {
        const current = predictions[0];
        selected.push(current);

        predictions = predictions.slice(1).filter(pred => {
          return calculateIOU(current.bbox, pred.bbox) < iouThreshold;
        });
      }

      return selected;
    }

    // 計算 IoU
    function calculateIOU(box1, box2) {
      const [x1, y1, w1, h1] = box1;
      const [x2, y2, w2, h2] = box2;

      const xLeft = Math.max(x1, x2);
      const yTop = Math.max(y1, y2);
      const xRight = Math.min(x1 + w1, x2 + w2);
      const yBottom = Math.min(y1 + h1, y2 + h2);

      if (xRight < xLeft || yBottom < yTop) {
        return 0.0;
      }

      const intersectionArea = (xRight - xLeft) * (yBottom - yTop);
      const box1Area = w1 * h1;
      const box2Area = w2 * h2;

      return intersectionArea / (box1Area + box2Area - intersectionArea);
    }

    // 估算距離
    function estimateDistance(width, height, className) {
      const area = width * height;
      let referenceArea = 10000; // 默認參考面積

      // 根據物體類型調整參考面積
      if (className === 'person') referenceArea = 8000;
      else if (className === 'car') referenceArea = 30000;
      else if (className === 'chair') referenceArea = 5000;

      // 簡單的距離估算公式
      const distance = Math.sqrt(referenceArea / area) * 2;
      return Math.min(Math.max(distance, 0.5), 20); // 限制在 0.5-20 公尺
    }

    // 處理預測結果
    function processPredictions(predictions) {
      // 過濾重要障礙物
      const obstacles = predictions.filter(p => IMPORTANT_CLASSES.includes(p.class));
      
      document.getElementById('obstacleCount').textContent = obstacles.length;
      
      // 找到最近障礙物
      let closestDistance = Infinity;
      let closestObstacle = null;

      obstacles.forEach(obstacle => {
        if (obstacle.distance < closestDistance) {
          closestDistance = obstacle.distance;
          closestObstacle = obstacle;
        }
      });

      // 更新最近距離顯示
      const distanceElement = document.getElementById('closestDistance');
      if (closestObstacle) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' 公尺';
        
        // 語音警告
        if (voiceEnabled && closestDistance < 5) {
          const now = Date.now();
          if (now - lastSpeechTime > 3000) { // 3秒冷卻
            let message = `前方${closestDistance.toFixed(1)}公尺有${closestObstacle.class}`;
            if (closestDistance < 2) message = `警告！${message}，請小心`;
            updateVoice(message);
            lastSpeechTime = now;
          }
        }
      } else {
        distanceElement.textContent = '— 公尺';
      }

      // 更新偵測列表
      updateDetectionList(obstacles);
    }

    let lastSpeechTime = 0;

    // 繪製檢測結果
    function drawPredictions(predictions, video) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // 設定 canvas 尺寸
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      // 清除畫布
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 繪製每個預測框
      predictions.forEach(pred => {
        if (!IMPORTANT_CLASSES.includes(pred.class)) return;
        
        const [x, y, w, h] = pred.bbox;
        const color = pred.distance < 3 ? '#ff0000' : (pred.distance < 5 ? '#ff9900' : '#00ff00');
        
        // 繪製邊框
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        // 繪製標籤
        const label = `${pred.class} ${pred.distance.toFixed(1)}m`;
        ctx.font = '16px Arial';
        const textWidth = ctx.measureText(label).width;
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y - 20, textWidth + 10, 20);
        
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 5, y - 5);
      });
    }

    // 更新偵測列表
    function updateDetectionList(predictions) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="chip" style="text-align:center; color:var(--muted);">未偵測到障礙物</div>';
        return;
      }
      
      // 按距離排序
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        const dangerColor = pred.distance < 3 ? 'var(--bad)' : (pred.distance < 5 ? 'var(--warn)' : 'var(--good)');
        
        return `
          <div class="chip" style="border-left: 4px solid ${dangerColor}">
            <strong>${pred.class}</strong><br>
            距離: ${pred.distance.toFixed(1)}公尺 | 置信度: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    // FPS 計算
    let frameCount = 0;
    let lastFpsUpdate = 0;

    function updateFPS(processingTime) {
      frameCount++;
      const now = performance.now();
      
      if (now - lastFpsUpdate >= 1000) {
        const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        lastFpsUpdate = now;
        
        if (debugMode) {
          updateDebugInfo(`FPS: ${fps}, 處理時間: ${processingTime.toFixed(1)}ms`);
        }
      }
    }

    // 工具函數
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateDebugInfo(info) {
      if (debugMode) {
        document.getElementById('debugInfo').textContent = info;
      }
    }

    // 事件監聽器
    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnDebug').addEventListener('click', toggleDebug);
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        button.textContent = '語音關閉';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('語音提示已開啟');
      } else {
        button.textContent = '語音開啟';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleDebug() {
      debugMode = !debugMode;
      const panel = document.getElementById('debugPanel');
      const button = document.getElementById('btnDebug');
      
      if (debugMode) {
        panel.style.display = 'block';
        button.textContent = '隱藏除錯';
        updateDebugInfo('除錯模式已開啟');
      } else {
        panel.style.display = 'none';
        button.textContent = '顯示除錯';
      }
    }

    // 初始化
    window.addEventListener('DOMContentLoaded', () => {
      initEventListeners();
      initModel();
    });
  </script>
</body>
</html>