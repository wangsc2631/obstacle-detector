<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆª - å³æ™‚éšœç¤™ç‰©æª¢æ¸¬" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆª</title>
  
  <!-- TensorFlow.js å’Œ COCO-SSD -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
  
  <style>
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
    }
    
    .container {
      max-width: 100%;
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    
    .camera-container {
      position: relative;
      width: 100%;
      height: 50vh;
      background: #000;
      border-radius: 15px;
      overflow: hidden;
      margin-bottom: 15px;
    }
    
    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(1);
    }
    
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      min-height: 54px;
    }
    
    .btn-primary { background: var(--good); color: white; }
    .btn-warning { background: var(--warn); color: white; }
    .btn-danger { background: var(--bad); color: white; }
    .btn-secondary { background: var(--glass-strong); color: var(--text); }
    
    .voice-alert {
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      margin: 10px 0;
    }
    
    .status-panel {
      background: rgba(0,0,0,0.3);
      padding: 12px;
      border-radius: 10px;
      margin-bottom: 15px;
    }
    
    .status-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      padding: 5px 0;
    }
    
    .detection-info {
      background: rgba(0,0,0,0.2);
      padding: 10px;
      border-radius: 10px;
      font-size: 14px;
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    .no-select {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body class="no-select">
  <div class="container">
    <h2 style="text-align: center; margin-bottom: 15px;">ğŸ§­ ç›²äººå³æ™‚å°èˆªè¼”åŠ©</h2>
    
    <div class="camera-container">
      <video id="video" autoplay playsinline muted></video>
    </div>
    
    <div id="voiceAlert" class="voice-alert loading">ç³»çµ±å•Ÿå‹•ä¸­...</div>
    
    <div class="controls">
      <button class="btn btn-primary" onclick="startDetection()">é–‹å§‹æª¢æ¸¬</button>
      <button class="btn btn-secondary" onclick="toggleVoice()" id="voiceBtn">èªéŸ³é–‹å•Ÿ</button>
      <button class="btn btn-warning" onclick="toggleDetectionMode()" id="modeBtn">è©³ç´°æ¨¡å¼</button>
      <button class="btn btn-danger" onclick="stopDetection()">åœæ­¢æª¢æ¸¬</button>
    </div>

    <div class="status-panel">
      <div class="status-item">
        <span>æª¢æ¸¬ç‹€æ…‹:</span>
        <span id="detectionStatus">æœªé–‹å§‹</span>
      </div>
      <div class="status-item">
        <span>éšœç¤™ç‰©æ•¸é‡:</span>
        <span id="obstacleCount">0</span>
      </div>
      <div class="status-item">
        <span>æœ€è¿‘éšœç¤™ç‰©:</span>
        <span id="closestObstacle">ç„¡</span>
      </div>
      <div class="status-item">
        <span>æª¢æ¸¬æ¨¡å¼:</span>
        <span id="detectionMode">ç°¡æ½”æ¨¡å¼</span>
      </div>
    </div>

    <div class="detection-info" id="detectionInfo">
      <div style="text-align: center; color: #ccc;">
        ç­‰å¾…é–‹å§‹æª¢æ¸¬...
      </div>
    </div>
  </div>

  <script>
    /**********************
     * 1) æ ¸å¿ƒåƒæ•¸è¨­å®š
     **********************/
    let model = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let detailedMode = false;
    let lastSpeechTime = 0;
    const SPEECH_COOLDOWN = 3000; // 3ç§’å†·å»

    // é‡è¦çš„éšœç¤™ç‰©é¡åˆ¥ï¼ˆç§»é™¤ä¸å¿…è¦çš„é¡åˆ¥ï¼‰
    const importantObstacles = {
      'person': 'è¡Œäºº',
      'car': 'æ±½è»Š',
      'motorcycle': 'æ‘©æ‰˜è»Š',
      'bus': 'å…¬è»Š',
      'truck': 'å¡è»Š',
      'bicycle': 'è…³è¸è»Š',
      'chair': 'æ¤…å­',
      'couch': 'æ²™ç™¼',
      'bed': 'åºŠ',
      'dining table': 'æ¡Œå­',
      'tv': 'é›»è¦–',
      'laptop': 'é›»è…¦',
      'bottle': 'ç“¶å­',
      'cup': 'æ¯å­',
      'book': 'æ›¸æœ¬'
    };

    /**********************
     * 2) æ¨¡å‹åˆå§‹åŒ–
     **********************/
    async function initModel() {
      try {
        updateVoice('æ­£åœ¨è¼‰å…¥AIæª¢æ¸¬æ¨¡å‹...');
        model = await cocoSsd.load();
        updateVoice('æ¨¡å‹è¼‰å…¥æˆåŠŸï¼è«‹é»æ“Šé–‹å§‹æª¢æ¸¬');
        console.log('COCO-SSD æ¨¡å‹è¼‰å…¥æˆåŠŸ');
      } catch (error) {
        console.error('æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
        updateVoice('æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹åˆ·æ–°é é¢é‡è©¦');
      }
    }

    /**********************
     * 3) ç›¸æ©Ÿè¨­ç½®
     **********************/
    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { 
            facingMode: 'environment',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        });
        video.srcObject = stream;
        return new Promise((resolve) => {
          video.onloadedmetadata = () => { resolve(video); };
        });
      } catch (error) {
        updateVoice('ç„¡æ³•é–‹å•Ÿç›¸æ©Ÿ: ' + error.message);
        return null;
      }
    }

    /**********************
     * 4) ä¸»è¦æª¢æ¸¬åŠŸèƒ½
     **********************/
    async function startDetection() {
      if (!model) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆ');
        return;
      }
      
      const video = await setupCamera();
      if (!video) return;
      
      isDetecting = true;
      updateDetectionStatus('æª¢æ¸¬ä¸­');
      updateVoice('é–‹å§‹å³æ™‚éšœç¤™ç‰©æª¢æ¸¬');
      
      detectFrame(video);
    }

    async function detectFrame(video) {
      if (!isDetecting) return;
      
      try {
        const predictions = await model.detect(video);
        processDetections(predictions, video.videoWidth, video.videoHeight);
        
        // ç¹¼çºŒä¸‹ä¸€å¹€æª¢æ¸¬
        setTimeout(() => detectFrame(video), 200); // 5 FPS é¿å…éè¼‰
      } catch (error) {
        console.error('æª¢æ¸¬éŒ¯èª¤:', error);
      }
    }

    function processDetections(predictions, width, height) {
      // éæ¿¾é‡è¦çš„éšœç¤™ç‰©
      const obstacles = predictions.filter(pred => 
        importantObstacles[pred.class] && pred.score > 0.5
      ).map(pred => ({
        ...pred,
        name: importantObstacles[pred.class],
        distance: calculateDistance(pred.bbox[2], pred.bbox[3], pred.class),
        position: analyzePosition(pred.bbox, width, height)
      }));

      updateDisplay(obstacles);
      provideVoiceGuidance(obstacles);
    }

    function calculateDistance(width, height, className) {
      const area = width * height;
      let referenceSize = 10000; // é»˜èªåƒè€ƒå¤§å°
      
      // æ ¹æ“šç‰©é«”é¡å‹èª¿æ•´åƒè€ƒå¤§å°
      const sizeMap = {
        'person': 8000,
        'car': 40000,
        'chair': 6000,
        'bottle': 2000
      };
      
      referenceSize = sizeMap[className] || referenceSize;
      return Math.max(0.5, Math.sqrt(referenceSize / area) * 5);
    }

    function analyzePosition(bbox, screenWidth, screenHeight) {
      const [x, y, w, h] = bbox;
      const centerX = x + w/2;
      const centerY = y + h/2;
      
      // åˆ†æç‰©é«”åœ¨ç•«é¢ä¸­çš„ä½ç½®
      const horizontal = centerX < screenWidth * 0.4 ? 'å·¦å´' : 
                        centerX > screenWidth * 0.6 ? 'å³å´' : 'å‰æ–¹';
      
      const vertical = centerY < screenHeight * 0.4 ? 'é è™•' : 
                      centerY > screenHeight * 0.7 ? 'è¿‘è™•' : 'ä¸­è·é›¢';
      
      return { horizontal, vertical, centerX, centerY };
    }

    /**********************
     * 5) èªéŸ³å°èˆªç³»çµ±
     **********************/
    function provideVoiceGuidance(obstacles) {
      const now = Date.now();
      if (now - lastSpeechTime < SPEECH_COOLDOWN) return;
      
      if (obstacles.length === 0) {
        // æ²’æœ‰éšœç¤™ç‰©æ™‚ï¼Œå¶çˆ¾æç¤ºç’°å¢ƒå®‰å…¨
        if (Math.random() < 0.1) { // 10% æ©Ÿç‡
          updateVoice('å‰æ–¹ç’°å¢ƒå®‰å…¨ï¼Œè«‹ç¹¼çºŒå‰é€²');
          lastSpeechTime = now;
        }
        return;
      }

      // æ‰¾åˆ°æœ€è¿‘çš„éšœç¤™ç‰©
      const closest = obstacles.reduce((prev, curr) => 
        curr.distance < prev.distance ? curr : prev
      );

      if (closest.distance < 2) {
        // ç·Šæ€¥æƒ…æ³
        const guidance = generateEmergencyGuidance(closest);
        updateVoice(guidance);
        lastSpeechTime = now;
      } else if (closest.distance < 5) {
        // ä¸­ç­‰è·é›¢è­¦å‘Š
        const guidance = generateWarningGuidance(closest);
        updateVoice(guidance);
        lastSpeechTime = now;
      }
    }

    function generateEmergencyGuidance(obstacle) {
      const directions = [];
      
      if (obstacle.position.horizontal === 'å·¦å´') {
        directions.push('ç«‹å³å‘å³é–ƒé¿');
      } else if (obstacle.position.horizontal === 'å³å´') {
        directions.push('ç«‹å³å‘å·¦é–ƒé¿');
      } else {
        directions.push('ç«‹å³åœæ­¢å‰é€²');
      }
      
      return `ç·Šæ€¥ï¼${obstacle.position.vertical}${obstacle.position.horizontal}æœ‰${obstacle.name}ï¼Œè·é›¢${obstacle.distance.toFixed(1)}å…¬å°ºï¼Œ${directions.join('ï¼Œ')}ï¼`;
    }

    function generateWarningGuidance(obstacle) {
      const actions = [];
      
      if (obstacle.position.horizontal === 'å·¦å´') {
        actions.push('è«‹é å³è¡Œèµ°');
      } else if (obstacle.position.horizontal === 'å³å´') {
        actions.push('è«‹é å·¦è¡Œèµ°');
      } else {
        actions.push('è«‹æ³¨æ„å‰æ–¹');
      }
      
      return `æ³¨æ„ï¼${obstacle.position.vertical}${obstacle.position.horizontal}æœ‰${obstacle.name}ï¼Œè·é›¢${obstacle.distance.toFixed(1)}å…¬å°ºï¼Œ${actions.join('ï¼Œ')}`;
    }

    /**********************
     * 6) é¡¯ç¤ºæ›´æ–°
     **********************/
    function updateDisplay(obstacles) {
      // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
      document.getElementById('obstacleCount').textContent = obstacles.length;
      
      if (obstacles.length > 0) {
        const closest = obstacles.reduce((prev, curr) => 
          curr.distance < prev.distance ? curr : prev
        );
        document.getElementById('closestObstacle').textContent = 
          `${closest.name} (${closest.distance.toFixed(1)}m)`;
      } else {
        document.getElementById('closestObstacle').textContent = 'ç„¡';
      }
      
      // æ›´æ–°è©³ç´°è³‡è¨Š
      updateDetectionInfo(obstacles);
    }

    function updateDetectionInfo(obstacles) {
      const infoElement = document.getElementById('detectionInfo');
      
      if (obstacles.length === 0) {
        infoElement.innerHTML = '<div style="text-align: center; color: #4CAF50;">âœ“ ç’°å¢ƒå®‰å…¨ï¼Œç„¡éšœç¤™ç‰©</div>';
        return;
      }
      
      if (!detailedMode) {
        // ç°¡æ½”æ¨¡å¼ï¼šåªé¡¯ç¤ºæœ€é‡è¦çš„è³‡è¨Š
        const closest = obstacles.reduce((prev, curr) => 
          curr.distance < prev.distance ? curr : prev
        );
        
        let statusColor = '#4CAF50';
        if (closest.distance < 2) statusColor = '#f44336';
        else if (closest.distance < 5) statusColor = '#FF9800';
        
        infoElement.innerHTML = `
          <div style="text-align: center; color: ${statusColor}; font-weight: bold;">
            âš ï¸ æª¢æ¸¬åˆ° ${obstacles.length} å€‹éšœç¤™ç‰©<br>
            æœ€è¿‘: ${closest.name} (${closest.distance.toFixed(1)}å…¬å°º)
          </div>
        `;
      } else {
        // è©³ç´°æ¨¡å¼ï¼šé¡¯ç¤ºæ‰€æœ‰éšœç¤™ç‰©
        const obstaclesHTML = obstacles
          .sort((a, b) => a.distance - b.distance)
          .map(obs => {
            let color = '#4CAF50';
            if (obs.distance < 2) color = '#f44336';
            else if (obs.distance < 5) color = '#FF9800';
            
            return `
              <div style="margin: 5px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 5px; border-left: 4px solid ${color};">
                <strong>${obs.name}</strong><br>
                è·é›¢: ${obs.distance.toFixed(1)}å…¬å°º | ä½ç½®: ${obs.position.vertical}${obs.position.horizontal}
              </div>
            `;
          })
          .join('');
        
        infoElement.innerHTML = obstaclesHTML;
      }
    }

    /**********************
     * 7) å·¥å…·å‡½æ•¸
     **********************/
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateDetectionStatus(status) {
      document.getElementById('detectionStatus').textContent = status;
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const button = document.getElementById('voiceBtn');
      
      if (voiceEnabled) {
        button.textContent = 'èªéŸ³é—œé–‰';
        updateVoice('èªéŸ³æç¤ºå·²é–‹å•Ÿ');
      } else {
        button.textContent = 'èªéŸ³é–‹å•Ÿ';
        window.speechSynthesis.cancel();
      }
    }

    function toggleDetectionMode() {
      detailedMode = !detailedMode;
      const button = document.getElementById('modeBtn');
      const modeText = document.getElementById('detectionMode');
      
      if (detailedMode) {
        button.textContent = 'ç°¡æ½”æ¨¡å¼';
        modeText.textContent = 'è©³ç´°æ¨¡å¼';
        updateVoice('åˆ‡æ›åˆ°è©³ç´°æª¢æ¸¬æ¨¡å¼');
      } else {
        button.textContent = 'è©³ç´°æ¨¡å¼';
        modeText.textContent = 'ç°¡æ½”æ¨¡å¼';
        updateVoice('åˆ‡æ›åˆ°ç°¡æ½”æª¢æ¸¬æ¨¡å¼');
      }
    }

    function stopDetection() {
      isDetecting = false;
      updateDetectionStatus('å·²åœæ­¢');
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      updateVoice('æª¢æ¸¬å·²åœæ­¢');
    }

    /**********************
     * 8) åˆå§‹åŒ–
     **********************/
    window.addEventListener('DOMContentLoaded', function() {
      initModel();
    });

    // é˜²æ­¢é é¢ä¼‘çœ 
    let wakeLock = null;
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
        }
      } catch (err) {
        console.log('Wake Lock å¤±æ•—:', err.message);
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && isDetecting) {
        await requestWakeLock();
      }
    });

    requestWakeLock();
  </script>
</body>
</html>