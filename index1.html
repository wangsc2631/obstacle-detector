<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆªç³»çµ± - å³æ™‚éšœç¤™ç‰©æª¢æ¸¬èˆ‡GPSè¿”èˆª" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</title>
  
  <!-- PWA æ”¯æŒ -->
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§­</text></svg>">
  
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js"></script>
  
  <style>
    /* ä¿æŒåŸæœ‰çš„ CSS æ¨£å¼ä¸è®Š */
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    
    @media (min-width: 920px) {
      .app {
        grid-template-columns: 6fr 4fr;
      }
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    header.card {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: clamp(18px, 5vw, 24px);
      margin: 0;
      font-weight: 700;
    }
    
    header .tips {
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    
    @media (min-width: 768px) {
      .tips {
        display: block;
      }
    }
    
    .camera {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera video, .camera canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    
    .camera video {
      transform: scaleX(-1);
      background: #000;
    }
    
    .camera canvas {
      z-index: 2;
    }
    
    .camera-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 16px;
      z-index: 5;
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    @media (min-width: 480px) {
      .controls {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .primary {
      background: var(--good);
      color: #fff;
    }
    
    .warning {
      background: var(--warn);
      color: #fff;
    }
    
    .danger {
      background: var(--bad);
      color: #fff;
    }
    
    .secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, 1fr);
      margin-bottom: 12px;
    }
    
    @media (min-width: 480px) {
      .status {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .k {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .v {
      font-weight: 800;
      font-size: clamp(14px, 4vw, 16px);
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .list {
      max-height: 200px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
      padding-right: 4px;
      -webkit-overflow-scrolling: touch;
    }
    
    .chip {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }
    
    .module-tag {
      display: inline-block;
      background: var(--warn);
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 10px;
      margin-left: 8px;
      font-weight: 600;
    }
    
    .gps-active {
      background: var(--good) !important;
    }
    
    .emergency-alert {
      animation: pulse 1s infinite;
      border: 2px solid var(--bad);
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    .obstacle-warning {
      background: rgba(245,158,11,0.3);
      border: 2px solid var(--warn);
    }
    
    .danger-warning {
      background: rgba(239,68,68,0.3);
      border: 2px solid var(--bad);
    }
    
    @keyframes pulse {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
      100% {
        opacity: 1;
      }
    }
    
    @keyframes loading {
      0% {
        background-position: 200% 0;
      }
      100% {
        background-position: -200% 0;
      }
    }
    
    /* æ‰‹æ©Ÿå„ªåŒ– */
    @media (max-width: 480px) {
      body {
        padding: 8px;
      }
      
      .panel {
        padding: 12px;
      }
      
      button.btn {
        padding: 14px 10px;
        font-size: 13px;
        min-height: 50px;
      }
      
      .status-item {
        padding: 10px;
      }
      
      .voice-alert {
        padding: 14px;
        min-height: 55px;
        font-size: 14px;
      }
    }
    
    /* é˜²æ­¢æ–‡å­—é¸æ“‡ */
    .no-select {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    /* æª¢æ¸¬æ¡†æ¨£å¼ */
    .detection-box {
      position: absolute;
      border: 3px solid;
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
      pointer-events: none;
      z-index: 10;
    }
    
    .detection-label {
      position: absolute;
      background: inherit;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      white-space: nowrap;
      pointer-events: none;
      z-index: 11;
    }
    
    .camera-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 10;
    }
    
    .debug-info {
      background: rgba(0,0,0,0.8);
      color: #00ff00;
      padding: 8px;
      border-radius: 5px;
      font-size: 12px;
      margin-top: 8px;
      font-family: monospace;
    }
  </style>
</head>
<body class="no-select">
  <div class="app">
    <header class="card">
      <h1>ğŸ§­ ç›²äººè¼”åŠ©å°èˆª</h1>
      <div class="tips">å®‰å…¨å‡ºè¡Œ Â· éšœç¤™æª¢æ¸¬ Â· GPSå°èˆª</div>
    </header>

    <section class="card camera">
      <div id="cameraPreview" class="camera-preview">
        é»æ“Šã€Œé–‹å•Ÿç›¸æ©Ÿã€é–‹å§‹ä½¿ç”¨
      </div>
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
      <div id="cameraInfo" class="camera-info"></div>
      <div id="detectionContainer"></div>
    </section>

    <section class="card panel">
      <div id="voiceAlert" class="voice-alert">ç³»çµ±æº–å‚™ä¸­â€¦</div>
      
      <!-- ç›¸æ©Ÿæ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnCamera" class="btn primary">é–‹å•Ÿç›¸æ©Ÿ</button>
        <button id="btnStart" class="btn primary" disabled>é–‹å§‹æª¢æ¸¬</button>
        <button id="btnVoice" class="btn secondary">èªéŸ³é—œé–‰</button>
        <button id="btnStop" class="btn danger">åœæ­¢</button>
      </div>
      
      <!-- æª¢æ¸¬æ§åˆ¶ -->
      <div class="controls">
        <button id="btnMirror" class="btn secondary">é—œé–‰é¡åƒ</button>
        <button id="btnDebug" class="btn secondary">é¡¯ç¤ºæª¢æ¸¬æ¡†</button>
        <button id="btnSwitchCamera" class="btn secondary">åˆ‡æ›é¡é ­</button>
        <button id="btnTestDetection" class="btn primary">æ¸¬è©¦æª¢æ¸¬</button>
      </div>

      <!-- ç‹€æ…‹è³‡è¨Š -->
      <div class="status">
        <div class="status-item">
          <div class="k">ç³»çµ±ç‹€æ…‹</div>
          <div class="v" id="status">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="k">ç›¸æ©Ÿç‹€æ…‹</div>
          <div class="v" id="cameraStatus">æœªé–‹å•Ÿ</div>
        </div>
        <div class="status-item">
          <div class="k">æª¢æ¸¬ç‹€æ…‹</div>
          <div class="v" id="detectionStatus">æœªé–‹å§‹</div>
        </div>
        <div class="status-item">
          <div class="k">æœ€è¿‘è·é›¢</div>
          <div class="v" id="closestDistance">â€” å…¬å°º</div>
        </div>
      </div>
      
      <div class="status">
        <div class="status-item">
          <div class="k">æª¢æ¸¬æ¡†æ•¸</div>
          <div class="v" id="boxCount">0</div>
        </div>
        <div class="status-item">
          <div class="k">æœ€é«˜ç½®ä¿¡åº¦</div>
          <div class="v" id="maxConfidence">0%</div>
        </div>
        <div class="status-item">
          <div class="k">ç•¶å‰ç’°å¢ƒ</div>
          <div class="v" id="currentModule">æˆ¶å¤–</div>
        </div>
        <div class="status-item">
          <div class="k">èªéŸ³ç‹€æ…‹</div>
          <div class="v" id="voiceStatus">é–‹å•Ÿ</div>
        </div>
      </div>

      <!-- èª¿è©¦ä¿¡æ¯ -->
      <div id="debugInfo" class="debug-info"></div>
    </section>

    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">
        å³æ™‚åµæ¸¬ <span id="activeModuleTag" class="module-tag">æˆ¶å¤–æ¨¡å¼</span>
      </h3>
      <div id="detectionList" class="list">
        <div class="chip" style="text-align:center; color:var(--muted);">
          ç­‰å¾…é–‹å•Ÿç›¸æ©Ÿâ€¦
        </div>
      </div>
      <footer>
        å°ˆç‚ºè¦–éšœæœ‹å‹è¨­è¨ˆ Â· å®‰å…¨å‡ºè¡Œä¼´ä¾¶<br>
        è«‹åœ¨å…‰ç·šå……è¶³ç’°å¢ƒä½¿ç”¨ä»¥ç²å¾—æœ€ä½³æ•ˆæœ
      </footer>
    </aside>
  </div>

  <script>
    /**********************
     * 1) åƒæ•¸å€
     **********************/
    const MODEL_SOURCES = [
      'https://cdn.jsdelivr.net/gh/ultralytics/assets@main/yolov8n.onnx',
      'yolov8n.onnx'
    ];

    const INPUT_SIZE = 640;
    let SCORE_THRESHOLD = 0.25;
    const IOU_THR = 0.45;
    const TARGET_FPS = 10;

    // COCO80 é¡åˆ¥
    const coco80 = [
      'person','bicycle','car','motorcycle','airplane','bus','train','truck','boat','traffic light',
      'fire hydrant','stop sign','parking meter','bench','bird','cat','dog','horse','sheep','cow',
      'elephant','bear','zebra','giraffe','backpack','umbrella','handbag','tie','suitcase','frisbee',
      'skis','snowboard','sports ball','kite','baseball bat','baseball glove','skateboard','surfboard','tennis racket','bottle',
      'wine glass','cup','fork','knife','spoon','bowl','banana','apple','sandwich','orange',
      'broccoli','carrot','hot dog','pizza','donut','cake','chair','couch','potted plant','bed',
      'dining table','toilet','tv','laptop','mouse','remote','keyboard','cell phone','microwave','oven',
      'toaster','sink','refrigerator','book','clock','vase','scissors','teddy bear','hair drier','toothbrush'
    ];

    const environmentModules = {
      outdoor: {
        name: 'æˆ¶å¤–å°èˆª',
        objects: {
          'person': { name: 'è¡Œäºº', danger: 'medium', voice: 'å‰æ–¹æœ‰è¡Œäºº' },
          'car': { name: 'æ±½è»Š', danger: 'high', voice: 'å‰æ–¹æœ‰æ±½è»Š' },
          'motorcycle': { name: 'æ‘©æ‰˜è»Š', danger: 'high', voice: 'æ³¨æ„æ‘©æ‰˜è»Š' },
          'bicycle': { name: 'è…³è¸è»Š', danger: 'medium', voice: 'å‰æ–¹æœ‰è…³è¸è»Š' },
          'bus': { name: 'å…¬è»Š', danger: 'high', voice: 'è­¦å‘Šï¼å…¬è»Š' },
          'truck': { name: 'å¡è»Š', danger: 'high', voice: 'è­¦å‘Šï¼å¡è»Š' }
        },
        filterOut: ['cat', 'dog', 'bird', 'bottle', 'cup', 'book', 'laptop']
      },
      indoor: {
        name: 'å®¤å…§ç’°å¢ƒ',
        objects: {
          'person': { name: 'äººå“¡', danger: 'medium', voice: 'å‰æ–¹æœ‰äººå“¡' },
          'chair': { name: 'æ¤…å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¤…å­' },
          'couch': { name: 'æ²™ç™¼', danger: 'medium', voice: 'å‰æ–¹æœ‰æ²™ç™¼' },
          'bed': { name: 'åºŠ', danger: 'medium', voice: 'å‰æ–¹æœ‰åºŠ' },
          'dining table': { name: 'é¤æ¡Œ', danger: 'medium', voice: 'å‰æ–¹æœ‰é¤æ¡Œ' }
        },
        filterOut: ['cat', 'dog', 'bird', 'bottle', 'cup', 'book', 'laptop']
      }
    };

    /**********************
     * 2) ç‹€æ…‹è®Šæ•¸
     **********************/
    let session = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let isMirrored = true;
    let showDetectionBoxes = true;
    let currentEnvironment = 'outdoor';
    let currentStream = null;
    let usingFrontCamera = false;
    let detectionInterval = null;

    /**********************
     * 3) æ¨¡å‹è¼‰å…¥
     **********************/
    async function initModel() {
      try {
        updateVoice('æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹â€¦');
        updateStatus('è¼‰å…¥æ¨¡å‹ä¸­');
        
        ort.env.wasm.numThreads = 1;
        
        let modelLoaded = false;
        for (let i = 0; i < MODEL_SOURCES.length; i++) {
          try {
            const cacheBuster = `?t=${Date.now()}`;
            session = await ort.InferenceSession.create(MODEL_SOURCES[i] + cacheBuster, {
              executionProviders: ['wasm']
            });
            modelLoaded = true;
            break;
          } catch (error) {
            continue;
          }
        }
        
        if (!modelLoaded) throw new Error('æ¨¡å‹è¼‰å…¥å¤±æ•—');
        
        initEventListeners();
        updateStatus('æº–å‚™å°±ç·’');
        updateVoice('AI æ¨¡å‹è¼‰å…¥æˆåŠŸï¼è«‹å…ˆé–‹å•Ÿç›¸æ©Ÿ');
        
      } catch (error) {
        console.error('æ¨¡å‹è¼‰å…¥éŒ¯èª¤:', error);
        updateVoice('æ¨¡å‹è¼‰å…¥å¤±æ•—');
      }
    }

    function initEventListeners() {
      document.getElementById('btnCamera').addEventListener('click', setupCamera);
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnMirror').addEventListener('click', toggleMirror);
      document.getElementById('btnDebug').addEventListener('click', toggleDetectionBoxes);
      document.getElementById('btnSwitchCamera').addEventListener('click', switchCamera);
      document.getElementById('btnTestDetection').addEventListener('click', testSingleDetection);
    }

    /**********************
     * 4) æ”åƒé ­æ§åˆ¶
     **********************/
    async function setupCamera() {
      try {
        updateVoice('æ­£åœ¨è«‹æ±‚ç›¸æ©Ÿæ¬Šé™â€¦');
        updateCameraStatus('è«‹æ±‚æ¬Šé™ä¸­');
        
        // åœæ­¢ä¹‹å‰çš„ stream
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }
        
        const video = document.getElementById('video');
        const preview = document.getElementById('cameraPreview');
        
        // ç°¡å–®çš„ç›¸æ©Ÿé…ç½®
        const constraints = {
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: usingFrontCamera ? 'user' : 'environment'
          },
          audio: false
        };
        
        console.log('å˜—è©¦ç›¸æ©Ÿé…ç½®:', constraints);
        
        // è«‹æ±‚ç›¸æ©Ÿæ¬Šé™
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
        
        // ç­‰å¾…è¦–é »æº–å‚™å¥½
        await new Promise((resolve, reject) => {
          video.onloadedmetadata = () => {
            console.log('âœ… ç›¸æ©Ÿæº–å‚™å®Œæˆ:', video.videoWidth, 'x', video.videoHeight);
            resolve(video);
          };
          video.onerror = reject;
        });
        
        // é–‹å§‹æ’­æ”¾è¦–é »
        await video.play();
        
        // éš±è—é è¦½ç•«é¢
        preview.style.display = 'none';
        
        // æ›´æ–°é¡åƒæ•ˆæœ
        updateMirrorEffect();
        
        // æ›´æ–°ç›¸æ©Ÿä¿¡æ¯
        updateCameraInfo();
        
        // å•Ÿç”¨é–‹å§‹æª¢æ¸¬æŒ‰éˆ•
        document.getElementById('btnStart').disabled = false;
        document.getElementById('btnTestDetection').disabled = false;
        
        updateCameraStatus('å·²é–‹å•Ÿ');
        updateVoice('ç›¸æ©Ÿé–‹å•ŸæˆåŠŸï¼ç¾åœ¨å¯ä»¥é–‹å§‹æª¢æ¸¬');
        
        console.log('ğŸ¥ ç›¸æ©ŸæˆåŠŸé–‹å•Ÿ');
        return video;
        
      } catch (error) {
        console.error('âŒ ç›¸æ©ŸéŒ¯èª¤:', error);
        handleCameraError(error);
        return null;
      }
    }

    function handleCameraError(error) {
      const preview = document.getElementById('cameraPreview');
      let errorMessage = 'ç„¡æ³•é–‹å•Ÿç›¸æ©Ÿï¼š';
      
      switch(error.name) {
        case 'NotAllowedError':
          errorMessage += 'è«‹å…è¨±ç›¸æ©Ÿæ¬Šé™ï¼Œç„¶å¾Œåˆ·æ–°é é¢';
          break;
        case 'NotFoundError':
          errorMessage += 'æœªæ‰¾åˆ°ç›¸æ©Ÿè¨­å‚™';
          break;
        default:
          errorMessage += error.message;
      }
      
      preview.innerHTML = `
        <div style="text-align: center;">
          <div style="font-size: 48px; margin-bottom: 10px;">ğŸ“·</div>
          <div>${errorMessage}</div>
          <button onclick="retryCamera()" style="margin-top: 10px; padding: 8px 16px; background: var(--good); color: white; border: none; border-radius: 8px;">
            é‡è©¦
          </button>
        </div>
      `;
      
      updateCameraStatus('é–‹å•Ÿå¤±æ•—');
      updateVoice('ç›¸æ©Ÿé–‹å•Ÿå¤±æ•—ï¼Œè«‹æª¢æŸ¥æ¬Šé™');
    }

    function retryCamera() {
      setupCamera();
    }

    async function switchCamera() {
      usingFrontCamera = !usingFrontCamera;
      updateVoice(usingFrontCamera ? 'åˆ‡æ›åˆ°å‰ç½®é¡é ­' : 'åˆ‡æ›åˆ°å¾Œç½®é¡é ­');
      await setupCamera();
    }

    function updateCameraInfo() {
      const video = document.getElementById('video');
      const info = document.getElementById('cameraInfo');
      
      if (video.videoWidth && video.videoHeight) {
        info.textContent = `${video.videoWidth}Ã—${video.videoHeight} ${usingFrontCamera ? 'å‰ç½®' : 'å¾Œç½®'}`;
      }
    }

    function updateCameraStatus(status) {
      document.getElementById('cameraStatus').textContent = status;
    }

    function toggleMirror() {
      isMirrored = !isMirrored;
      const button = document.getElementById('btnMirror');
      button.textContent = isMirrored ? 'é—œé–‰é¡åƒ' : 'é–‹å•Ÿé¡åƒ';
      updateMirrorEffect();
    }

    function updateMirrorEffect() {
      const video = document.getElementById('video');
      // åªæœ‰å‰ç½®é¡é ­æ‰éœ€è¦é¡åƒ
      video.style.transform = (isMirrored && usingFrontCamera) ? 'scaleX(-1)' : 'scaleX(1)';
    }

    /**********************
     * 5) æª¢æ¸¬åŠŸèƒ½ - ä¿®å¾©ç‰ˆæœ¬
     **********************/
    async function startDetection() {
      if (!session) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆ');
        return;
      }
      
      const video = document.getElementById('video');
      if (!video.srcObject) {
        updateVoice('è«‹å…ˆé–‹å•Ÿç›¸æ©Ÿ');
        return;
      }
      
      isDetecting = true;
      updateStatus('æª¢æ¸¬ä¸­');
      updateDetectionStatus('é‹è¡Œä¸­');
      updateVoice('é–‹å§‹éšœç¤™ç‰©æª¢æ¸¬');
      
      // ä½¿ç”¨ setInterval è€Œä¸æ˜¯ requestAnimationFrameï¼Œé¿å…è¡çª
      detectionInterval = setInterval(async () => {
        if (!isDetecting) return;
        
        try {
          const { predictions, frameW } = await runOnce(video);
          updateDebugInfo(`æª¢æ¸¬åˆ° ${predictions.length} å€‹ç‰©é«”`);
          processPredictions(predictions, frameW);
          updateDetectionBoxes(predictions, video.videoWidth, video.videoHeight);
          updateStats(predictions);
        } catch (error) {
          console.error('æª¢æ¸¬éŒ¯èª¤:', error);
          updateDebugInfo(`æª¢æ¸¬éŒ¯èª¤: ${error.message}`);
        }
      }, 1000 / TARGET_FPS);
    }

    function stopDetection() {
      isDetecting = false;
      if (detectionInterval) {
        clearInterval(detectionInterval);
        detectionInterval = null;
      }
      updateStatus('å·²åœæ­¢');
      updateDetectionStatus('å·²åœæ­¢');
      clearDetectionBoxes();
      updateVoice('æª¢æ¸¬å·²åœæ­¢');
    }

    // å–®æ¬¡æ¸¬è©¦æª¢æ¸¬
    async function testSingleDetection() {
      if (!session) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆ');
        return;
      }
      
      const video = document.getElementById('video');
      if (!video.srcObject) {
        updateVoice('è«‹å…ˆé–‹å•Ÿç›¸æ©Ÿ');
        return;
      }
      
      updateVoice('åŸ·è¡Œå–®æ¬¡æª¢æ¸¬æ¸¬è©¦');
      
      try {
        const { predictions, frameW } = await runOnce(video);
        updateDebugInfo(`æ¸¬è©¦æª¢æ¸¬: ${predictions.length} å€‹ç‰©é«”`);
        
        if (predictions.length > 0) {
          const objects = predictions.map(p => p.class).join(', ');
          updateVoice(`æ¸¬è©¦æˆåŠŸï¼æª¢æ¸¬åˆ°: ${objects}`);
        } else {
          updateVoice('æ¸¬è©¦å®Œæˆï¼Œæœªæª¢æ¸¬åˆ°ç‰©é«”');
        }
        
        processPredictions(predictions, frameW);
        updateDetectionBoxes(predictions, video.videoWidth, video.videoHeight);
        updateStats(predictions);
        
      } catch (error) {
        console.error('æ¸¬è©¦æª¢æ¸¬éŒ¯èª¤:', error);
        updateVoice('æª¢æ¸¬æ¸¬è©¦å¤±æ•—');
      }
    }

    /**********************
     * 6) YOLO æ¨ç†
     **********************/
    async function runOnce(video) {
      try {
        const frame = captureFrame(video);
        const { predictions, frameW } = await inference(frame);
        return { predictions, frameW };
      } catch (error) {
        console.error('æ¨ç†éŒ¯èª¤:', error);
        return { predictions: [], frameW: 640 };
      }
    }

    function captureFrame(video) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const { videoWidth: w, videoHeight: h } = video;
      
      // ä½¿ç”¨è¼ƒå°çš„å°ºå¯¸æé«˜æ€§èƒ½
      canvas.width = INPUT_SIZE;
      canvas.height = INPUT_SIZE;
      
      // ç›´æ¥ç¹ªè£½ï¼Œä¸é€²è¡Œè¤‡é›œè¨ˆç®—
      ctx.drawImage(video, 0, 0, INPUT_SIZE, INPUT_SIZE);
      
      return ctx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
    }

    async function inference(imageData) {
      if (!session) {
        throw new Error('æ¨¡å‹æœªè¼‰å…¥');
      }
      
      const [inferenceTensor, frameW] = preprocess(imageData);
      const feeds = { [session.inputNames[0]]: inferenceTensor };
      const results = await session.run(feeds);
      const predictions = postprocess(results, frameW);
      return { predictions, frameW };
    }

    function preprocess(imageData, modelWidth = INPUT_SIZE, modelHeight = INPUT_SIZE) {
      const { data, width, height } = imageData;
      const input = new Float32Array(3 * modelWidth * modelHeight);
      
      // ç°¡åŒ–çš„é è™•ç†ï¼Œåªé€²è¡Œæ­¸ä¸€åŒ–
      for (let i = 0; i < data.length; i += 4) {
        const pixelIndex = i / 4;
        const r = data[i] / 255.0;
        const g = data[i + 1] / 255.0;
        const b = data[i + 2] / 255.0;
        
        input[pixelIndex] = r;
        input[modelWidth * modelHeight + pixelIndex] = g;
        input[2 * modelWidth * modelHeight + pixelIndex] = b;
      }
      
      const tensor = new ort.Tensor('float32', input, [1, 3, modelWidth, modelHeight]);
      return [tensor, width];
    }

    function postprocess(results, frameW) {
      const output = results[session.outputNames[0]];
      const predictions = [];
      const outputData = output.data;
      const outputDims = output.dims;
      
      // YOLOv8 è¼¸å‡ºæ ¼å¼: [1, 84, 8400]
      for (let i = 0; i < outputDims[2]; i++) {
        const offset = i * outputDims[1];
        const scores = outputData.slice(offset + 4, offset + outputDims[1]);
        const maxScore = Math.max(...scores);
        
        if (maxScore < SCORE_THRESHOLD) continue;
        
        const classId = scores.indexOf(maxScore);
        if (classId >= coco80.length) continue;
        
        const bbox = outputData.slice(offset, offset + 4);
        let [x, y, w, h] = bbox;
        
        // è½‰æ›ç‚ºåƒç´ åæ¨™
        x = x * frameW;
        y = y * frameW;
        w = w * frameW;
        h = h * frameW;
        
        // ä¼°ç®—è·é›¢
        const distance = estimateDistance(w, h, classId);
        
        predictions.push({
          class: coco80[classId],
          score: maxScore,
          bbox: [x, y, w, h],
          distance: distance
        });
      }
      
      return nonMaxSuppression(predictions, IOU_THR);
    }

    function estimateDistance(width, height, classId) {
      const className = coco80[classId];
      const pixelArea = width * height;
      const referenceSizes = {
        'person': 15000, 'car': 80000, 'chair': 12000
      };
      const refSize = referenceSizes[className] || 20000;
      const distance = Math.sqrt(refSize / pixelArea) * 2;
      return Math.min(distance, 20);
    }

    function nonMaxSuppression(predictions, iouThr) {
      predictions.sort((a, b) => b.score - a.score);
      const selected = [];
      while (predictions.length > 0) {
        const current = predictions[0];
        selected.push(current);
        predictions = predictions.filter(pred => {
          const iou = calculateIOU(current.bbox, pred.bbox);
          return iou < iouThr;
        });
      }
      return selected;
    }

    function calculateIOU(box1, box2) {
      const [x1, y1, w1, h1] = box1;
      const [x2, y2, w2, h2] = box2;
      const xi1 = Math.max(x1, x2);
      const yi1 = Math.max(y1, y2);
      const xi2 = Math.min(x1 + w1, x2 + w2);
      const yi2 = Math.min(y1 + h1, y2 + h2);
      const interArea = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);
      const box1Area = w1 * h1;
      const box2Area = w2 * h2;
      return interArea / (box1Area + box2Area - interArea);
    }

    /**********************
     * 7) è¦–è¦ºåŒ–å’Œè™•ç†
     **********************/
    function toggleDetectionBoxes() {
      showDetectionBoxes = !showDetectionBoxes;
      const button = document.getElementById('btnDebug');
      button.textContent = showDetectionBoxes ? 'éš±è—æª¢æ¸¬æ¡†' : 'é¡¯ç¤ºæª¢æ¸¬æ¡†';
      if (!showDetectionBoxes) {
        clearDetectionBoxes();
      }
    }

    function createDetectionBox(prediction, videoWidth, videoHeight) {
      const container = document.getElementById('detectionContainer');
      const [x, y, w, h] = prediction.bbox;
      
      const scaleX = videoWidth / INPUT_SIZE;
      const scaleY = videoHeight / INPUT_SIZE;
      
      const actualX = x * scaleX;
      const actualY = y * scaleY;
      const actualW = w * scaleX;
      const actualH = h * scaleY;
      
      const box = document.createElement('div');
      box.className = 'detection-box';
      box.style.left = actualX + 'px';
      box.style.top = actualY + 'px';
      box.style.width = actualW + 'px';
      box.style.height = actualH + 'px';
      
      const module = environmentModules[currentEnvironment];
      const objConfig = module.objects[prediction.class];
      let color = '#22c55e';
      
      if (objConfig) {
        switch(objConfig.danger) {
          case 'high': color = '#ef4444'; break;
          case 'medium': color = '#f59e0b'; break;
        }
      } else {
        color = '#6b7280';
      }
      
      box.style.borderColor = color;
      box.style.background = color.replace(')', ', 0.1)').replace('rgb', 'rgba');
      
      const label = document.createElement('div');
      label.className = 'detection-label';
      label.style.left = actualX + 'px';
      label.style.top = (actualY - 25) + 'px';
      label.style.background = color;
      
      const confidencePercent = (prediction.score * 100).toFixed(0);
      label.textContent = `${objConfig ? objConfig.name : prediction.class} ${confidencePercent}%`;
      
      container.appendChild(box);
      container.appendChild(label);
    }

    function clearDetectionBoxes() {
      const container = document.getElementById('detectionContainer');
      container.innerHTML = '';
    }

    function updateDetectionBoxes(predictions, videoWidth, videoHeight) {
      clearDetectionBoxes();
      
      if (!showDetectionBoxes) return;
      
      predictions.forEach(prediction => {
        createDetectionBox(prediction, videoWidth, videoHeight);
      });
    }

    function processPredictions(predictions, frameW) {
      const module = environmentModules[currentEnvironment];
      
      const relevantPredictions = predictions.filter(p => {
        const isRelevant = module.objects[p.class];
        const isFilteredOut = module.filterOut.includes(p.class);
        return isRelevant && !isFilteredOut && p.score > SCORE_THRESHOLD;
      });
      
      document.getElementById('obstacleCount').textContent = relevantPredictions.length;
      document.getElementById('boxCount').textContent = predictions.length;
      
      let closestDistance = Infinity;
      let closestObject = null;
      
      relevantPredictions.forEach(pred => {
        if (pred.distance < closestDistance) {
          closestDistance = pred.distance;
          closestObject = pred;
        }
      });
      
      const distanceElement = document.getElementById('closestDistance');
      if (closestObject) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' å…¬å°º';
        
        if (closestDistance < 1.5) {
          distanceElement.parentElement.classList.add('danger-warning');
        } else if (closestDistance < 3) {
          distanceElement.parentElement.classList.add('obstacle-warning');
        } else {
          distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
        }
      } else {
        distanceElement.textContent = 'â€” å…¬å°º';
        distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
      }
      
      updateDetectionList(relevantPredictions);
    }

    function updateDetectionList(predictions) {
      const list = document.getElementById('detectionList');
      const module = environmentModules[currentEnvironment];
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="chip" style="text-align:center; color:var(--muted);">æœªåµæ¸¬åˆ°éšœç¤™ç‰©</div>';
        return;
      }
      
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        const objConfig = module.objects[pred.class];
        const dangerLevel = objConfig ? objConfig.danger : 'low';
        const dangerColors = {
          'high': 'var(--bad)', 'medium': 'var(--warn)', 'low': 'var(--good)'
        };
        
        return `
          <div class="chip" style="border-left: 4px solid ${dangerColors[dangerLevel]}">
            <strong>${objConfig ? objConfig.name : pred.class}</strong><br>
            è·é›¢: ${pred.distance.toFixed(1)}å…¬å°º | ç½®ä¿¡åº¦: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    function updateStats(predictions) {
      const maxConfidence = predictions.length > 0 ? 
        Math.max(...predictions.map(p => p.score)) : 0;
      document.getElementById('maxConfidence').textContent = 
        (maxConfidence * 100).toFixed(0) + '%';
    }

    /**********************
     * 8) å·¥å…·å‡½æ•¸
     **********************/
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateDetectionStatus(status) {
      document.getElementById('detectionStatus').textContent = status;
    }

    function updateDebugInfo(message) {
      const debugElement = document.getElementById('debugInfo');
      debugElement.textContent = `èª¿è©¦: ${message}`;
      console.log(message);
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const status = document.getElementById('voiceStatus');
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        status.textContent = 'é–‹å•Ÿ';
        button.textContent = 'èªéŸ³é—œé–‰';
        updateVoice('èªéŸ³æç¤ºå·²é–‹å•Ÿ');
      } else {
        status.textContent = 'é—œé–‰';
        button.textContent = 'èªéŸ³é–‹å•Ÿ';
        window.speechSynthesis.cancel();
      }
    }

    /**********************
     * 9) åˆå§‹åŒ–
     **********************/
    window.addEventListener('DOMContentLoaded', () => {
      updateStatus('åˆå§‹åŒ–ä¸­');
      updateVoice('ç›²äººè¼”åŠ©å°èˆªç³»çµ±å•Ÿå‹•ä¸­...');
      initModel();
    });
  </script>
</body>
</html>