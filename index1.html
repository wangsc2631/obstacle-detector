<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆªç³»çµ± - å³æ™‚éšœç¤™ç‰©æª¢æ¸¬" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</title>
  
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§­</text></svg>">
  
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js"></script>
  
  <style>
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    .camera-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera-container video, .camera-container canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    
    .camera-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 16px;
      z-index: 5;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    button {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .btn-primary {
      background: var(--good);
      color: #fff;
    }
    
    .btn-danger {
      background: var(--bad);
      color: #fff;
    }
    
    .btn-secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-value {
      font-weight: 800;
      font-size: 16px;
    }
    
    .voice-alert {
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      margin-bottom: 15px;
    }
    
    .detection-list {
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .detection-item {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
    }
    
    .debug-info {
      background: rgba(0,0,0,0.8);
      color: #00ff00;
      padding: 8px;
      border-radius: 5px;
      font-size: 12px;
      margin-top: 8px;
      font-family: monospace;
      display: none;
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- æ¨™é¡Œ -->
    <div class="card">
      <h1 style="margin:0; text-align:center;">ğŸ§­ ç›²äººè¼”åŠ©å°èˆª</h1>
    </div>

    <!-- ç›¸æ©Ÿç•«é¢ -->
    <div class="card">
      <div class="camera-container">
        <div id="cameraPreview" class="camera-preview">
          é»æ“Šã€Œé–‹å•Ÿç›¸æ©Ÿã€é–‹å§‹ä½¿ç”¨
        </div>
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
      </div>
    </div>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="card">
      <div id="voiceAlert" class="voice-alert">ç³»çµ±æº–å‚™ä¸­â€¦</div>
      
      <div class="controls">
        <button id="btnCamera" class="btn-primary">é–‹å•Ÿç›¸æ©Ÿ</button>
        <button id="btnStart" class="btn-primary" disabled>é–‹å§‹æª¢æ¸¬</button>
        <button id="btnTest" class="btn-secondary" disabled>æ¸¬è©¦æª¢æ¸¬</button>
        <button id="btnStop" class="btn-danger">åœæ­¢</button>
      </div>

      <div class="status-grid">
        <div class="status-item">
          <div class="status-label">ç³»çµ±ç‹€æ…‹</div>
          <div class="status-value" id="status">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="status-label">æ¨¡å‹ç‹€æ…‹</div>
          <div class="status-value" id="modelStatus">è¼‰å…¥ä¸­</div>
        </div>
        <div class="status-item">
          <div class="status-label">ç›¸æ©Ÿç‹€æ…‹</div>
          <div class="status-value" id="cameraStatus">æœªé–‹å•Ÿ</div>
        </div>
        <div class="status-item">
          <div class="status-label">æª¢æ¸¬ç‹€æ…‹</div>
          <div class="status-value" id="detectionStatus">æœªé–‹å§‹</div>
        </div>
      </div>

      <div id="debugInfo" class="debug-info"></div>
    </div>

    <!-- æª¢æ¸¬çµæœ -->
    <div class="card">
      <h3 style="margin:0 0 12px 0;">å³æ™‚åµæ¸¬çµæœ</h3>
      <div id="detectionList" class="detection-list">
        <div class="detection-item" style="text-align:center; color:var(--muted);">
          ç­‰å¾…é–‹å§‹åµæ¸¬â€¦
        </div>
      </div>
    </div>
  </div>

  <script>
    // ç°¡å–®çš„æ¨¡å‹é…ç½®
    const MODEL_URL = 'https://cdn.jsdelivr.net/gh/ultralytics/assets@main/yolov8n.onnx';
    const INPUT_SIZE = 640;
    
    // COCO é¡åˆ¥åç¨±
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
      'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
      'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
      'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
      'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
      'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
      'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair',
      'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse',
      'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator',
      'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    // ç‹€æ…‹è®Šæ•¸
    let session = null;
    let isDetecting = false;
    let currentStream = null;
    let detectionInterval = null;

    // åˆå§‹åŒ–
    async function init() {
      try {
        updateStatus('è¼‰å…¥æ¨¡å‹ä¸­');
        updateVoice('æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹â€¦');
        
        // è¼‰å…¥ ONNX æ¨¡å‹
        session = await ort.InferenceSession.create(MODEL_URL, {
          executionProviders: ['wasm']
        });
        
        console.log('âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸ');
        console.log('è¼¸å…¥:', session.inputNames);
        console.log('è¼¸å‡º:', session.outputNames);
        
        updateModelStatus('è¼‰å…¥æˆåŠŸ');
        updateStatus('æº–å‚™å°±ç·’');
        updateVoice('AI æ¨¡å‹è¼‰å…¥æˆåŠŸï¼è«‹é–‹å•Ÿç›¸æ©Ÿé–‹å§‹ä½¿ç”¨');
        
        initEventListeners();
        
      } catch (error) {
        console.error('âŒ æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
        updateModelStatus('è¼‰å…¥å¤±æ•—');
        updateVoice('æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥');
      }
    }

    function initEventListeners() {
      document.getElementById('btnCamera').addEventListener('click', setupCamera);
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnTest').addEventListener('click', testDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
    }

    // ç›¸æ©Ÿè¨­ç½®
    async function setupCamera() {
      try {
        updateVoice('æ­£åœ¨é–‹å•Ÿç›¸æ©Ÿâ€¦');
        updateCameraStatus('é–‹å•Ÿä¸­');
        
        // åœæ­¢ä¹‹å‰çš„ä¸²æµ
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }
        
        const video = document.getElementById('video');
        const preview = document.getElementById('cameraPreview');
        
        // è«‹æ±‚ç›¸æ©Ÿæ¬Šé™
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: 'environment'
          },
          audio: false
        });
        
        currentStream = stream;
        video.srcObject = stream;
        
        // ç­‰å¾…å½±ç‰‡è¼‰å…¥
        await new Promise((resolve) => {
          video.onloadedmetadata = () => resolve(video);
        });
        
        await video.play();
        
        // éš±è—é è¦½ç•«é¢
        preview.style.display = 'none';
        
        // å•Ÿç”¨æŒ‰éˆ•
        document.getElementById('btnStart').disabled = false;
        document.getElementById('btnTest').disabled = false;
        
        updateCameraStatus('å·²é–‹å•Ÿ');
        updateVoice('ç›¸æ©Ÿé–‹å•ŸæˆåŠŸï¼å¯ä»¥é–‹å§‹æª¢æ¸¬');
        
        console.log('ğŸ¥ ç›¸æ©Ÿé–‹å•ŸæˆåŠŸ');
        
      } catch (error) {
        console.error('âŒ ç›¸æ©Ÿé–‹å•Ÿå¤±æ•—:', error);
        updateCameraStatus('é–‹å•Ÿå¤±æ•—');
        updateVoice('ç„¡æ³•é–‹å•Ÿç›¸æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­å®š');
      }
    }

    // é–‹å§‹æª¢æ¸¬
    function startDetection() {
      if (!session) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥');
        return;
      }
      
      const video = document.getElementById('video');
      if (!video.srcObject) {
        updateVoice('è«‹å…ˆé–‹å•Ÿç›¸æ©Ÿ');
        return;
      }
      
      isDetecting = true;
      updateStatus('æª¢æ¸¬ä¸­');
      updateDetectionStatus('é‹è¡Œä¸­');
      updateVoice('é–‹å§‹éšœç¤™ç‰©æª¢æ¸¬');
      
      // é–‹å§‹æª¢æ¸¬å¾ªç’°
      detectionInterval = setInterval(async () => {
        if (!isDetecting) return;
        
        try {
          const predictions = await detectObjects(video);
          updateDetectionDisplay(predictions);
        } catch (error) {
          console.error('æª¢æ¸¬éŒ¯èª¤:', error);
        }
      }, 1000); // æ¯ç§’æª¢æ¸¬ä¸€æ¬¡
    }

    // æ¸¬è©¦æª¢æ¸¬
    async function testDetection() {
      if (!session) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥');
        return;
      }
      
      const video = document.getElementById('video');
      if (!video.srcObject) {
        updateVoice('è«‹å…ˆé–‹å•Ÿç›¸æ©Ÿ');
        return;
      }
      
      updateVoice('åŸ·è¡Œæ¸¬è©¦æª¢æ¸¬');
      
      try {
        const predictions = await detectObjects(video);
        if (predictions.length > 0) {
          updateVoice(`æ¸¬è©¦æˆåŠŸï¼æª¢æ¸¬åˆ° ${predictions.length} å€‹ç‰©é«”`);
        } else {
          updateVoice('æ¸¬è©¦å®Œæˆï¼Œæœªæª¢æ¸¬åˆ°ç‰©é«”');
        }
        updateDetectionDisplay(predictions);
      } catch (error) {
        console.error('æ¸¬è©¦æª¢æ¸¬éŒ¯èª¤:', error);
        updateVoice('æª¢æ¸¬æ¸¬è©¦å¤±æ•—');
      }
    }

    // åœæ­¢æª¢æ¸¬
    function stopDetection() {
      isDetecting = false;
      if (detectionInterval) {
        clearInterval(detectionInterval);
      }
      updateStatus('å·²åœæ­¢');
      updateDetectionStatus('å·²åœæ­¢');
      updateVoice('æª¢æ¸¬å·²åœæ­¢');
      clearDetectionDisplay();
    }

    // ç‰©ä»¶æª¢æ¸¬ä¸»å‡½æ•¸
    async function detectObjects(video) {
      try {
        // 1. æ“·å–ç•«é¢
        const imageData = captureFrame(video);
        
        // 2. é è™•ç†
        const inputTensor = preprocess(imageData);
        
        // 3. æ¨¡å‹æ¨ç†
        const feeds = { [session.inputNames[0]]: inputTensor };
        const results = await session.run(feeds);
        
        // 4. å¾Œè™•ç†
        const predictions = postprocess(results, video.videoWidth, video.videoHeight);
        
        console.log(`æª¢æ¸¬åˆ° ${predictions.length} å€‹ç‰©é«”:`, predictions);
        return predictions;
        
      } catch (error) {
        console.error('æª¢æ¸¬éç¨‹éŒ¯èª¤:', error);
        return [];
      }
    }

    // æ“·å–ç•«é¢
    function captureFrame(video) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = INPUT_SIZE;
      canvas.height = INPUT_SIZE;
      
      // ç¹ªè£½å½±ç‰‡ç•«é¢åˆ° canvas
      ctx.drawImage(video, 0, 0, INPUT_SIZE, INPUT_SIZE);
      
      return ctx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
    }

    // é è™•ç†
    function preprocess(imageData) {
      const { data } = imageData;
      const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
      
      // ç°¡å–®çš„ RGB æ­¸ä¸€åŒ–
      for (let i = 0; i < data.length; i += 4) {
        const pixelIndex = Math.floor(i / 4);
        input[pixelIndex] = data[i] / 255.0;         // R
        input[INPUT_SIZE * INPUT_SIZE + pixelIndex] = data[i + 1] / 255.0; // G
        input[2 * INPUT_SIZE * INPUT_SIZE + pixelIndex] = data[i + 2] / 255.0; // B
      }
      
      return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
    }

    // å¾Œè™•ç†
    function postprocess(results, frameWidth, frameHeight) {
      const output = results[session.outputNames[0]];
      const outputData = output.data;
      const predictions = [];
      
      // YOLOv8 è¼¸å‡ºæ ¼å¼: [1, 84, 8400]
      const numBoxes = output.dims[2]; // 8400
      const numClasses = output.dims[1] - 4; // 84 - 4 = 80
      
      for (let i = 0; i < numBoxes; i++) {
        const offset = i * output.dims[1];
        
        // ç²å–é‚Šç•Œæ¡†è³‡è¨Š
        const x = outputData[offset];
        const y = outputData[offset + 1];
        const w = outputData[offset + 2];
        const h = outputData[offset + 3];
        
        // ç²å–é¡åˆ¥åˆ†æ•¸
        let maxScore = 0;
        let classId = -1;
        
        for (let j = 0; j < numClasses; j++) {
          const score = outputData[offset + 4 + j];
          if (score > maxScore) {
            maxScore = score;
            classId = j;
          }
        }
        
        // éæ¿¾ä½åˆ†æ•¸æª¢æ¸¬
        if (maxScore < 0.25 || classId === -1) continue;
        
        // è½‰æ›ç‚ºåƒç´ åæ¨™
        const x1 = (x - w / 2) * frameWidth;
        const y1 = (y - h / 2) * frameHeight;
        const width = w * frameWidth;
        const height = h * frameHeight;
        
        // ä¼°ç®—è·é›¢
        const distance = estimateDistance(width, height, classId);
        
        predictions.push({
          class: CLASS_NAMES[classId],
          score: maxScore,
          bbox: [x1, y1, width, height],
          distance: distance
        });
      }
      
      return predictions;
    }

    // ä¼°ç®—è·é›¢
    function estimateDistance(width, height, classId) {
      const area = width * height;
      const referenceAreas = {
        'person': 15000,
        'car': 80000,
        'chair': 12000,
        'bottle': 3000
      };
      
      const className = CLASS_NAMES[classId];
      const refArea = referenceAreas[className] || 20000;
      
      return Math.sqrt(refArea / area) * 2;
    }

    // æ›´æ–°æª¢æ¸¬é¡¯ç¤º
    function updateDetectionDisplay(predictions) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="detection-item" style="text-align:center; color:var(--muted);">æœªåµæ¸¬åˆ°éšœç¤™ç‰©</div>';
        return;
      }
      
      // æŒ‰è·é›¢æ’åº
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => `
        <div class="detection-item">
          <strong>${pred.class}</strong><br>
          è·é›¢: ${pred.distance.toFixed(1)}å…¬å°º | ç½®ä¿¡åº¦: ${(pred.score * 100).toFixed(0)}%
        </div>
      `).join('');
      
      // èªéŸ³æç¤ºæœ€è¿‘çš„ç‰©é«”
      const closest = predictions[0];
      if (closest.distance < 2) {
        updateVoice(`è­¦å‘Šï¼${closest.class}éå¸¸æ¥è¿‘ï¼Œåƒ…${closest.distance.toFixed(1)}å…¬å°º`);
      }
    }

    function clearDetectionDisplay() {
      const list = document.getElementById('detectionList');
      list.innerHTML = '<div class="detection-item" style="text-align:center; color:var(--muted);">æª¢æ¸¬å·²åœæ­¢</div>';
    }

    // å·¥å…·å‡½æ•¸
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateModelStatus(status) {
      document.getElementById('modelStatus').textContent = status;
    }

    function updateCameraStatus(status) {
      document.getElementById('cameraStatus').textContent = status;
    }

    function updateDetectionStatus(status) {
      document.getElementById('detectionStatus').textContent = status;
    }

    // å•Ÿå‹•æ‡‰ç”¨
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>