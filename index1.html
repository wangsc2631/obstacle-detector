<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆªç³»çµ± - å³æ™‚éšœç¤™ç‰©æª¢æ¸¬èˆ‡GPSè¿”èˆª" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</title>
  
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    header.card {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: clamp(18px, 5vw, 24px);
      margin: 0;
      font-weight: 700;
    }
    
    .camera {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera video, .camera canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    /* ç§»é™¤æ‰€æœ‰é¡åƒè½‰æ› */
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .primary {
      background: var(--good);
      color: #fff;
    }
    
    .warning {
      background: var(--warn);
      color: #fff;
    }
    
    .danger {
      background: var(--bad);
      color: #fff;
    }
    
    .secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, 1fr);
      margin-bottom: 12px;
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .k {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .v {
      font-weight: 800;
      font-size: clamp(14px, 4vw, 16px);
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .list {
      max-height: 200px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
      padding-right: 4px;
    }
    
    .chip {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .debug-panel {
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="card">
      <h1>ğŸ§­ ç›²äººè¼”åŠ©å°èˆª</h1>
      <div class="tips">å®‰å…¨å‡ºè¡Œ Â· éšœç¤™æª¢æ¸¬</div>
    </header>

    <section class="card camera">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
    </section>

    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">ç³»çµ±åˆå§‹åŒ–ä¸­â€¦</div>
      
      <div class="controls">
        <button id="btnStart" class="btn primary">é–‹å§‹æª¢æ¸¬</button>
        <button id="btnStop" class="btn danger">åœæ­¢æª¢æ¸¬</button>
        <button id="btnVoice" class="btn secondary">èªéŸ³é—œé–‰</button>
        <button id="btnDebug" class="btn warning">é¡¯ç¤ºé™¤éŒ¯</button>
      </div>

      <div class="status">
        <div class="status-item">
          <div class="k">ç³»çµ±ç‹€æ…‹</div>
          <div class="v" id="status">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="k">åµæ¸¬é€Ÿåº¦</div>
          <div class="v" id="fps">â€”</div>
        </div>
        <div class="status-item">
          <div class="k">éšœç¤™ç‰©æ•¸</div>
          <div class="v" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="k">æœ€è¿‘è·é›¢</div>
          <div class="v" id="closestDistance">â€” å…¬å°º</div>
        </div>
      </div>

      <div id="debugPanel" class="debug-panel" style="display: none;">
        <div><strong>é™¤éŒ¯è³‡è¨Š:</strong></div>
        <div id="debugInfo">ç­‰å¾…é–‹å§‹åµæ¸¬...</div>
      </div>
    </section>

    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">å³æ™‚åµæ¸¬çµæœ</h3>
      <div id="detectionList" class="list">
        <div class="chip" style="text-align:center; color:var(--muted);">
          ç­‰å¾…é–‹å§‹åµæ¸¬â€¦
        </div>
      </div>
    </aside>
  </div>

  <script>
    // ç°¡åŒ–çš„æ¨¡å‹é…ç½®
    const MODEL_URL = 'https://raw.githubusercontent.com/ultralytics/assets/main/yolov8n.onnx';
    const INPUT_SIZE = 640;
    const SCORE_THRESHOLD = 0.25; // é™ä½é–€æª»æé«˜æª¢æ¸¬ç‡
    const IOU_THRESHOLD = 0.45;

    // COCO é¡åˆ¥åç¨±
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light',
      'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
      'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee',
      'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle',
      'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange',
      'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed',
      'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven',
      'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    // é‡è¦éšœç¤™ç‰©é¡åˆ¥
    const IMPORTANT_CLASSES = ['person', 'car', 'motorcycle', 'bus', 'truck', 'bicycle', 'chair', 'bench', 'bed', 'couch'];

    let session = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let debugMode = false;

    // åˆå§‹åŒ–æ¨¡å‹
    async function initModel() {
      try {
        updateVoice('æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...');
        updateDebugInfo('é–‹å§‹è¼‰å…¥æ¨¡å‹...');
        
        // è¨­å®š ONNX Runtime
        ort.env.wasm.numThreads = 1;
        
        updateDebugInfo('å»ºç«‹æ¨ç†æœƒè©±...');
        session = await ort.InferenceSession.create(MODEL_URL, {
          executionProviders: ['wasm']
        });
        
        updateDebugInfo(`æ¨¡å‹è¼‰å…¥æˆåŠŸï¼è¼¸å…¥å½¢ç‹€: ${session.inputNames[0]}`);
        updateVoice('æ¨¡å‹è¼‰å…¥å®Œæˆï¼é»æ“Šé–‹å§‹æª¢æ¸¬');
        updateStatus('æº–å‚™å°±ç·’');
        
      } catch (error) {
        console.error('æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
        updateDebugInfo(`æ¨¡å‹è¼‰å…¥éŒ¯èª¤: ${error.message}`);
        updateVoice('æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥');
      }
    }

    // è¨­å®šç›¸æ©Ÿ
    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }, 
          audio: false 
        });
        
        video.srcObject = stream;
        
        return new Promise((resolve) => {
          video.onloadedmetadata = () => {
            video.play().then(() => {
              updateDebugInfo(`ç›¸æ©Ÿå°±ç·’: ${video.videoWidth}x${video.videoHeight}`);
              resolve(video);
            });
          };
        });
      } catch (error) {
        console.error('ç›¸æ©ŸéŒ¯èª¤:', error);
        updateDebugInfo(`ç›¸æ©ŸéŒ¯èª¤: ${error.message}`);
        updateVoice('ç„¡æ³•å­˜å–ç›¸æ©Ÿ');
        return null;
      }
    }

    // é–‹å§‹æª¢æ¸¬
    async function startDetection() {
      if (!session) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥');
        return;
      }

      const video = await setupCamera();
      if (!video) return;

      isDetecting = true;
      updateStatus('æª¢æ¸¬ä¸­');
      updateVoice('é–‹å§‹éšœç¤™ç‰©æª¢æ¸¬');

      // é–‹å§‹æª¢æ¸¬å¾ªç’°
      detectFrame(video);
    }

    // åœæ­¢æª¢æ¸¬
    function stopDetection() {
      isDetecting = false;
      updateStatus('å·²åœæ­¢');
      
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      
      updateVoice('æª¢æ¸¬å·²åœæ­¢');
    }

    // ä¸»æª¢æ¸¬å¾ªç’°
    async function detectFrame(video) {
      if (!isDetecting) return;

      const startTime = performance.now();

      try {
        // 1. æ•æ‰ç•«é¢
        const imageData = captureFrame(video);
        
        // 2. é è™•ç†
        const inputTensor = preprocess(imageData);
        
        // 3. æ¨ç†
        const outputs = await session.run({ [session.inputNames[0]]: inputTensor });
        
        // 4. å¾Œè™•ç†
        const predictions = postprocess(outputs, video.videoWidth, video.videoHeight);
        
        // 5. è™•ç†çµæœ
        processPredictions(predictions);
        
        // 6. ç¹ªè£½çµæœ
        drawPredictions(predictions, video);
        
        // æ›´æ–° FPS
        updateFPS(performance.now() - startTime);

      } catch (error) {
        console.error('æª¢æ¸¬éŒ¯èª¤:', error);
        updateDebugInfo(`æª¢æ¸¬éŒ¯èª¤: ${error.message}`);
      }

      // ç¹¼çºŒä¸‹ä¸€å¹€
      if (isDetecting) {
        setTimeout(() => detectFrame(video), 100); // 10 FPS
      }
    }

    // æ•æ‰ç•«é¢
    function captureFrame(video) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      // æ­£å¸¸ç¹ªè£½ï¼Œä¸ç¿»è½‰
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    // é è™•ç†
    function preprocess(imageData) {
      const { data, width, height } = imageData;
      const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
      
      // ç°¡å–®çš„é è™•ç†ï¼šèª¿æ•´å¤§å° + æ­¸ä¸€åŒ–
      for (let c = 0; c < 3; c++) {
        for (let h = 0; h < INPUT_SIZE; h++) {
          for (let w = 0; w < INPUT_SIZE; w++) {
            // è¨ˆç®—å°æ‡‰çš„åŸåœ–åº§æ¨™
            const srcX = Math.floor(w * width / INPUT_SIZE);
            const srcY = Math.floor(h * height / INPUT_SIZE);
            const srcIndex = (srcY * width + srcX) * 4;
            
            const pixelValue = data[srcIndex + c] / 255.0; // æ­¸ä¸€åŒ–åˆ° [0,1]
            input[c * INPUT_SIZE * INPUT_SIZE + h * INPUT_SIZE + w] = pixelValue;
          }
        }
      }
      
      return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
    }

    // å¾Œè™•ç†
    function postprocess(outputs, originalWidth, originalHeight) {
      const predictions = [];
      const output = outputs[session.outputNames[0]];
      
      if (!output || !output.data) {
        return predictions;
      }

      const outputData = output.data;
      const numDetections = output.dims[1];
      const numClasses = output.dims[2] - 4;

      updateDebugInfo(`æª¢æ¸¬è¼¸å‡º: ${numDetections}å€‹æª¢æ¸¬, æ•¸æ“šé•·åº¦: ${outputData.length}`);

      for (let i = 0; i < numDetections; i++) {
        const offset = i * (numClasses + 4);
        const [x, y, width, height, ...scores] = Array.from(outputData.slice(offset, offset + numClasses + 4));
        
        // æ‰¾åˆ°æœ€é«˜åˆ†æ•¸çš„é¡åˆ¥
        const maxScore = Math.max(...scores);
        const classId = scores.indexOf(maxScore);

        if (maxScore > SCORE_THRESHOLD && classId < CLASS_NAMES.length) {
          // è½‰æ›åº§æ¨™åˆ°åŸåœ–å°ºå¯¸
          const scaleX = originalWidth / INPUT_SIZE;
          const scaleY = originalHeight / INPUT_SIZE;
          
          const bbox = [
            (x - width / 2) * scaleX,  // x
            (y - height / 2) * scaleY, // y
            width * scaleX,            // width
            height * scaleY            // height
          ];

          predictions.push({
            class: CLASS_NAMES[classId],
            score: maxScore,
            bbox: bbox,
            distance: estimateDistance(bbox[2], bbox[3], CLASS_NAMES[classId])
          });
        }
      }

      updateDebugInfo(`éæ¿¾å¾Œæª¢æ¸¬: ${predictions.length}å€‹ç‰©é«”`);
      return nonMaxSuppression(predictions, IOU_THRESHOLD);
    }

    // éæ¥µå¤§å€¼æŠ‘åˆ¶
    function nonMaxSuppression(predictions, iouThreshold) {
      predictions.sort((a, b) => b.score - a.score);
      const selected = [];

      while (predictions.length > 0) {
        const current = predictions[0];
        selected.push(current);

        predictions = predictions.slice(1).filter(pred => {
          return calculateIOU(current.bbox, pred.bbox) < iouThreshold;
        });
      }

      return selected;
    }

    // è¨ˆç®— IoU
    function calculateIOU(box1, box2) {
      const [x1, y1, w1, h1] = box1;
      const [x2, y2, w2, h2] = box2;

      const xLeft = Math.max(x1, x2);
      const yTop = Math.max(y1, y2);
      const xRight = Math.min(x1 + w1, x2 + w2);
      const yBottom = Math.min(y1 + h1, y2 + h2);

      if (xRight < xLeft || yBottom < yTop) {
        return 0.0;
      }

      const intersectionArea = (xRight - xLeft) * (yBottom - yTop);
      const box1Area = w1 * h1;
      const box2Area = w2 * h2;

      return intersectionArea / (box1Area + box2Area - intersectionArea);
    }

    // ä¼°ç®—è·é›¢
    function estimateDistance(width, height, className) {
      const area = width * height;
      let referenceArea = 10000; // é»˜èªåƒè€ƒé¢ç©

      // æ ¹æ“šç‰©é«”é¡å‹èª¿æ•´åƒè€ƒé¢ç©
      if (className === 'person') referenceArea = 8000;
      else if (className === 'car') referenceArea = 30000;
      else if (className === 'chair') referenceArea = 5000;

      // ç°¡å–®çš„è·é›¢ä¼°ç®—å…¬å¼
      const distance = Math.sqrt(referenceArea / area) * 2;
      return Math.min(Math.max(distance, 0.5), 20); // é™åˆ¶åœ¨ 0.5-20 å…¬å°º
    }

    // è™•ç†é æ¸¬çµæœ
    function processPredictions(predictions) {
      // éæ¿¾é‡è¦éšœç¤™ç‰©
      const obstacles = predictions.filter(p => IMPORTANT_CLASSES.includes(p.class));
      
      document.getElementById('obstacleCount').textContent = obstacles.length;
      
      // æ‰¾åˆ°æœ€è¿‘éšœç¤™ç‰©
      let closestDistance = Infinity;
      let closestObstacle = null;

      obstacles.forEach(obstacle => {
        if (obstacle.distance < closestDistance) {
          closestDistance = obstacle.distance;
          closestObstacle = obstacle;
        }
      });

      // æ›´æ–°æœ€è¿‘è·é›¢é¡¯ç¤º
      const distanceElement = document.getElementById('closestDistance');
      if (closestObstacle) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' å…¬å°º';
        
        // èªéŸ³è­¦å‘Š
        if (voiceEnabled && closestDistance < 5) {
          const now = Date.now();
          if (now - lastSpeechTime > 3000) { // 3ç§’å†·å»
            let message = `å‰æ–¹${closestDistance.toFixed(1)}å…¬å°ºæœ‰${closestObstacle.class}`;
            if (closestDistance < 2) message = `è­¦å‘Šï¼${message}ï¼Œè«‹å°å¿ƒ`;
            updateVoice(message);
            lastSpeechTime = now;
          }
        }
      } else {
        distanceElement.textContent = 'â€” å…¬å°º';
      }

      // æ›´æ–°åµæ¸¬åˆ—è¡¨
      updateDetectionList(obstacles);
    }

    let lastSpeechTime = 0;

    // ç¹ªè£½æª¢æ¸¬çµæœ
    function drawPredictions(predictions, video) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // è¨­å®š canvas å°ºå¯¸
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      // æ¸…é™¤ç•«å¸ƒ
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // ç¹ªè£½æ¯å€‹é æ¸¬æ¡†
      predictions.forEach(pred => {
        if (!IMPORTANT_CLASSES.includes(pred.class)) return;
        
        const [x, y, w, h] = pred.bbox;
        const color = pred.distance < 3 ? '#ff0000' : (pred.distance < 5 ? '#ff9900' : '#00ff00');
        
        // ç¹ªè£½é‚Šæ¡†
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        // ç¹ªè£½æ¨™ç±¤
        const label = `${pred.class} ${pred.distance.toFixed(1)}m`;
        ctx.font = '16px Arial';
        const textWidth = ctx.measureText(label).width;
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y - 20, textWidth + 10, 20);
        
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 5, y - 5);
      });
    }

    // æ›´æ–°åµæ¸¬åˆ—è¡¨
    function updateDetectionList(predictions) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="chip" style="text-align:center; color:var(--muted);">æœªåµæ¸¬åˆ°éšœç¤™ç‰©</div>';
        return;
      }
      
      // æŒ‰è·é›¢æ’åº
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        const dangerColor = pred.distance < 3 ? 'var(--bad)' : (pred.distance < 5 ? 'var(--warn)' : 'var(--good)');
        
        return `
          <div class="chip" style="border-left: 4px solid ${dangerColor}">
            <strong>${pred.class}</strong><br>
            è·é›¢: ${pred.distance.toFixed(1)}å…¬å°º | ç½®ä¿¡åº¦: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    // FPS è¨ˆç®—
    let frameCount = 0;
    let lastFpsUpdate = 0;

    function updateFPS(processingTime) {
      frameCount++;
      const now = performance.now();
      
      if (now - lastFpsUpdate >= 1000) {
        const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        lastFpsUpdate = now;
        
        if (debugMode) {
          updateDebugInfo(`FPS: ${fps}, è™•ç†æ™‚é–“: ${processingTime.toFixed(1)}ms`);
        }
      }
    }

    // å·¥å…·å‡½æ•¸
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateDebugInfo(info) {
      if (debugMode) {
        document.getElementById('debugInfo').textContent = info;
      }
    }

    // äº‹ä»¶ç›£è½å™¨
    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnDebug').addEventListener('click', toggleDebug);
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        button.textContent = 'èªéŸ³é—œé–‰';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('èªéŸ³æç¤ºå·²é–‹å•Ÿ');
      } else {
        button.textContent = 'èªéŸ³é–‹å•Ÿ';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleDebug() {
      debugMode = !debugMode;
      const panel = document.getElementById('debugPanel');
      const button = document.getElementById('btnDebug');
      
      if (debugMode) {
        panel.style.display = 'block';
        button.textContent = 'éš±è—é™¤éŒ¯';
        updateDebugInfo('é™¤éŒ¯æ¨¡å¼å·²é–‹å•Ÿ');
      } else {
        panel.style.display = 'none';
        button.textContent = 'é¡¯ç¤ºé™¤éŒ¯';
      }
    }

    // åˆå§‹åŒ–
    window.addEventListener('DOMContentLoaded', () => {
      initEventListeners();
      initModel();
    });
  </script>
</body>
</html>