<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆªç³»çµ± - å®‰å…¨é€šé“å°èˆª" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</title>
  
  <!-- TensorFlow.js å’Œ COCO-SSD -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
  
  <style>
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    
    @media (min-width: 920px) {
      .app {
        grid-template-columns: 6fr 4fr;
      }
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    header.card {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: clamp(18px, 5vw, 24px);
      margin: 0;
      font-weight: 700;
    }
    
    .camera {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera video, .camera canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    
    .camera video {
      transform: scaleX(1);
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    @media (min-width: 480px) {
      .controls {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .primary {
      background: var(--good);
      color: #fff;
    }
    
    .warning {
      background: var(--warn);
      color: #fff;
    }
    
    .danger {
      background: var(--bad);
      color: #fff;
    }
    
    .secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, 1fr);
      margin-bottom: 12px;
    }
    
    @media (min-width: 480px) {
      .status {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .k {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .v {
      font-weight: 800;
      font-size: clamp(14px, 4vw, 16px);
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .list {
      max-height: 200px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
      padding-right: 4px;
      -webkit-overflow-scrolling: touch;
    }
    
    .chip {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }
    
    /* å®‰å…¨é€šé“è¦–è¦ºåŒ– */
    .safe-path {
      position: absolute;
      pointer-events: none;
      z-index: 5;
    }
    
    .safe-lane {
      border: 3px dashed #22c55e;
      background: rgba(34, 197, 94, 0.1);
    }
    
    .safe-center {
      border: 2px solid #22c55e;
      background: rgba(34, 197, 94, 0.2);
    }
    
    .obstacle-warning-left {
      border-left: 4px solid #f59e0b;
      background: rgba(245, 158, 11, 0.1);
    }
    
    .obstacle-warning-right {
      border-right: 4px solid #f59e0b;
      background: rgba(245, 158, 11, 0.1);
    }
    
    .obstacle-danger {
      border: 4px solid #ef4444;
      background: rgba(239, 68, 68, 0.2);
      animation: pulse 1s infinite;
    }
    
    .navigation-arrow {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 15px solid #22c55e;
      z-index: 6;
      animation: float 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }

    .no-select {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    .progress-container {
      width: 100%;
      height: 6px;
      background: var(--glass-strong);
      border-radius: 3px;
      margin: 10px 0;
      overflow: hidden;
    }
    
    .progress-bar {
      height: 100%;
      background: var(--good);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
  </style>
</head>
<body class="no-select">
  <div class="app">
    <header class="card">
      <h1>ğŸ§­ ç›²äººå®‰å…¨é€šé“å°èˆª</h1>
      <div class="tips">å®‰å…¨è¡Œèµ° Â· éšœç¤™é¿è®“ Â· èªéŸ³æŒ‡å¼•</div>
    </header>

    <section class="card camera">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
      <div id="safePathContainer"></div>
    </section>

    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">ç³»çµ±åˆå§‹åŒ–ä¸­â€¦</div>
      
      <div id="progressContainer" class="progress-container" style="display: none;">
        <div id="progressBar" class="progress-bar"></div>
      </div>
      
      <div class="controls">
        <button id="btnStart" class="btn primary">é–‹å§‹å°èˆª</button>
        <button id="btnVoice" class="btn secondary">èªéŸ³é—œé–‰</button>
        <button id="btnRecordPath" class="btn warning">è¨˜éŒ„å®‰å…¨é€šé“</button>
        <button id="btnStop" class="btn danger">åœæ­¢</button>
      </div>

      <div class="status">
        <div class="status-item">
          <div class="k">å°èˆªç‹€æ…‹</div>
          <div class="v" id="navStatus">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="k">å®‰å…¨é€šé“</div>
          <div class="v" id="pathStatus">æœªè¨˜éŒ„</div>
        </div>
        <div class="status-item">
          <div class="k">éšœç¤™æª¢æ¸¬</div>
          <div class="v" id="obstacleStatus">æ­£å¸¸</div>
        </div>
        <div class="status-item">
          <div class="k">èªéŸ³ç‹€æ…‹</div>
          <div class="v" id="voiceStatus">é–‹å•Ÿ</div>
        </div>
      </div>
    </section>

    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">
        å°èˆªæŒ‡å¼•
      </h3>
      <div id="navigationGuide" class="list">
        <div class="chip" style="text-align:center; color:var(--muted);">
          ç­‰å¾…é–‹å§‹å°èˆªâ€¦
        </div>
      </div>
      <footer>
        å°ˆç‚ºè¦–éšœæœ‹å‹è¨­è¨ˆ Â· å®‰å…¨é€šé“å°èˆªç³»çµ±<br>
        è‡ªå‹•é¿éšœï¼ŒèªéŸ³æŒ‡å¼•å®‰å…¨è·¯ç·š
      </footer>
    </aside>
  </div>

  <script>
    /**********************
     * 1) åƒæ•¸è¨­å®š
     **********************/
    const TARGET_FPS = 15;
    const INTERVAL = 1000 / TARGET_FPS;
    const SCORE_THRESHOLD = 0.6;

    /**********************
     * 2) éšœç¤™ç‰©è³‡æ–™åº«
     **********************/
    const obstacleDatabase = {
      'car': 'è»Šè¼›',
      'motorcycle': 'æ‘©æ‰˜è»Š',
      'bus': 'å…¬è»Š',
      'truck': 'å¡è»Š',
      'bicycle': 'è…³è¸è»Š',
      'person': 'è¡Œäºº',
      'chair': 'æ¤…å­',
      'couch': 'æ²™ç™¼',
      'bed': 'åºŠ',
      'dining table': 'æ¡Œå­',
      'tv': 'é›»è¦–',
      'laptop': 'é›»è…¦'
    };

    /**********************
     * 3) å®‰å…¨é€šé“å°èˆªç³»çµ±
     **********************/
    class SafePathNavigator {
      constructor() {
        this.safePath = [];
        this.isRecording = false;
        this.isNavigating = false;
        this.safeLanes = [];
        this.lastWarningTime = 0;
        this.warningCooldown = 2000; // 2ç§’å†·å»
      }

      startRecording() {
        this.safePath = [];
        this.isRecording = true;
        this.isNavigating = false;
        updateVoice('é–‹å§‹è¨˜éŒ„å®‰å…¨é€šé“ï¼Œè«‹åœ¨å®‰å…¨å€åŸŸç·©æ…¢ç›´è¡Œ');
        updateNavigationGuide('æ­£åœ¨è¨˜éŒ„å®‰å…¨é€šé“...');
        document.getElementById('pathStatus').textContent = 'è¨˜éŒ„ä¸­';
        document.getElementById('btnRecordPath').textContent = 'åœæ­¢è¨˜éŒ„';
        document.getElementById('btnRecordPath').classList.remove('warning');
        document.getElementById('btnRecordPath').classList.add('danger');
      }

      stopRecording() {
        this.isRecording = false;
        if (this.safePath.length > 0) {
          localStorage.setItem('safePath', JSON.stringify(this.safePath));
          updateVoice(`å®‰å…¨é€šé“è¨˜éŒ„å®Œæˆï¼Œå…±${this.safePath.length}å€‹å®‰å…¨é»`);
          document.getElementById('pathStatus').textContent = 'å·²è¨˜éŒ„';
        } else {
          updateVoice('æœªè¨˜éŒ„åˆ°å®‰å…¨é€šé“ï¼Œè«‹é‡æ–°è¨˜éŒ„');
          document.getElementById('pathStatus').textContent = 'æœªè¨˜éŒ„';
        }
        document.getElementById('btnRecordPath').textContent = 'è¨˜éŒ„å®‰å…¨é€šé“';
        document.getElementById('btnRecordPath').classList.remove('danger');
        document.getElementById('btnRecordPath').classList.add('warning');
        this.clearDisplay();
      }

      startNavigation() {
        const savedPath = localStorage.getItem('safePath');
        if (!savedPath) {
          updateVoice('è«‹å…ˆè¨˜éŒ„å®‰å…¨é€šé“');
          return;
        }

        this.safePath = JSON.parse(savedPath);
        this.isNavigating = true;
        this.isRecording = false;
        
        updateVoice('é–‹å§‹å®‰å…¨é€šé“å°èˆªï¼Œè«‹è·Ÿéš¨èªéŸ³æŒ‡å¼•');
        updateNavigationGuide('è·Ÿéš¨å®‰å…¨é€šé“å‰é€²');
        document.getElementById('navStatus').textContent = 'å°èˆªä¸­';
        
        this.updateDisplay();
      }

      stopNavigation() {
        this.isNavigating = false;
        this.isRecording = false;
        updateVoice('å°èˆªå·²åœæ­¢');
        document.getElementById('navStatus').textContent = 'å·²åœæ­¢';
        document.getElementById('btnRecordPath').textContent = 'è¨˜éŒ„å®‰å…¨é€šé“';
        document.getElementById('btnRecordPath').classList.remove('danger');
        document.getElementById('btnRecordPath').classList.add('warning');
        this.clearDisplay();
      }

      analyzeSafety(videoWidth, videoHeight, predictions) {
        if (!this.isNavigating && !this.isRecording) return;

        const obstacles = predictions.filter(p => 
          p.score > SCORE_THRESHOLD && obstacleDatabase[p.class]
        );

        // åˆ†æå®‰å…¨å€åŸŸ
        const safeZones = this.findSafeZones(videoWidth, videoHeight, obstacles);
        
        if (this.isRecording) {
          this.recordSafePath(safeZones, videoWidth, videoHeight);
        } else if (this.isNavigating) {
          this.guidanceNavigation(safeZones, obstacles, videoWidth, videoHeight);
        }

        this.updateDisplay();
      }

      findSafeZones(width, height, obstacles) {
        const gridSize = 60;
        const cols = Math.floor(width / gridSize);
        const rows = Math.floor(height / gridSize);
        
        // å»ºç«‹éšœç¤™ç‰©åœ°åœ–
        const obstacleGrid = Array(cols * rows).fill(false);
        
        obstacles.forEach(obs => {
          const [x, y, w, h] = obs.bbox;
          const startCol = Math.max(0, Math.floor(x / gridSize));
          const startRow = Math.max(0, Math.floor(y / gridSize));
          const endCol = Math.min(cols-1, Math.floor((x + w) / gridSize));
          const endRow = Math.min(rows-1, Math.floor((y + h) / gridSize));
          
          for (let r = startRow; r <= endRow; r++) {
            for (let c = startCol; c <= endCol; c++) {
              obstacleGrid[r * cols + c] = true;
            }
          }
        });

        // å°‹æ‰¾å®‰å…¨é€šé“
        const safeZones = [];
        const centerCol = Math.floor(cols / 2);
        
        // å¾åº•éƒ¨ä¸­å¿ƒé–‹å§‹å°‹æ‰¾å®‰å…¨è·¯å¾‘
        for (let row = rows - 1; row >= 0; row--) {
          let leftSafe = 0, rightSafe = 0;
          
          // å‘å·¦æª¢æŸ¥
          for (let col = centerCol; col >= 0; col--) {
            if (!obstacleGrid[row * cols + col]) {
              leftSafe++;
            } else {
              break;
            }
          }
          
          // å‘å³æª¢æŸ¥
          for (let col = centerCol; col < cols; col++) {
            if (!obstacleGrid[row * cols + col]) {
              rightSafe++;
            } else {
              break;
            }
          }
          
          safeZones.push({
            row,
            leftSafe,
            rightSafe,
            centerSafe: Math.min(leftSafe, rightSafe),
            hasObstacle: obstacleGrid[row * cols + centerCol]
          });
        }
        
        return safeZones;
      }

      recordSafePath(safeZones, width, height) {
        const gridSize = 60;
        const centerCol = Math.floor(width / gridSize / 2);
        
        // è¨˜éŒ„æœ€å®‰å…¨çš„è·¯å¾‘é»
        const safePoint = {
          x: centerCol * gridSize,
          y: (safeZones[0]?.row || 0) * gridSize,
          width: gridSize * 3,
          height: gridSize,
          timestamp: Date.now(),
          safetyScore: safeZones[0]?.centerSafe || 0
        };
        
        this.safePath.push(safePoint);
        
        // é™åˆ¶è¨˜éŒ„æ•¸é‡
        if (this.safePath.length > 100) {
          this.safePath.shift();
        }
      }

      guidanceNavigation(safeZones, obstacles, width, height) {
        const now = Date.now();
        if (now - this.lastWarningTime < this.warningCooldown) return;

        // åˆ†æå‰æ–¹éšœç¤™ç‰©
        const frontObstacles = obstacles.filter(obs => {
          const [x, y, w, h] = obs.bbox;
          return y + h > height * 0.6; // å‰æ–¹å€åŸŸ
        });

        // åˆ†æå·¦å³å´éšœç¤™ç‰©
        const leftObstacles = obstacles.filter(obs => {
          const [x, y, w, h] = obs.bbox;
          return x + w < width * 0.4; // å·¦å´å€åŸŸ
        });

        const rightObstacles = obstacles.filter(obs => {
          const [x, y, w, h] = obs.bbox;
          return x > width * 0.6; // å³å´å€åŸŸ
        });

        // ç”Ÿæˆå°èˆªæŒ‡å¼•
        let guidance = '';
        let obstacleStatus = 'æ­£å¸¸';

        if (frontObstacles.length > 0) {
          const centerSafe = safeZones[0]?.centerSafe || 0;
          if (centerSafe >= 2) {
            guidance = 'å‰æ–¹æœ‰éšœç¤™ç‰©ï¼Œè«‹ç¹¼çºŒç›´è¡Œé€šé';
          } else if (safeZones[0]?.leftSafe > safeZones[0]?.rightSafe) {
            guidance = 'å‰æ–¹æœ‰éšœç¤™ç‰©ï¼Œè«‹ç¨å¾®é å³é€šè¡Œ';
          } else {
            guidance = 'å‰æ–¹æœ‰éšœç¤™ç‰©ï¼Œè«‹ç¨å¾®é å·¦é€šè¡Œ';
          }
          obstacleStatus = 'å‰æ–¹éšœç¤™';
        } else if (leftObstacles.length > 0) {
          guidance = 'å·¦å´æœ‰éšœç¤™ç‰©ï¼Œè«‹é å³è¡Œèµ°';
          obstacleStatus = 'å·¦å´éšœç¤™';
        } else if (rightObstacles.length > 0) {
          guidance = 'å³å´æœ‰éšœç¤™ç‰©ï¼Œè«‹é å·¦è¡Œèµ°';
          obstacleStatus = 'å³å´éšœç¤™';
        } else {
          guidance = 'é€šé“å®‰å…¨ï¼Œè«‹ç›´è¡Œå‰é€²';
          obstacleStatus = 'æ­£å¸¸';
        }

        if (guidance) {
          updateVoice(guidance);
          updateNavigationGuide(guidance);
          document.getElementById('obstacleStatus').textContent = obstacleStatus;
          this.lastWarningTime = now;
        }
      }

      updateDisplay() {
        const container = document.getElementById('safePathContainer');
        container.innerHTML = '';

        if (this.isRecording || this.isNavigating) {
          // é¡¯ç¤ºå®‰å…¨é€šé“
          this.safePath.forEach((zone, index) => {
            const safeElement = document.createElement('div');
            safeElement.className = 'safe-path safe-lane';
            safeElement.style.left = (zone.x - zone.width/2) + 'px';
            safeElement.style.top = zone.y + 'px';
            safeElement.style.width = zone.width + 'px';
            safeElement.style.height = zone.height + 'px';
            container.appendChild(safeElement);

            // é¡¯ç¤ºå°èˆªç®­é ­
            if (index === this.safePath.length - 1) {
              const arrow = document.createElement('div');
              arrow.className = 'navigation-arrow';
              arrow.style.left = (zone.x - 10) + 'px';
              arrow.style.top = (zone.y - 20) + 'px';
              container.appendChild(arrow);
            }
          });
        }
      }

      clearDisplay() {
        const container = document.getElementById('safePathContainer');
        container.innerHTML = '';
      }

      toggleRecording() {
        if (this.isRecording) {
          this.stopRecording();
        } else if (this.isNavigating) {
          this.stopNavigation();
        } else {
          this.startRecording();
        }
      }
    }

    /**********************
     * 4) ç‹€æ…‹è®Šæ•¸
     **********************/
    let model = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let safePathNavigator = new SafePathNavigator();

    /**********************
     * 5) æ¨¡å‹è¼‰å…¥
     **********************/
    async function initModel() {
      try {
        updateVoice('æ­£åœ¨è¼‰å…¥å°èˆªç³»çµ±â€¦');
        
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        progressContainer.style.display = 'block';
        progressBar.style.width = '60%';
        
        model = await cocoSsd.load();
        
        progressBar.style.width = '100%';
        progressBar.style.background = 'var(--good)';
        
        initEventListeners();
        updateVoice('å°èˆªç³»çµ±æº–å‚™å®Œæˆï¼Œè«‹é–‹å§‹è¨˜éŒ„å®‰å…¨é€šé“');
        document.getElementById('navStatus').textContent = 'æº–å‚™å°±ç·’';
        
        setTimeout(() => {
          progressContainer.style.display = 'none';
        }, 1000);
        
      } catch (e) {
        console.error('æ¨¡å‹è¼‰å…¥éŒ¯èª¤:', e);
        updateVoice('ç³»çµ±è¼‰å…¥å¤±æ•—ï¼Œè«‹åˆ·æ–°é é¢é‡è©¦');
        document.getElementById('progressContainer').style.display = 'none';
      }
    }

    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startNavigation);
      document.getElementById('btnStop').addEventListener('click', stopNavigation);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnRecordPath').addEventListener('click', () => safePathNavigator.toggleRecording());
    }

    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment', 
            width: { ideal: 640 },
            height: { ideal: 480 } 
          }, 
          audio: false 
        });
        video.srcObject = stream; 
        await new Promise((resolve) => {
          video.onloadedmetadata = () => { resolve(video); };
        }); 
        await video.play();
        return video;
      } catch (e) { 
        console.error('ç›¸æ©ŸéŒ¯èª¤:', e); 
        updateVoice('ç„¡æ³•å­˜å–ç›¸æ©Ÿï¼Œè«‹ç¢ºèªæ¬Šé™'); 
        return null; 
      }
    }

    /**********************
     * 6) ä¸»å°èˆªæµç¨‹
     **********************/
    async function startNavigation() {
      if (!model) {
        updateVoice('ç³»çµ±å°šæœªè¼‰å…¥å®Œæˆï¼Œè«‹ç¨å€™');
        return;
      }
      
      const video = await setupCamera(); 
      if (!video) return;
      
      isDetecting = true; 
      document.getElementById('navStatus').textContent = 'å°èˆªä¸­';
      updateVoice('å®‰å…¨é€šé“å°èˆªå•Ÿå‹•ï¼Œé–‹å§‹æª¢æ¸¬å‘¨åœç’°å¢ƒ');
      updateNavigationGuide('æª¢æ¸¬ç’°å¢ƒä¸­...');
      
      requestAnimationFrame((ts) => navigationLoop(video, ts));
    }

    function stopNavigation() {
      isDetecting = false; 
      document.getElementById('navStatus').textContent = 'å·²åœæ­¢';
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      updateVoice('å°èˆªå·²åœæ­¢');
      safePathNavigator.stopNavigation();
    }

    async function navigationLoop(video, ts = 0) {
      if (!isDetecting) return;
      
      if (ts - lastTick >= INTERVAL) {
        try {
          const predictions = await model.detect(video);
          
          // å®‰å…¨é€šé“åˆ†æå’Œå°èˆª
          safePathNavigator.analyzeSafety(video.videoWidth, video.videoHeight, predictions);

          lastTick = ts;
        } catch (error) {
          console.error('å°èˆªå¾ªç’°éŒ¯èª¤:', error);
        }
      }
      requestAnimationFrame((n) => navigationLoop(video, n));
    }

    let lastTick = 0;

    /**********************
     * 7) å·¥å…·å‡½æ•¸
     **********************/
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateNavigationGuide(message) {
      const guideElement = document.getElementById('navigationGuide');
      guideElement.innerHTML = `
        <div class="chip" style="text-align:center; border-left: 4px solid var(--good);">
          <strong>${message}</strong>
        </div>
      `;
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const status = document.getElementById('voiceStatus');
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        status.textContent = 'é–‹å•Ÿ';
        button.textContent = 'èªéŸ³é—œé–‰';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('èªéŸ³æŒ‡å¼•å·²é–‹å•Ÿ');
      } else {
        status.textContent = 'é—œé–‰';
        button.textContent = 'èªéŸ³é–‹å•Ÿ';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    /**********************
     * 8) åˆå§‹åŒ–æ‡‰ç”¨
     **********************/
    window.addEventListener('DOMContentLoaded', () => {
      updateVoice('ç›²äººå®‰å…¨é€šé“å°èˆªç³»çµ±å•Ÿå‹•ä¸­...');
      initModel();
    });

    // é˜²æ­¢é é¢ä¼‘çœ 
    let wakeLock = null;
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
        }
      } catch (err) {
        console.log('Wake Lock å¤±æ•—:', err.message);
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && isDetecting) {
        await requestWakeLock();
      }
    });

    requestWakeLock();
  </script>
</body>
</html>