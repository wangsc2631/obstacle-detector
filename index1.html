<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆªç³»çµ± - å³æ™‚éšœç¤™ç‰©æª¢æ¸¬èˆ‡GPSè¿”èˆª" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</title>
  
  <!-- PWA æ”¯æŒ -->
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§­</text></svg>">
  
  <!-- TensorFlow.js å’Œ COCO-SSD -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
  
  <style>
    /* ä¿æŒåŸæœ‰çš„ CSS æ¨£å¼ä¸è®Š */
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    
    @media (min-width: 920px) {
      .app {
        grid-template-columns: 6fr 4fr;
      }
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    header.card {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: clamp(18px, 5vw, 24px);
      margin: 0;
      font-weight: 700;
    }
    
    header .tips {
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    
    @media (min-width: 768px) {
      header .tips {
        display: block;
      }
    }
    
    .camera {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
    }
    
    .camera video, .camera canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    
    /* ç§»é™¤é¡åƒæ•ˆæœ */
    .camera video {
      transform: scaleX(1);
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    @media (min-width: 480px) {
      .controls {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .primary {
      background: var(--good);
      color: #fff;
    }
    
    .warning {
      background: var(--warn);
      color: #fff;
    }
    
    .danger {
      background: var(--bad);
      color: #fff;
    }
    
    .secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, 1fr);
      margin-bottom: 12px;
    }
    
    @media (min-width: 480px) {
      .status {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .k {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .v {
      font-weight: 800;
      font-size: clamp(14px, 4vw, 16px);
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .list {
      max-height: 200px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
      padding-right: 4px;
      -webkit-overflow-scrolling: touch;
    }
    
    .chip {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }
    
    .module-tag {
      display: inline-block;
      background: var(--warn);
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 10px;
      margin-left: 8px;
      font-weight: 600;
    }
    
    .gps-active {
      background: var(--good) !important;
    }
    
    .emergency-alert {
      animation: pulse 1s infinite;
      border: 2px solid var(--bad);
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    .obstacle-warning {
      background: rgba(245,158,11,0.3);
      border: 2px solid var(--warn);
    }
    
    .danger-warning {
      background: rgba(239,68,68,0.3);
      border: 2px solid var(--bad);
    }
    
    @keyframes pulse {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
      100% {
        opacity: 1;
      }
    }
    
    @keyframes loading {
      0% {
        background-position: 200% 0;
      }
      100% {
        background-position: -200% 0;
      }
    }
    
    /* æ‰‹æ©Ÿå„ªåŒ– */
    @media (max-width: 480px) {
      body {
        padding: 8px;
      }
      
      .panel {
        padding: 12px;
      }
      
      button.btn {
        padding: 14px 10px;
        font-size: 13px;
        min-height: 50px;
      }
      
      .status-item {
        padding: 10px;
      }
      
      .voice-alert {
        padding: 14px;
        min-height: 55px;
        font-size: 14px;
      }
    }
    
    /* é˜²æ­¢æ–‡å­—é¸æ“‡ */
    .no-select {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    /* æ¨¡å‹è¼‰å…¥é€²åº¦æ¢ */
    .progress-container {
      width: 100%;
      height: 6px;
      background: var(--glass-strong);
      border-radius: 3px;
      margin: 10px 0;
      overflow: hidden;
    }
    
    .progress-bar {
      height: 100%;
      background: var(--good);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }

    /* ç’°å¢ƒæŒ‡ç¤ºå™¨ */
    .environment-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
    }
    
    .indoor-indicator { background: #2196F3; }
    .outdoor-indicator { background: #4CAF50; }
    .auto-indicator { background: #FF9800; }

    /* å®‰å…¨é€šé“è¦–è¦ºåŒ– */
    .safe-path {
      position: absolute;
      border: 3px dashed #22c55e;
      background: rgba(34, 197, 94, 0.1);
      pointer-events: none;
      z-index: 5;
    }
  </style>
</head>
<body class="no-select">
  <div class="app">
    <header class="card">
      <h1>ğŸ§­ ç›²äººè¼”åŠ©å°èˆª</h1>
      <div class="tips">å®‰å…¨å‡ºè¡Œ Â· æ™ºèƒ½ç’°å¢ƒæª¢æ¸¬ Â· å®‰å…¨é€šé“å°èˆª</div>
    </header>

    <section class="card camera">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
      <div id="safePathContainer"></div>
    </section>

    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">ç³»çµ±åˆå§‹åŒ–ä¸­â€¦</div>
      
      <!-- æ¨¡å‹è¼‰å…¥é€²åº¦ -->
      <div id="progressContainer" class="progress-container" style="display: none;">
        <div id="progressBar" class="progress-bar"></div>
      </div>
      
      <!-- ä¸»è¦æ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnStart" class="btn primary">é–‹å§‹æª¢æ¸¬</button>
        <button id="btnVoice" class="btn secondary">èªéŸ³é—œé–‰</button>
        <button id="btnMode" class="btn primary">æ™ºèƒ½æ¨¡å¼</button>
        <button id="btnStop" class="btn danger">åœæ­¢</button>
      </div>
      
      <!-- å°èˆªæ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnSetHome" class="btn primary">è¨­å®šå®‰å…¨èµ·é»</button>
        <button id="btnReturnHome" class="btn warning" id="safePathBtn">å®‰å…¨é€šé“å°èˆª</button>
        <button id="btnLoadModule" class="btn primary">æ‰‹å‹•åˆ‡æ›ç’°å¢ƒ</button>
        <button id="btnEmergency" class="btn danger">ç·Šæ€¥æ±‚åŠ©</button>
      </div>

      <!-- ç‹€æ…‹è³‡è¨Š -->
      <div class="status">
        <div class="status-item">
          <div class="k">ç³»çµ±ç‹€æ…‹</div>
          <div class="v" id="status">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="k">åµæ¸¬é€Ÿåº¦</div>
          <div class="v" id="fps">â€”</div>
        </div>
        <div class="status-item">
          <div class="k">éšœç¤™ç‰©æ•¸</div>
          <div class="v" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="k">æœ€è¿‘è·é›¢</div>
          <div class="v" id="closestDistance">â€” å…¬å°º</div>
        </div>
      </div>
      
      <div class="status">
        <div class="status-item">
          <div class="k">å°èˆªç‹€æ…‹</div>
          <div class="v" id="gpsStatus">æœªå•Ÿå‹•</div>
        </div>
        <div class="status-item">
          <div class="k">å®‰å…¨é€šé“</div>
          <div class="v" id="safePathStatus">æœªè¨˜éŒ„</div>
        </div>
        <div class="status-item">
          <div class="k">ç’°å¢ƒåˆ¤æ–·</div>
          <div class="v" id="currentModule">
            <span class="environment-indicator auto-indicator"></span>è‡ªå‹•
          </div>
        </div>
        <div class="status-item">
          <div class="k">èªéŸ³ç‹€æ…‹</div>
          <div class="v" id="voiceStatus">é–‹å•Ÿ</div>
        </div>
      </div>
    </section>

    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">
        å³æ™‚åµæ¸¬ <span id="activeModuleTag" class="module-tag">æ™ºèƒ½æ¨¡å¼</span>
      </h3>
      <div id="detectionList" class="list">
        <div class="chip" style="text-align:center; color:var(--muted);">
          ç­‰å¾…é–‹å§‹åµæ¸¬â€¦
        </div>
      </div>
      <footer>
        å°ˆç‚ºè¦–éšœæœ‹å‹è¨­è¨ˆ Â· æ™ºèƒ½ç’°å¢ƒè­˜åˆ¥<br>
        å®‰å…¨é€šé“å°èˆªï¼Œé¿é–‹éšœç¤™ç‰©
      </footer>
    </aside>
  </div>

  <script>
    /**********************
     * 1) åƒæ•¸è¨­å®š
     **********************/
    const TARGET_FPS = 15;
    const INTERVAL = 1000 / TARGET_FPS;
    const SCORE_THRESHOLD = 0.6; // æé«˜é–¾å€¼æ¸›å°‘èª¤åˆ¤

    /**********************
     * 2) ä¿®æ­£ç’°å¢ƒæ¨¡çµ„ç³»çµ± - ç§»é™¤è²“ç‹—ç«è»Š
     **********************/
    const environmentModules = {
      outdoor: {
        name: 'æˆ¶å¤–å°èˆª',
        objects: {
          'car': { name: 'æ±½è»Š', danger: 'high', voice: 'å‰æ–¹æœ‰æ±½è»Šï¼Œè«‹ä¿æŒå®‰å…¨è·é›¢' },
          'motorcycle': { name: 'æ‘©æ‰˜è»Š', danger: 'high', voice: 'æ³¨æ„ï¼å‰æ–¹æœ‰æ‘©æ‰˜è»Š' },
          'bus': { name: 'å…¬è»Š', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å…¬è»Š' },
          'truck': { name: 'å¡è»Š', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å¡è»Š' },
          'bicycle': { name: 'è…³è¸è»Š', danger: 'medium', voice: 'å‰æ–¹æœ‰è…³è¸è»Š' },
          'traffic light': { name: 'ç´…ç¶ ç‡ˆ', danger: 'medium', voice: 'å‰æ–¹æœ‰ç´…ç¶ ç‡ˆï¼Œè«‹æ³¨æ„äº¤é€šè™ŸèªŒ' },
          'stop sign': { name: 'åœæ­¢æ¨™èªŒ', danger: 'medium', voice: 'åœæ­¢æ¨™èªŒï¼Œè«‹åœè»Šè§€å¯Ÿ' },
          'person': { name: 'è¡Œäºº', danger: 'medium', voice: 'å‰æ–¹æœ‰è¡Œäºº' },
          'bench': { name: 'é•·æ¤…', danger: 'low', voice: 'å‰æ–¹æœ‰é•·æ¤…' },
          'fire hydrant': { name: 'æ¶ˆé˜²æ “', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¶ˆé˜²æ “' }
        },
        triggers: ['car', 'motorcycle', 'bus', 'traffic light', 'stop sign', 'person']
      },
      indoor: {
        name: 'å®¤å…§ç’°å¢ƒ',
        objects: {
          'chair': { name: 'æ¤…å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¤…å­ï¼Œè«‹ç¹è¡Œ' },
          'couch': { name: 'æ²™ç™¼', danger: 'medium', voice: 'å‰æ–¹æœ‰æ²™ç™¼' },
          'bed': { name: 'åºŠ', danger: 'medium', voice: 'å‰æ–¹æœ‰åºŠ' },
          'dining table': { name: 'é¤æ¡Œ', danger: 'medium', voice: 'å‰æ–¹æœ‰é¤æ¡Œ' },
          'potted plant': { name: 'ç›†æ ½', danger: 'low', voice: 'å‰æ–¹æœ‰ç›†æ ½' },
          'tv': { name: 'é›»è¦–', danger: 'medium', voice: 'å‰æ–¹æœ‰é›»è¦–' },
          'laptop': { name: 'ç­†è¨˜å‹é›»è…¦', danger: 'medium', voice: 'å‰æ–¹æœ‰é›»è…¦' },
          'mouse': { name: 'æ»‘é¼ ', danger: 'low', voice: 'å‰æ–¹æœ‰æ»‘é¼ ' },
          'remote': { name: 'é™æ§å™¨', danger: 'low', voice: 'å‰æ–¹æœ‰é™æ§å™¨' },
          'keyboard': { name: 'éµç›¤', danger: 'low', voice: 'å‰æ–¹æœ‰éµç›¤' },
          'cell phone': { name: 'æ‰‹æ©Ÿ', danger: 'low', voice: 'å‰æ–¹æœ‰æ‰‹æ©Ÿ' },
          'book': { name: 'æ›¸æœ¬', danger: 'low', voice: 'å‰æ–¹æœ‰æ›¸æœ¬' },
          'vase': { name: 'èŠ±ç“¶', danger: 'medium', voice: 'å‰æ–¹æœ‰èŠ±ç“¶ï¼Œæ˜“ç¢ç‰©å“è«‹å°å¿ƒ' },
          'clock': { name: 'æ™‚é˜', danger: 'low', voice: 'å‰æ–¹æœ‰æ™‚é˜' },
          'scissors': { name: 'å‰ªåˆ€', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å‰ªåˆ€ï¼Œé‹’åˆ©ç‰©å“è«‹å°å¿ƒ' },
          'bottle': { name: 'ç“¶å­', danger: 'medium', voice: 'å‰æ–¹æœ‰ç“¶å­' },
          'cup': { name: 'æ¯å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¯å­' },
          'bowl': { name: 'ç¢—', danger: 'medium', voice: 'å‰æ–¹æœ‰ç¢—' },
          'fork': { name: 'å‰å­', danger: 'medium', voice: 'å‰æ–¹æœ‰å‰å­' },
          'knife': { name: 'åˆ€å­', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰åˆ€å­ï¼Œé‹’åˆ©ç‰©å“è«‹å°å¿ƒ' },
          'spoon': { name: 'æ¹¯åŒ™', danger: 'low', voice: 'å‰æ–¹æœ‰æ¹¯åŒ™' }
        },
        triggers: ['chair', 'bed', 'dining table', 'tv', 'laptop', 'vase', 'knife', 'scissors']
      },
      kitchen: {
        name: 'å»šæˆ¿ç’°å¢ƒ',
        objects: {
          'knife': { name: 'åˆ€å­', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰åˆ€å­ï¼Œé‹’åˆ©ç‰©å“è«‹å°å¿ƒ' },
          'cup': { name: 'æ¯å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¯å­ï¼Œè«‹å°å¿ƒæ‹¿å–' },
          'fork': { name: 'å‰å­', danger: 'medium', voice: 'å‰æ–¹æœ‰å‰å­ï¼Œè«‹æ³¨æ„å°–é½’' },
          'spoon': { name: 'æ¹¯åŒ™', danger: 'low', voice: 'å‰æ–¹æœ‰æ¹¯åŒ™' },
          'bowl': { name: 'ç¢—', danger: 'medium', voice: 'å‰æ–¹æœ‰ç¢—' },
          'oven': { name: 'çƒ¤ç®±', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰çƒ¤ç®±ï¼Œé«˜æº«è¨­å‚™è«‹å°å¿ƒ' },
          'microwave': { name: 'å¾®æ³¢çˆ', danger: 'high', voice: 'æ³¨æ„ï¼å‰æ–¹æœ‰å¾®æ³¢çˆ' },
          'refrigerator': { name: 'å†°ç®±', danger: 'medium', voice: 'å‰æ–¹æœ‰å†°ç®±' },
          'sink': { name: 'æ°´æ§½', danger: 'medium', voice: 'å‰æ–¹æœ‰æ°´æ§½' },
          'bottle': { name: 'ç“¶å­', danger: 'medium', voice: 'å‰æ–¹æœ‰ç“¶å­' },
          'dining table': { name: 'é¤æ¡Œ', danger: 'medium', voice: 'å‰æ–¹æœ‰é¤æ¡Œ' },
          'chair': { name: 'æ¤…å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¤…å­' }
        },
        triggers: ['knife', 'oven', 'microwave', 'cup', 'bottle']
      },
      bathroom: {
        name: 'æµ´å®¤ç’°å¢ƒ',
        objects: {
          'toilet': { name: 'é¦¬æ¡¶', danger: 'medium', voice: 'å‰æ–¹æœ‰é¦¬æ¡¶' },
          'sink': { name: 'æ´—æ‰‹å°', danger: 'medium', voice: 'å‰æ–¹æœ‰æ´—æ‰‹å°' },
          'bottle': { name: 'æ´—é«®ç²¾', danger: 'low', voice: 'å‰æ–¹æœ‰æ´—é«®ç²¾' },
          'toothbrush': { name: 'ç‰™åˆ·', danger: 'low', voice: 'å‰æ–¹æœ‰ç‰™åˆ·' },
          'hair drier': { name: 'å¹é¢¨æ©Ÿ', danger: 'medium', voice: 'å‰æ–¹æœ‰å¹é¢¨æ©Ÿ' },
          'cup': { name: 'æ¯å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¯å­' }
        },
        triggers: ['toilet', 'sink', 'bottle']
      },
      office: {
        name: 'è¾¦å…¬å®¤ç’°å¢ƒ',
        objects: {
          'chair': { name: 'è¾¦å…¬æ¤…', danger: 'medium', voice: 'å‰æ–¹æœ‰è¾¦å…¬æ¤…' },
          'desk': { name: 'è¾¦å…¬æ¡Œ', danger: 'medium', voice: 'å‰æ–¹æœ‰è¾¦å…¬æ¡Œ' },
          'laptop': { name: 'ç­†è¨˜å‹é›»è…¦', danger: 'medium', voice: 'å‰æ–¹æœ‰é›»è…¦' },
          'mouse': { name: 'æ»‘é¼ ', danger: 'low', voice: 'å‰æ–¹æœ‰æ»‘é¼ ' },
          'keyboard': { name: 'éµç›¤', danger: 'low', voice: 'å‰æ–¹æœ‰éµç›¤' },
          'book': { name: 'æ›¸æœ¬', danger: 'low', voice: 'å‰æ–¹æœ‰æ›¸æœ¬' },
          'cell phone': { name: 'æ‰‹æ©Ÿ', danger: 'low', voice: 'å‰æ–¹æœ‰æ‰‹æ©Ÿ' },
          'bottle': { name: 'æ°´ç“¶', danger: 'low', voice: 'å‰æ–¹æœ‰æ°´ç“¶' },
          'cup': { name: 'æ¯å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¯å­' }
        },
        triggers: ['chair', 'desk', 'laptop']
      }
    };

    /**********************
     * 3) å®‰å…¨é€šé“å°èˆªç³»çµ±
     **********************/
    class SafePathNavigator {
      constructor() {
        this.safePath = [];
        this.isRecording = false;
        this.isNavigating = false;
        this.currentStep = 0;
        this.safeZones = [];
      }

      startRecording() {
        this.safePath = [];
        this.isRecording = true;
        this.isNavigating = false;
        updateVoice('é–‹å§‹è¨˜éŒ„å®‰å…¨é€šé“ï¼Œè«‹åœ¨å®‰å…¨å€åŸŸç§»å‹•');
        document.getElementById('safePathStatus').textContent = 'è¨˜éŒ„ä¸­';
        document.getElementById('safePathBtn').textContent = 'åœæ­¢è¨˜éŒ„';
        document.getElementById('safePathBtn').classList.remove('warning');
        document.getElementById('safePathBtn').classList.add('danger');
      }

      stopRecording() {
        this.isRecording = false;
        if (this.safePath.length > 0) {
          localStorage.setItem('safePath', JSON.stringify(this.safePath));
          updateVoice(`å®‰å…¨é€šé“è¨˜éŒ„å®Œæˆï¼Œå…±${this.safePath.length}å€‹å®‰å…¨é»`);
          document.getElementById('safePathStatus').textContent = 'å·²è¨˜éŒ„';
        } else {
          updateVoice('æœªè¨˜éŒ„åˆ°å®‰å…¨é€šé“');
          document.getElementById('safePathStatus').textContent = 'æœªè¨˜éŒ„';
        }
        document.getElementById('safePathBtn').textContent = 'å®‰å…¨é€šé“å°èˆª';
        document.getElementById('safePathBtn').classList.remove('danger');
        document.getElementById('safePathBtn').classList.add('warning');
      }

      startNavigation() {
        const savedPath = localStorage.getItem('safePath');
        if (!savedPath) {
          updateVoice('è«‹å…ˆè¨˜éŒ„å®‰å…¨é€šé“');
          return;
        }

        this.safePath = JSON.parse(savedPath);
        this.isNavigating = true;
        this.currentStep = 0;
        this.isRecording = false;
        
        updateVoice(`é–‹å§‹å®‰å…¨é€šé“å°èˆªï¼Œå…±${this.safePath.length}å€‹å®‰å…¨é»ï¼Œè«‹è·Ÿéš¨èªéŸ³æŒ‡å¼•`);
        document.getElementById('gpsStatus').textContent = 'å°èˆªä¸­';
        document.getElementById('safePathBtn').textContent = 'å–æ¶ˆå°èˆª';
        document.getElementById('safePathBtn').classList.remove('warning');
        document.getElementById('safePathBtn').classList.add('danger');
        
        this.updateSafePathDisplay();
      }

      stopNavigation() {
        this.isNavigating = false;
        updateVoice('å®‰å…¨é€šé“å°èˆªå·²å–æ¶ˆ');
        document.getElementById('gpsStatus').textContent = 'æœªå•Ÿå‹•';
        document.getElementById('safePathBtn').textContent = 'å®‰å…¨é€šé“å°èˆª';
        document.getElementById('safePathBtn').classList.remove('danger');
        document.getElementById('safePathBtn').classList.add('warning');
        this.clearSafePathDisplay();
      }

      recordSafeZone(videoWidth, videoHeight, predictions) {
        if (!this.isRecording) return;

        // åˆ†æç•¶å‰ç•«é¢ä¸­çš„å®‰å…¨å€åŸŸï¼ˆæ²’æœ‰éšœç¤™ç‰©çš„å€åŸŸï¼‰
        const safeZones = this.analyzeSafeZones(videoWidth, videoHeight, predictions);
        
        if (safeZones.length > 0) {
          // è¨˜éŒ„æœ€å¤§çš„å®‰å…¨å€åŸŸ
          const largestZone = safeZones.reduce((max, zone) => 
            zone.area > max.area ? zone : max
          );
          
          this.safePath.push({
            x: largestZone.x,
            y: largestZone.y,
            width: largestZone.width,
            height: largestZone.height,
            timestamp: Date.now()
          });
          
          // é™åˆ¶è¨˜éŒ„çš„é»æ•¸é‡
          if (this.safePath.length > 50) {
            this.safePath.shift();
          }
          
          this.updateSafePathDisplay();
        }
      }

      analyzeSafeZones(videoWidth, videoHeight, predictions) {
        const safeZones = [];
        const gridSize = 80; // ç¶²æ ¼å¤§å°
        const cols = Math.floor(videoWidth / gridSize);
        const rows = Math.floor(videoHeight / gridSize);
        
        // å»ºç«‹éšœç¤™ç‰©åœ°åœ–
        const obstacleMap = Array(cols * rows).fill(false);
        
        // æ¨™è¨˜æœ‰éšœç¤™ç‰©çš„ç¶²æ ¼
        predictions.forEach(pred => {
          if (pred.score > SCORE_THRESHOLD) {
            const [x, y, w, h] = pred.bbox;
            const startCol = Math.floor(x / gridSize);
            const startRow = Math.floor(y / gridSize);
            const endCol = Math.floor((x + w) / gridSize);
            const endRow = Math.floor((y + h) / gridSize);
            
            for (let row = startRow; row <= endRow; row++) {
              for (let col = startCol; col <= endCol; col++) {
                if (row >= 0 && row < rows && col >= 0 && col < cols) {
                  obstacleMap[row * cols + col] = true;
                }
              }
            }
          }
        });
        
        // å°‹æ‰¾é€£çºŒçš„å®‰å…¨å€åŸŸ
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            if (!obstacleMap[row * cols + col]) {
              // ç°¡å–®çš„å€åŸŸç”Ÿé•·ç®—æ³•
              const zone = this.growSafeZone(obstacleMap, cols, rows, col, row);
              if (zone.area >= 4) { // è‡³å°‘4å€‹ç¶²æ ¼
                safeZones.push({
                  x: zone.minCol * gridSize,
                  y: zone.minRow * gridSize,
                  width: (zone.maxCol - zone.minCol + 1) * gridSize,
                  height: (zone.maxRow - zone.minRow + 1) * gridSize,
                  area: zone.area
                });
              }
            }
          }
        }
        
        return safeZones;
      }

      growSafeZone(obstacleMap, cols, rows, startCol, startRow) {
        const visited = new Set();
        const queue = [[startCol, startRow]];
        let minCol = startCol, maxCol = startCol, minRow = startRow, maxRow = startRow;
        let area = 0;
        
        while (queue.length > 0) {
          const [col, row] = queue.shift();
          const index = row * cols + col;
          
          if (visited.has(index)) continue;
          if (col < 0 || col >= cols || row < 0 || row >= rows) continue;
          if (obstacleMap[index]) continue;
          
          visited.add(index);
          area++;
          
          minCol = Math.min(minCol, col);
          maxCol = Math.max(maxCol, col);
          minRow = Math.min(minRow, row);
          maxRow = Math.max(maxRow, row);
          
          // æª¢æŸ¥ç›¸é„°ç¶²æ ¼
          queue.push([col-1, row], [col+1, row], [col, row-1], [col, row+1]);
        }
        
        return { minCol, maxCol, minRow, maxRow, area };
      }

      updateSafePathDisplay() {
        const container = document.getElementById('safePathContainer');
        container.innerHTML = '';
        
        if (this.isRecording || this.isNavigating) {
          this.safePath.forEach((zone, index) => {
            const safeElement = document.createElement('div');
            safeElement.className = 'safe-path';
            safeElement.style.left = zone.x + 'px';
            safeElement.style.top = zone.y + 'px';
            safeElement.style.width = zone.width + 'px';
            safeElement.style.height = zone.height + 'px';
            safeElement.title = `å®‰å…¨å€åŸŸ ${index + 1}`;
            container.appendChild(safeElement);
          });
        }
      }

      clearSafePathDisplay() {
        const container = document.getElementById('safePathContainer');
        container.innerHTML = '';
      }

      toggleNavigation() {
        if (this.isRecording) {
          this.stopRecording();
        } else if (this.isNavigating) {
          this.stopNavigation();
        } else {
          const savedPath = localStorage.getItem('safePath');
          if (savedPath) {
            this.startNavigation();
          } else {
            this.startRecording();
          }
        }
      }
    }

    /**********************
     * 4) ç‹€æ…‹è®Šæ•¸
     **********************/
    let model = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let currentMode = 'auto';
    let lastTick = 0;
    let frames = 0;
    let lastFpsTs = 0;
    let lastSpeechAt = 0;
    let currentEnvironment = 'auto';
    let safePathNavigator = new SafePathNavigator();
    let environmentHistory = [];
    let falsePositiveFilter = new Set(); // èª¤åˆ¤éæ¿¾å™¨

    /**********************
     * 5) æ™ºèƒ½ç’°å¢ƒåˆ¤æ–·ç³»çµ±
     **********************/
    class EnvironmentAnalyzer {
      constructor() {
        this.indoorScore = 0;
        this.outdoorScore = 0;
        this.lastEnvironment = 'auto';
        this.confidenceThreshold = 3;
      }

      analyze(predictions) {
        let indoorPoints = 0;
        let outdoorPoints = 0;
        
        predictions.forEach(pred => {
          if (pred.score < SCORE_THRESHOLD) return;
          
          Object.keys(environmentModules).forEach(env => {
            if (env === 'auto') return;
            
            if (environmentModules[env].objects[pred.class]) {
              if (env === 'outdoor') {
                outdoorPoints += pred.score * 2;
              } else {
                indoorPoints += pred.score * 2;
              }
            }
          });
        });

        environmentHistory.push({ indoor: indoorPoints, outdoor: outdoorPoints });
        if (environmentHistory.length > 10) {
          environmentHistory.shift();
        }

        const avgIndoor = environmentHistory.reduce((sum, item) => sum + item.indoor, 0) / environmentHistory.length;
        const avgOutdoor = environmentHistory.reduce((sum, item) => sum + item.outdoor, 0) / environmentHistory.length;

        let detectedEnvironment = 'auto';
        
        if (avgIndoor > avgOutdoor + this.confidenceThreshold) {
          detectedEnvironment = 'indoor';
        } else if (avgOutdoor > avgIndoor + this.confidenceThreshold) {
          detectedEnvironment = 'outdoor';
        }

        if (detectedEnvironment !== this.lastEnvironment && environmentHistory.length >= 5) {
          this.lastEnvironment = detectedEnvironment;
          updateEnvironmentDisplay(detectedEnvironment);
        }

        return detectedEnvironment;
      }
    }

    const environmentAnalyzer = new EnvironmentAnalyzer();

    function updateEnvironmentDisplay(environment) {
      const moduleElement = document.getElementById('currentModule');
      const tagElement = document.getElementById('activeModuleTag');
      
      let displayName = 'è‡ªå‹•';
      let indicatorClass = 'auto-indicator';
      
      if (environment === 'indoor') {
        displayName = 'å®¤å…§';
        indicatorClass = 'indoor-indicator';
      } else if (environment === 'outdoor') {
        displayName = 'å®¤å¤–';
        indicatorClass = 'outdoor-indicator';
      }
      
      moduleElement.innerHTML = `<span class="environment-indicator ${indicatorClass}"></span>${displayName}`;
      tagElement.textContent = displayName + 'æ¨¡å¼';
      
      if (environment !== 'auto') {
        updateVoice(`æª¢æ¸¬åˆ°${displayName}ç’°å¢ƒï¼Œå·²è‡ªå‹•åˆ‡æ›æ¨¡å¼`);
      }
    }

    /**********************
     * 6) æ¨¡å‹è¼‰å…¥ - TensorFlow.js COCO-SSD
     **********************/
    async function initModel() {
      try {
        updateVoice('æ­£åœ¨è¼‰å…¥ TensorFlow.js COCO-SSD æ¨¡å‹â€¦');
        
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        progressContainer.style.display = 'block';
        progressBar.style.width = '30%';
        
        progressBar.style.width = '60%';
        updateVoice('è¼‰å…¥ COCO-SSD æ¨¡å‹ä¸­...');
        
        model = await cocoSsd.load();
        
        progressBar.style.width = '100%';
        progressBar.style.background = 'var(--good)';
        
        initEventListeners();
        updateVoice('COCO-SSD æ¨¡å‹è¼‰å…¥æˆåŠŸï¼ç³»çµ±æº–å‚™å®Œæˆï¼Œè«‹é»æ“Šé–‹å§‹æª¢æ¸¬');
        updateStatus('æº–å‚™å°±ç·’');
        
        setTimeout(() => {
          progressContainer.style.display = 'none';
        }, 1000);
        
      } catch (e) {
        console.error('æ¨¡å‹è¼‰å…¥éŒ¯èª¤:', e);
        updateVoice('æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹åˆ·æ–°é é¢é‡è©¦');
        document.getElementById('progressContainer').style.display = 'none';
      }
    }

    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnMode').addEventListener('click', toggleMode);
      document.getElementById('btnSetHome').addEventListener('click', setSafeStart);
      document.getElementById('btnReturnHome').addEventListener('click', () => safePathNavigator.toggleNavigation());
      document.getElementById('btnLoadModule').addEventListener('click', loadEnvironmentModule);
      document.getElementById('btnEmergency').addEventListener('click', emergencyAlert);
    }

    function setSafeStart() {
      updateVoice('å®‰å…¨èµ·é»å·²è¨­å®šï¼Œç¾åœ¨å¯ä»¥é–‹å§‹è¨˜éŒ„å®‰å…¨é€šé“');
      localStorage.removeItem('safePath'); // æ¸…é™¤èˆŠçš„å®‰å…¨é€šé“
      safePathNavigator.startRecording();
    }

    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment', 
            width: { ideal: 640 },
            height: { ideal: 480 } 
          }, 
          audio: false 
        });
        video.srcObject = stream; 
        await new Promise((resolve) => {
          video.onloadedmetadata = () => { resolve(video); };
        }); 
        await video.play();
        return video;
      } catch (e) { 
        console.error('ç›¸æ©ŸéŒ¯èª¤:', e); 
        updateVoice('ç„¡æ³•å­˜å–ç›¸æ©Ÿï¼Œè«‹ç¢ºèªæ¬Šé™'); 
        return null; 
      }
    }

    /**********************
     * 7) ä¸»æµç¨‹ï¼ˆä½¿ç”¨ COCO-SSD æª¢æ¸¬ï¼‰
     **********************/
    async function startDetection() {
      if (!model) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆï¼Œè«‹ç¨å€™');
        return;
      }
      
      const video = await setupCamera(); 
      if (!video) return;
      
      isDetecting = true; 
      updateStatus('æª¢æ¸¬ä¸­'); 
      updateVoice('é–‹å§‹éšœç¤™ç‰©æª¢æ¸¬ï¼Œæ™ºèƒ½ç’°å¢ƒè­˜åˆ¥å·²å•Ÿå‹•â€¦');
      
      requestAnimationFrame((ts) => loop(video, ts));
    }

    function stopDetection() {
      isDetecting = false; 
      updateStatus('å·²åœæ­¢');
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      updateVoice('æª¢æ¸¬å·²åœæ­¢');
      safePathNavigator.stopNavigation();
    }

    async function loop(video, ts = 0) {
      if (!isDetecting) return;
      
      if (ts - lastTick >= INTERVAL) {
        try {
          const predictions = await model.detect(video);
          
          // éæ¿¾èª¤åˆ¤
          const filteredPredictions = filterFalsePositives(predictions);
          
          const detectedEnvironment = environmentAnalyzer.analyze(filteredPredictions);
          
          // è¨˜éŒ„å®‰å…¨é€šé“
          safePathNavigator.recordSafeZone(video.videoWidth, video.videoHeight, filteredPredictions);
          
          processPredictions(filteredPredictions, video.videoWidth, detectedEnvironment);
          draw(filteredPredictions, video.videoWidth, video.videoHeight);

          frames++; 
          if (!lastFpsTs) {
            lastFpsTs = ts;
          } else if (ts - lastFpsTs >= 1000) {
            document.getElementById('fps').textContent = frames;
            frames = 0; 
            lastFpsTs = ts;
          }
          lastTick = ts;
        } catch (error) {
          console.error('æª¢æ¸¬å¾ªç’°éŒ¯èª¤:', error);
        }
      }
      requestAnimationFrame((n) => loop(video, n));
    }

    /**********************
     * 8) èª¤åˆ¤éæ¿¾ç³»çµ±
     **********************/
    function filterFalsePositives(predictions) {
      return predictions.filter(pred => {
        // éæ¿¾ä½ç½®ä¿¡åº¦çš„æª¢æ¸¬
        if (pred.score < SCORE_THRESHOLD) return false;
        
        // éæ¿¾ç‰¹å®šé¡åˆ¥çš„èª¤åˆ¤
        if (pred.class === 'person') {
          // å°è¡Œäººæª¢æ¸¬é€²è¡Œé¡å¤–é©—è­‰
          const [x, y, w, h] = pred.bbox;
          const aspectRatio = w / h;
          // è¡Œäººçš„å¯¬é«˜æ¯”é€šå¸¸åœ¨0.3-0.7ä¹‹é–“
          if (aspectRatio < 0.3 || aspectRatio > 0.7) return false;
        }
        
        return true;
      });
    }

    /**********************
     * 9) é æ¸¬è™•ç†èˆ‡ç¹ªåœ–
     **********************/
    function processPredictions(predictions, frameW, detectedEnvironment) {
      let activeModules = [];
      if (detectedEnvironment === 'auto') {
        activeModules = Object.keys(environmentModules).filter(env => env !== 'auto');
      } else {
        activeModules = [detectedEnvironment];
      }
      
      const relevantPredictions = predictions.filter(p => {
        if (p.score < SCORE_THRESHOLD) return false;
        return activeModules.some(env => environmentModules[env].objects[p.class]);
      }).map(pred => {
        const distance = estimateDistance(pred.bbox[2], pred.bbox[3], pred.class);
        return {
          ...pred,
          distance: distance
        };
      });
      
      document.getElementById('obstacleCount').textContent = relevantPredictions.length;
      
      let closestDistance = Infinity;
      let closestObject = null;
      
      relevantPredictions.forEach(pred => {
        if (pred.distance < closestDistance) {
          closestDistance = pred.distance;
          closestObject = pred;
        }
      });
      
      const distanceElement = document.getElementById('closestDistance');
      if (closestObject) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' å…¬å°º';
        
        if (closestDistance < 2) {
          distanceElement.parentElement.classList.add('danger-warning');
        } else if (closestDistance < 5) {
          distanceElement.parentElement.classList.add('obstacle-warning');
        } else {
          distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
        }
        
        if (voiceEnabled) {
          const now = Date.now();
          const cooldown = closestObject.distance < 3 ? 3000 : 5000;
          
          if (now - lastSpeechAt > cooldown) {
            let objConfig = null;
            for (const env of activeModules) {
              if (environmentModules[env].objects[closestObject.class]) {
                objConfig = environmentModules[env].objects[closestObject.class];
                break;
              }
            }
            
            if (objConfig) {
              let voiceMsg = objConfig.voice;
              
              if (closestObject.distance < 2) {
                voiceMsg = `ç·Šæ€¥ï¼${objConfig.name}éå¸¸æ¥è¿‘ï¼Œåƒ…${closestObject.distance.toFixed(1)}å…¬å°º`;
              } else if (closestObject.distance < 5) {
                voiceMsg = `æ³¨æ„ï¼${objConfig.name}æ¥è¿‘ï¼Œè·é›¢${closestObject.distance.toFixed(1)}å…¬å°º`;
              }
              
              updateVoice(voiceMsg);
              lastSpeechAt = now;
            }
          }
        }
      } else {
        distanceElement.textContent = 'â€” å…¬å°º';
        distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
      }
      
      updateDetectionList(relevantPredictions, activeModules);
    }

    function estimateDistance(width, height, className) {
      const pixelArea = width * height;
      
      const referenceSizes = {
        'person': 8000,
        'car': 40000,
        'bicycle': 12000,
        'chair': 6000,
        'bed': 15000,
        'couch': 20000,
        'dining table': 25000,
        'tv': 8000,
        'laptop': 3000,
        'bottle': 1500,
        'cup': 1000,
        'book': 2000,
        'vase': 2000
      };
      
      const refSize = referenceSizes[className] || 8000;
      const distance = Math.sqrt(refSize / pixelArea) * 8;
      
      return Math.min(distance, 50);
    }

    function updateDetectionList(predictions, activeModules) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="chip" style="text-align:center; color:var(--muted);">æœªåµæ¸¬åˆ°éšœç¤™ç‰©</div>';
        return;
      }
      
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        let objConfig = null;
        for (const env of activeModules) {
          if (environmentModules[env].objects[pred.class]) {
            objConfig = environmentModules[env].objects[pred.class];
            break;
          }
        }
        
        const dangerLevel = objConfig ? objConfig.danger : 'low';
        const dangerColors = {
          'high': 'var(--bad)',
          'medium': 'var(--warn)', 
          'low': 'var(--good)'
        };
        
        const displayName = objConfig ? objConfig.name : pred.class;
        
        return `
          <div class="chip" style="border-left: 4px solid ${dangerColors[dangerLevel]}">
            <strong>${displayName}</strong><br>
            è·é›¢: ${pred.distance.toFixed(1)}å…¬å°º | ç½®ä¿¡åº¦: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    function draw(predictions, width, height) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      if (!width || !height) return;
      
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      predictions.forEach(pred => {
        if (pred.score < SCORE_THRESHOLD) return;
        
        const [x, y, w, h] = pred.bbox;
        
        let objConfig = null;
        for (const env in environmentModules) {
          if (env !== 'auto' && environmentModules[env].objects[pred.class]) {
            objConfig = environmentModules[env].objects[pred.class];
            break;
          }
        }
        
        if (!objConfig) return;
        
        let color;
        switch(objConfig.danger) {
          case 'high': color = '#ef4444'; break;
          case 'medium': color = '#f59e0b'; break;
          default: color = '#22c55e';
        }
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        const label = `${objConfig.name} ${pred.distance.toFixed(1)}m`;
        ctx.font = '16px Arial';
        const textWidth = ctx.measureText(label).width;
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y - 25, textWidth + 10, 25);
        
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 5, y - 7);
      });
    }

    /**********************
     * 10) å·¥å…·å‡½æ•¸
     **********************/
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateGPSStatus(status) {
      document.getElementById('gpsStatus').textContent = status;
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const status = document.getElementById('voiceStatus');
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        status.textContent = 'é–‹å•Ÿ';
        button.textContent = 'èªéŸ³é—œé–‰';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('èªéŸ³æç¤ºå·²é–‹å•Ÿ');
      } else {
        status.textContent = 'é—œé–‰';
        button.textContent = 'èªéŸ³é–‹å•Ÿ';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleMode() {
      const button = document.getElementById('btnMode');
      currentMode = currentMode === 'auto' ? 'manual' : 'auto';
      
      if (currentMode === 'auto') {
        button.textContent = 'æ‰‹å‹•æ¨¡å¼';
        updateVoice('åˆ‡æ›åˆ°æ™ºèƒ½æ¨¡å¼ï¼Œè‡ªå‹•åˆ¤æ–·ç’°å¢ƒ');
        environmentHistory = [];
      } else {
        button.textContent = 'æ™ºèƒ½æ¨¡å¼';
        updateVoice('åˆ‡æ›åˆ°æ‰‹å‹•æ¨¡å¼');
      }
    }

    function loadEnvironmentModule() {
      const environments = Object.keys(environmentModules).filter(env => env !== 'auto');
      const currentIndex = environments.indexOf(currentEnvironment);
      const nextIndex = (currentIndex + 1) % environments.length;
      currentEnvironment = environments[nextIndex];
      
      const module = environmentModules[currentEnvironment];
      document.getElementById('currentModule').textContent = module.name;
      document.getElementById('activeModuleTag').textContent = module.name;
      
      updateVoice(`æ‰‹å‹•åˆ‡æ›åˆ°${module.name}`);
    }

    function emergencyAlert() {
      const button = document.getElementById('btnEmergency');
      button.classList.add('emergency-alert');
      
      updateVoice('ç·Šæ€¥æ±‚åŠ©ï¼æ­£åœ¨ç™¼é€ä½ç½®è³‡è¨Šçµ¦ç·Šæ€¥è¯çµ¡äºº');
      
      setTimeout(() => {
        button.classList.remove('emergency-alert');
      }, 5000);
    }

    /**********************
     * 11) åˆå§‹åŒ–æ‡‰ç”¨
     **********************/
    window.addEventListener('DOMContentLoaded', () => {
      updateStatus('åˆå§‹åŒ–ä¸­');
      updateVoice('ç›²äººè¼”åŠ©å°èˆªç³»çµ±å•Ÿå‹•ä¸­...');
      
      initModel();
    });

    let wakeLock = null;
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
        }
      } catch (err) {
        console.log('Wake Lock å¤±æ•—:', err.message);
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && isDetecting) {
        await requestWakeLock();
      }
    });

    requestWakeLock();
  </script>
</body>
</html>