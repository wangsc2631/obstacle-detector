<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="盲人輔助導航系統 - 即時障礙物檢測" />
  <title>🧭 盲人輔助導航系統</title>
  
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🧭</text></svg>">
  
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js"></script>
  
  <style>
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    .camera-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera-container video, .camera-container canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    
    .camera-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 16px;
      z-index: 5;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    button {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .btn-primary {
      background: var(--good);
      color: #fff;
    }
    
    .btn-danger {
      background: var(--bad);
      color: #fff;
    }
    
    .btn-secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-value {
      font-weight: 800;
      font-size: 16px;
    }
    
    .voice-alert {
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      margin-bottom: 15px;
    }
    
    .detection-list {
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .detection-item {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
    }
    
    .debug-info {
      background: rgba(0,0,0,0.8);
      color: #00ff00;
      padding: 8px;
      border-radius: 5px;
      font-size: 12px;
      margin-top: 8px;
      font-family: monospace;
      display: none;
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- 標題 -->
    <div class="card">
      <h1 style="margin:0; text-align:center;">🧭 盲人輔助導航</h1>
    </div>

    <!-- 相機畫面 -->
    <div class="card">
      <div class="camera-container">
        <div id="cameraPreview" class="camera-preview">
          點擊「開啟相機」開始使用
        </div>
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
      </div>
    </div>

    <!-- 控制面板 -->
    <div class="card">
      <div id="voiceAlert" class="voice-alert">系統準備中…</div>
      
      <div class="controls">
        <button id="btnCamera" class="btn-primary">開啟相機</button>
        <button id="btnStart" class="btn-primary" disabled>開始檢測</button>
        <button id="btnTest" class="btn-secondary" disabled>測試檢測</button>
        <button id="btnStop" class="btn-danger">停止</button>
      </div>

      <div class="status-grid">
        <div class="status-item">
          <div class="status-label">系統狀態</div>
          <div class="status-value" id="status">準備中</div>
        </div>
        <div class="status-item">
          <div class="status-label">模型狀態</div>
          <div class="status-value" id="modelStatus">載入中</div>
        </div>
        <div class="status-item">
          <div class="status-label">相機狀態</div>
          <div class="status-value" id="cameraStatus">未開啟</div>
        </div>
        <div class="status-item">
          <div class="status-label">檢測狀態</div>
          <div class="status-value" id="detectionStatus">未開始</div>
        </div>
      </div>

      <div id="debugInfo" class="debug-info"></div>
    </div>

    <!-- 檢測結果 -->
    <div class="card">
      <h3 style="margin:0 0 12px 0;">即時偵測結果</h3>
      <div id="detectionList" class="detection-list">
        <div class="detection-item" style="text-align:center; color:var(--muted);">
          等待開始偵測…
        </div>
      </div>
    </div>
  </div>

  <script>
    // 簡單的模型配置
    const MODEL_URL = 'https://cdn.jsdelivr.net/gh/ultralytics/assets@main/yolov8n.onnx';
    const INPUT_SIZE = 640;
    
    // COCO 類別名稱
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
      'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
      'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
      'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
      'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
      'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
      'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair',
      'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse',
      'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator',
      'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    // 狀態變數
    let session = null;
    let isDetecting = false;
    let currentStream = null;
    let detectionInterval = null;

    // 初始化
    async function init() {
      try {
        updateStatus('載入模型中');
        updateVoice('正在載入 AI 模型…');
        
        // 載入 ONNX 模型
        session = await ort.InferenceSession.create(MODEL_URL, {
          executionProviders: ['wasm']
        });
        
        console.log('✅ 模型載入成功');
        console.log('輸入:', session.inputNames);
        console.log('輸出:', session.outputNames);
        
        updateModelStatus('載入成功');
        updateStatus('準備就緒');
        updateVoice('AI 模型載入成功！請開啟相機開始使用');
        
        initEventListeners();
        
      } catch (error) {
        console.error('❌ 模型載入失敗:', error);
        updateModelStatus('載入失敗');
        updateVoice('模型載入失敗，請檢查網路連接');
      }
    }

    function initEventListeners() {
      document.getElementById('btnCamera').addEventListener('click', setupCamera);
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnTest').addEventListener('click', testDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
    }

    // 相機設置
    async function setupCamera() {
      try {
        updateVoice('正在開啟相機…');
        updateCameraStatus('開啟中');
        
        // 停止之前的串流
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }
        
        const video = document.getElementById('video');
        const preview = document.getElementById('cameraPreview');
        
        // 請求相機權限
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: 'environment'
          },
          audio: false
        });
        
        currentStream = stream;
        video.srcObject = stream;
        
        // 等待影片載入
        await new Promise((resolve) => {
          video.onloadedmetadata = () => resolve(video);
        });
        
        await video.play();
        
        // 隱藏預覽畫面
        preview.style.display = 'none';
        
        // 啟用按鈕
        document.getElementById('btnStart').disabled = false;
        document.getElementById('btnTest').disabled = false;
        
        updateCameraStatus('已開啟');
        updateVoice('相機開啟成功！可以開始檢測');
        
        console.log('🎥 相機開啟成功');
        
      } catch (error) {
        console.error('❌ 相機開啟失敗:', error);
        updateCameraStatus('開啟失敗');
        updateVoice('無法開啟相機，請檢查權限設定');
      }
    }

    // 開始檢測
    function startDetection() {
      if (!session) {
        updateVoice('模型尚未載入');
        return;
      }
      
      const video = document.getElementById('video');
      if (!video.srcObject) {
        updateVoice('請先開啟相機');
        return;
      }
      
      isDetecting = true;
      updateStatus('檢測中');
      updateDetectionStatus('運行中');
      updateVoice('開始障礙物檢測');
      
      // 開始檢測循環
      detectionInterval = setInterval(async () => {
        if (!isDetecting) return;
        
        try {
          const predictions = await detectObjects(video);
          updateDetectionDisplay(predictions);
        } catch (error) {
          console.error('檢測錯誤:', error);
        }
      }, 1000); // 每秒檢測一次
    }

    // 測試檢測
    async function testDetection() {
      if (!session) {
        updateVoice('模型尚未載入');
        return;
      }
      
      const video = document.getElementById('video');
      if (!video.srcObject) {
        updateVoice('請先開啟相機');
        return;
      }
      
      updateVoice('執行測試檢測');
      
      try {
        const predictions = await detectObjects(video);
        if (predictions.length > 0) {
          updateVoice(`測試成功！檢測到 ${predictions.length} 個物體`);
        } else {
          updateVoice('測試完成，未檢測到物體');
        }
        updateDetectionDisplay(predictions);
      } catch (error) {
        console.error('測試檢測錯誤:', error);
        updateVoice('檢測測試失敗');
      }
    }

    // 停止檢測
    function stopDetection() {
      isDetecting = false;
      if (detectionInterval) {
        clearInterval(detectionInterval);
      }
      updateStatus('已停止');
      updateDetectionStatus('已停止');
      updateVoice('檢測已停止');
      clearDetectionDisplay();
    }

    // 物件檢測主函數
    async function detectObjects(video) {
      try {
        // 1. 擷取畫面
        const imageData = captureFrame(video);
        
        // 2. 預處理
        const inputTensor = preprocess(imageData);
        
        // 3. 模型推理
        const feeds = { [session.inputNames[0]]: inputTensor };
        const results = await session.run(feeds);
        
        // 4. 後處理
        const predictions = postprocess(results, video.videoWidth, video.videoHeight);
        
        console.log(`檢測到 ${predictions.length} 個物體:`, predictions);
        return predictions;
        
      } catch (error) {
        console.error('檢測過程錯誤:', error);
        return [];
      }
    }

    // 擷取畫面
    function captureFrame(video) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = INPUT_SIZE;
      canvas.height = INPUT_SIZE;
      
      // 繪製影片畫面到 canvas
      ctx.drawImage(video, 0, 0, INPUT_SIZE, INPUT_SIZE);
      
      return ctx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
    }

    // 預處理
    function preprocess(imageData) {
      const { data } = imageData;
      const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
      
      // 簡單的 RGB 歸一化
      for (let i = 0; i < data.length; i += 4) {
        const pixelIndex = Math.floor(i / 4);
        input[pixelIndex] = data[i] / 255.0;         // R
        input[INPUT_SIZE * INPUT_SIZE + pixelIndex] = data[i + 1] / 255.0; // G
        input[2 * INPUT_SIZE * INPUT_SIZE + pixelIndex] = data[i + 2] / 255.0; // B
      }
      
      return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
    }

    // 後處理
    function postprocess(results, frameWidth, frameHeight) {
      const output = results[session.outputNames[0]];
      const outputData = output.data;
      const predictions = [];
      
      // YOLOv8 輸出格式: [1, 84, 8400]
      const numBoxes = output.dims[2]; // 8400
      const numClasses = output.dims[1] - 4; // 84 - 4 = 80
      
      for (let i = 0; i < numBoxes; i++) {
        const offset = i * output.dims[1];
        
        // 獲取邊界框資訊
        const x = outputData[offset];
        const y = outputData[offset + 1];
        const w = outputData[offset + 2];
        const h = outputData[offset + 3];
        
        // 獲取類別分數
        let maxScore = 0;
        let classId = -1;
        
        for (let j = 0; j < numClasses; j++) {
          const score = outputData[offset + 4 + j];
          if (score > maxScore) {
            maxScore = score;
            classId = j;
          }
        }
        
        // 過濾低分數檢測
        if (maxScore < 0.25 || classId === -1) continue;
        
        // 轉換為像素坐標
        const x1 = (x - w / 2) * frameWidth;
        const y1 = (y - h / 2) * frameHeight;
        const width = w * frameWidth;
        const height = h * frameHeight;
        
        // 估算距離
        const distance = estimateDistance(width, height, classId);
        
        predictions.push({
          class: CLASS_NAMES[classId],
          score: maxScore,
          bbox: [x1, y1, width, height],
          distance: distance
        });
      }
      
      return predictions;
    }

    // 估算距離
    function estimateDistance(width, height, classId) {
      const area = width * height;
      const referenceAreas = {
        'person': 15000,
        'car': 80000,
        'chair': 12000,
        'bottle': 3000
      };
      
      const className = CLASS_NAMES[classId];
      const refArea = referenceAreas[className] || 20000;
      
      return Math.sqrt(refArea / area) * 2;
    }

    // 更新檢測顯示
    function updateDetectionDisplay(predictions) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="detection-item" style="text-align:center; color:var(--muted);">未偵測到障礙物</div>';
        return;
      }
      
      // 按距離排序
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => `
        <div class="detection-item">
          <strong>${pred.class}</strong><br>
          距離: ${pred.distance.toFixed(1)}公尺 | 置信度: ${(pred.score * 100).toFixed(0)}%
        </div>
      `).join('');
      
      // 語音提示最近的物體
      const closest = predictions[0];
      if (closest.distance < 2) {
        updateVoice(`警告！${closest.class}非常接近，僅${closest.distance.toFixed(1)}公尺`);
      }
    }

    function clearDetectionDisplay() {
      const list = document.getElementById('detectionList');
      list.innerHTML = '<div class="detection-item" style="text-align:center; color:var(--muted);">檢測已停止</div>';
    }

    // 工具函數
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateModelStatus(status) {
      document.getElementById('modelStatus').textContent = status;
    }

    function updateCameraStatus(status) {
      document.getElementById('cameraStatus').textContent = status;
    }

    function updateDetectionStatus(status) {
      document.getElementById('detectionStatus').textContent = status;
    }

    // 啟動應用
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>