<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="盲人輔助導航系統 - 即時障礙物檢測與GPS返航" />
  <title>🧭 盲人輔助導航系統</title>
  
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    /* 完整 CSS 樣式 */
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    header.card {
      padding: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: 20px;
      margin: 0;
      font-weight: 700;
    }
    
    .tips {
      font-size: 12px;
      color: var(--muted);
    }
    
    .camera-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera-container video, 
    .camera-container canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
      font-family: inherit;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .btn.primary {
      background: var(--good);
      color: #fff;
    }
    
    .btn.warning {
      background: var(--warn);
      color: #fff;
    }
    
    .btn.danger {
      background: var(--bad);
      color: #fff;
    }
    
    .btn.secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .value {
      font-weight: 800;
      font-size: 16px;
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .detection-list {
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding-right: 4px;
    }
    
    .detection-chip {
      background: var(--glass-strong);
      padding: 12px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
      border-left: 4px solid var(--good);
    }
    
    .detection-chip.warning {
      border-left-color: var(--warn);
    }
    
    .detection-chip.danger {
      border-left-color: var(--bad);
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .debug-panel {
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
      display: none;
    }
    
    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--glass-strong);
      border-radius: 3px;
      margin: 10px 0;
      overflow: hidden;
      display: none;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--good);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }

    /* 響應式設計 */
    @media (min-width: 768px) {
      .app {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-areas: 
          "header header"
          "camera sidebar"
          "controls sidebar"
          "status sidebar";
        gap: 12px;
      }
      
      header.card { grid-area: header; }
      .camera-container { grid-area: camera; }
      .panel:first-of-type { grid-area: controls; }
      .panel:last-of-type { grid-area: sidebar; }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- 標題區 -->
    <header class="card">
      <h1>🧭 盲人輔助導航系統</h1>
      <div class="tips">安全出行 · 障礙檢測 · 語音導航</div>
    </header>

    <!-- 相機區 -->
    <section class="card camera-container">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
    </section>

    <!-- 控制區 -->
    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">系統初始化中…</div>
      
      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      
      <div class="controls">
        <button id="btnStart" class="btn primary">開始檢測</button>
        <button id="btnStop" class="btn danger" disabled>停止檢測</button>
        <button id="btnVoice" class="btn secondary">語音開啟</button>
        <button id="btnDebug" class="btn warning">顯示除錯</button>
      </div>

      <div class="status-grid">
        <div class="status-item">
          <div class="label">系統狀態</div>
          <div class="value" id="status">準備中</div>
        </div>
        <div class="status-item">
          <div class="label">偵測速度</div>
          <div class="value" id="fps">—</div>
        </div>
        <div class="status-item">
          <div class="label">障礙物數</div>
          <div class="value" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="label">最近距離</div>
          <div class="value" id="closestDistance">— 公尺</div>
        </div>
      </div>

      <div id="debugPanel" class="debug-panel">
        <div><strong>除錯資訊:</strong></div>
        <div id="debugInfo">等待開始偵測...</div>
      </div>
    </section>

    <!-- 側邊欄 -->
    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">即時偵測結果</h3>
      <div id="detectionList" class="detection-list">
        <div class="detection-chip" style="text-align:center; color:var(--muted);">
          等待開始偵測…
        </div>
      </div>
      <footer>
        專為視障朋友設計 · 安全出行伴侶<br>
        請在光線充足環境使用
      </footer>
    </aside>
  </div>

  <script>
    // 配置參數
    const CONFIG = {
      modelUrl: 'https://raw.githubusercontent.com/ultralytics/assets/main/yolov8n.onnx',
      inputSize: 640,
      scoreThreshold: 0.3,
      iouThreshold: 0.5,
      targetFPS: 8
    };

    // COCO 類別名稱
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light',
      'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
      'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee',
      'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle',
      'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange',
      'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed',
      'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven',
      'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    // 重要障礙物類別
    const IMPORTANT_CLASSES = [
      'person', 'car', 'motorcycle', 'bus', 'truck', 'bicycle', 
      'chair', 'bench', 'bed', 'couch', 'table'
    ];

    // 全局變數
    let session = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let debugMode = false;
    let frameCount = 0;
    let lastFpsTime = 0;

    // 初始化模型
    async function initModel() {
      try {
        showProgress('正在載入 AI 模型...', 0);
        
        ort.env.wasm.numThreads = 1;
        
        showProgress('下載模型中...', 30);
        updateDebugInfo('開始載入 YOLOv8 模型...');
        
        // 使用更可靠的模型來源
        session = await ort.InferenceSession.create(CONFIG.modelUrl, {
          executionProviders: ['wasm']
        });
        
        showProgress('模型初始化完成', 100);
        updateDebugInfo(`模型載入成功！輸入: ${session.inputNames[0]}`);
        updateVoice('模型載入完成！請點擊開始檢測');
        updateStatus('準備就緒');
        
        setTimeout(() => {
          hideProgress();
        }, 1000);
        
      } catch (error) {
        console.error('模型載入失敗:', error);
        updateDebugInfo(`錯誤: ${error.message}`);
        updateVoice('模型載入失敗，請檢查網路連接');
        hideProgress();
      }
    }

    // 設定相機
    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        updateDebugInfo('請求相機權限...');
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        });
        
        video.srcObject = stream;
        
        return new Promise((resolve, reject) => {
          video.onloadedmetadata = () => {
            video.play().then(() => {
              updateDebugInfo(`相機就緒: ${video.videoWidth}x${video.videoHeight}`);
              resolve(video);
            }).catch(reject);
          };
          video.onerror = reject;
        });
      } catch (error) {
        console.error('相機錯誤:', error);
        updateDebugInfo(`相機錯誤: ${error.message}`);
        updateVoice('無法存取相機，請確認權限設定');
        return null;
      }
    }

    // 開始檢測
    async function startDetection() {
      if (!session) {
        updateVoice('模型尚未載入完成');
        return;
      }

      updateDebugInfo('開始設定相機...');
      const video = await setupCamera();
      if (!video) return;

      // 啟用按鈕狀態
      document.getElementById('btnStart').disabled = true;
      document.getElementById('btnStop').disabled = false;

      isDetecting = true;
      updateStatus('檢測中');
      updateVoice('開始障礙物檢測，請緩慢移動裝置');

      // 開始檢測循環
      detectionLoop(video);
    }

    // 停止檢測
    function stopDetection() {
      isDetecting = false;
      updateStatus('已停止');
      
      // 恢復按鈕狀態
      document.getElementById('btnStart').disabled = false;
      document.getElementById('btnStop').disabled = true;
      
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
        video.srcObject = null;
      }
      
      updateVoice('檢測已停止');
      updateDebugInfo('檢測已停止');
    }

    // 主檢測循環
    async function detectionLoop(video) {
      if (!isDetecting) return;

      const startTime = performance.now();

      try {
        // 1. 捕捉畫面
        const imageData = captureFrame(video);
        if (!imageData) {
          setTimeout(() => detectionLoop(video), 1000 / CONFIG.targetFPS);
          return;
        }

        // 2. 預處理
        const inputTensor = preprocess(imageData);
        
        // 3. 推理
        const feeds = { [session.inputNames[0]]: inputTensor };
        const results = await session.run(feeds);
        
        // 4. 後處理
        const predictions = postprocess(results, video.videoWidth, video.videoHeight);
        
        // 5. 處理結果
        processPredictions(predictions);
        
        // 6. 繪製結果
        drawPredictions(predictions, video);
        
        // 更新 FPS
        updateFPS(performance.now() - startTime);

      } catch (error) {
        console.error('檢測錯誤:', error);
        updateDebugInfo(`檢測錯誤: ${error.message}`);
      }

      // 繼續下一幀
      if (isDetecting) {
        setTimeout(() => detectionLoop(video), 1000 / CONFIG.targetFPS);
      }
    }

    // 捕捉畫面
    function captureFrame(video) {
      if (!video.videoWidth || !video.videoHeight) {
        return null;
      }

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      // 正常繪製，不翻轉
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    // 預處理
    function preprocess(imageData) {
      const { data, width, height } = imageData;
      const input = new Float32Array(3 * CONFIG.inputSize * CONFIG.inputSize);
      
      const scale = Math.min(CONFIG.inputSize / width, CONFIG.inputSize / height);
      const scaledWidth = Math.floor(width * scale);
      const scaledHeight = Math.floor(height * scale);
      const xOffset = Math.floor((CONFIG.inputSize - scaledWidth) / 2);
      const yOffset = Math.floor((CONFIG.inputSize - scaledHeight) / 2);
      
      // 填充黑色背景
      for (let i = 0; i < input.length; i++) {
        input[i] = 0.0;
      }
      
      // 填充影像數據
      for (let c = 0; c < 3; c++) {
        for (let h = 0; h < scaledHeight; h++) {
          for (let w = 0; w < scaledWidth; w++) {
            const srcX = Math.floor(w / scale);
            const srcY = Math.floor(h / scale);
            const srcIndex = (srcY * width + srcX) * 4;
            
            const pixelValue = data[srcIndex + c] / 255.0;
            const dstIndex = c * CONFIG.inputSize * CONFIG.inputSize + 
                            (h + yOffset) * CONFIG.inputSize + 
                            (w + xOffset);
            input[dstIndex] = pixelValue;
          }
        }
      }
      
      return new ort.Tensor('float32', input, [1, 3, CONFIG.inputSize, CONFIG.inputSize]);
    }

    // 後處理
    function postprocess(results, originalWidth, originalHeight) {
      const predictions = [];
      const output = results[session.outputNames[0]];
      
      if (!output || !output.data) {
        return predictions;
      }

      const outputData = output.data;
      const numDetections = output.dims[1];
      const numClasses = output.dims[2] - 4;

      for (let i = 0; i < numDetections; i++) {
        const offset = i * (numClasses + 4);
        const [x, y, w, h, ...scores] = Array.from(outputData.slice(offset, offset + numClasses + 4));
        
        const maxScore = Math.max(...scores);
        const classId = scores.indexOf(maxScore);

        if (maxScore > CONFIG.scoreThreshold && classId < CLASS_NAMES.length) {
          // 轉換座標回原圖尺寸
          const scale = Math.min(CONFIG.inputSize / originalWidth, CONFIG.inputSize / originalHeight);
          const scaledWidth = originalWidth * scale;
          const scaledHeight = originalHeight * scale;
          const xOffset = (CONFIG.inputSize - scaledWidth) / 2;
          const yOffset = (CONFIG.inputSize - scaledHeight) / 2;
          
          const bbox = [
            (x - xOffset - w/2) / scale,
            (y - yOffset - h/2) / scale,
            w / scale,
            h / scale
          ];

          // 確保座標在合理範圍內
          if (bbox[0] >= 0 && bbox[1] >= 0 && bbox[2] > 10 && bbox[3] > 10) {
            predictions.push({
              class: CLASS_NAMES[classId],
              score: maxScore,
              bbox: bbox,
              distance: estimateDistance(bbox[2], bbox[3], CLASS_NAMES[classId])
            });
          }
        }
      }

      return nonMaxSuppression(predictions, CONFIG.iouThreshold);
    }

    // 非極大值抑制
    function nonMaxSuppression(predictions, iouThreshold) {
      if (predictions.length === 0) return predictions;
      
      predictions.sort((a, b) => b.score - a.score);
      const selected = [];

      while (predictions.length > 0) {
        const current = predictions[0];
        selected.push(current);

        predictions = predictions.slice(1).filter(pred => {
          return calculateIOU(current.bbox, pred.bbox) < iouThreshold;
        });
      }

      return selected;
    }

    // 計算 IoU
    function calculateIOU(box1, box2) {
      const [x1, y1, w1, h1] = box1;
      const [x2, y2, w2, h2] = box2;

      const xLeft = Math.max(x1, x2);
      const yTop = Math.max(y1, y2);
      const xRight = Math.min(x1 + w1, x2 + w2);
      const yBottom = Math.min(y1 + h1, y2 + h2);

      if (xRight < xLeft || yBottom < yTop) return 0.0;

      const intersectionArea = (xRight - xLeft) * (yBottom - yTop);
      const box1Area = w1 * h1;
      const box2Area = w2 * h2;

      return intersectionArea / (box1Area + box2Area - intersectionArea);
    }

    // 估算距離
    function estimateDistance(width, height, className) {
      const area = width * height;
      let referenceArea = 10000;

      if (className === 'person') referenceArea = 8000;
      else if (className === 'car') referenceArea = 30000;
      else if (className === 'chair') referenceArea = 5000;

      const distance = Math.sqrt(referenceArea / area) * 3;
      return Math.min(Math.max(distance, 0.5), 20);
    }

    // 處理預測結果
    function processPredictions(predictions) {
      const obstacles = predictions.filter(p => IMPORTANT_CLASSES.includes(p.class));
      const obstacleCount = obstacles.length;
      
      document.getElementById('obstacleCount').textContent = obstacleCount;
      updateDebugInfo(`檢測到 ${predictions.length} 個物體，${obstacleCount} 個障礙物`);

      // 找到最近障礙物
      let closestDistance = Infinity;
      let closestObstacle = null;

      obstacles.forEach(obstacle => {
        if (obstacle.distance < closestDistance) {
          closestDistance = obstacle.distance;
          closestObstacle = obstacle;
        }
      });

      // 更新顯示
      const distanceElement = document.getElementById('closestDistance');
      if (closestObstacle) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' 公尺';
        
        // 語音警告
        if (voiceEnabled && closestDistance < 5) {
          const now = Date.now();
          if (now - lastSpeechTime > 3000) {
            let message = `前方${closestDistance.toFixed(1)}公尺有${closestObstacle.class}`;
            if (closestDistance < 2) message = `警告！${message}，請小心`;
            else if (closestDistance < 3) message = `注意！${message}`;
            updateVoice(message);
            lastSpeechTime = now;
          }
        }
      } else {
        distanceElement.textContent = '— 公尺';
      }

      updateDetectionList(obstacles);
    }

    let lastSpeechTime = 0;

    // 繪製檢測結果
    function drawPredictions(predictions, video) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      predictions.forEach(pred => {
        if (!IMPORTANT_CLASSES.includes(pred.class)) return;
        
        const [x, y, w, h] = pred.bbox;
        
        // 選擇顏色
        let color;
        if (pred.distance < 2) color = '#ff0000';
        else if (pred.distance < 4) color = '#ff9900';
        else color = '#00ff00';
        
        // 繪製邊框
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        // 繪製標籤
        const label = `${pred.class} ${pred.distance.toFixed(1)}m`;
        ctx.font = 'bold 14px Arial';
        const textWidth = ctx.measureText(label).width;
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y - 20, textWidth + 10, 20);
        
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 5, y - 5);
      });
    }

    // 更新偵測列表
    function updateDetectionList(predictions) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="detection-chip" style="text-align:center; color:var(--muted);">未偵測到障礙物</div>';
        return;
      }
      
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        let chipClass = '';
        if (pred.distance < 2) chipClass = 'danger';
        else if (pred.distance < 4) chipClass = 'warning';
        
        return `
          <div class="detection-chip ${chipClass}">
            <strong>${pred.class}</strong><br>
            距離: ${pred.distance.toFixed(1)}公尺 | 置信度: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    // FPS 計算
    function updateFPS(processingTime) {
      frameCount++;
      const now = performance.now();
      
      if (now - lastFpsTime >= 1000) {
        const fps = Math.round(frameCount * 1000 / (now - lastFpsTime));
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        lastFpsTime = now;
        
        if (debugMode) {
          updateDebugInfo(`FPS: ${fps}, 處理時間: ${processingTime.toFixed(1)}ms`);
        }
      }
    }

    // 工具函數
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      voiceAlert.classList.remove('loading');
      
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateDebugInfo(info) {
      if (debugMode) {
        document.getElementById('debugInfo').textContent = info;
      }
    }

    function showProgress(message, percent) {
      updateVoice(message);
      document.getElementById('progressBar').style.display = 'block';
      document.getElementById('progressFill').style.width = percent + '%';
    }

    function hideProgress() {
      document.getElementById('progressBar').style.display = 'none';
    }

    // 事件監聽器
    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnDebug').addEventListener('click', toggleDebug);
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        button.textContent = '語音關閉';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('語音提示已開啟');
      } else {
        button.textContent = '語音開啟';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleDebug() {
      debugMode = !debugMode;
      const panel = document.getElementById('debugPanel');
      const button = document.getElementById('btnDebug');
      
      if (debugMode) {
        panel.style.display = 'block';
        button.textContent = '隱藏除錯';
        updateDebugInfo('除錯模式已開啟');
      } else {
        panel.style.display = 'none';
        button.textContent = '顯示除錯';
      }
    }

    // 初始化應用
    window.addEventListener('DOMContentLoaded', () => {
      initEventListeners();
      initModel();
    });
  </script>
</body>
</html>