<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="盲人輔助導航系統 - 即時障礙物檢測與GPS返航" />
  <title>🧭 盲人輔助導航系統</title>
  
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    header.card {
      padding: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: 20px;
      margin: 0;
      font-weight: 700;
    }
    
    .tips {
      font-size: 12px;
      color: var(--muted);
    }
    
    .camera-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera-container video, 
    .camera-container canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
      font-family: inherit;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .btn.primary {
      background: var(--good);
      color: #fff;
    }
    
    .btn.warning {
      background: var(--warn);
      color: #fff;
    }
    
    .btn.danger {
      background: var(--bad);
      color: #fff;
    }
    
    .btn.secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .value {
      font-weight: 800;
      font-size: 16px;
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .detection-list {
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding-right: 4px;
    }
    
    .detection-chip {
      background: var(--glass-strong);
      padding: 12px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
      border-left: 4px solid var(--good);
    }
    
    .detection-chip.warning {
      border-left-color: var(--warn);
    }
    
    .detection-chip.danger {
      border-left-color: var(--bad);
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .debug-panel {
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
      display: none;
    }
    
    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--glass-strong);
      border-radius: 3px;
      margin: 10px 0;
      overflow: hidden;
      display: none;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--good);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }

    .gps-active {
      background: var(--good) !important;
    }

    .emergency-alert {
      animation: pulse 1s infinite;
      border: 2px solid var(--bad);
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    .module-tag {
      display: inline-block;
      background: var(--warn);
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 10px;
      margin-left: 8px;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- 標題區 -->
    <header class="card">
      <h1>🧭 盲人輔助導航系統</h1>
      <div class="tips">安全出行 · 障礙檢測 · 語音導航</div>
    </header>

    <!-- 相機區 -->
    <section class="card camera-container">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
    </section>

    <!-- 控制區 -->
    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">系統初始化中…</div>
      
      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      
      <!-- 主要控制按鈕 -->
      <div class="controls">
        <button id="btnStart" class="btn primary">開始檢測</button>
        <button id="btnVoice" class="btn secondary">語音開啟</button>
        <button id="btnMode" class="btn primary">步行模式</button>
        <button id="btnStop" class="btn danger">停止檢測</button>
      </div>

      <!-- 導航控制按鈕 -->
      <div class="controls">
        <button id="btnSetHome" class="btn primary">設定家的位置</button>
        <button id="btnReturnHome" class="btn warning">一鍵返航</button>
        <button id="btnLoadModule" class="btn primary">切換環境</button>
        <button id="btnEmergency" class="btn danger">緊急求助</button>
      </div>

      <div class="status-grid">
        <div class="status-item">
          <div class="label">系統狀態</div>
          <div class="value" id="status">準備中</div>
        </div>
        <div class="status-item">
          <div class="label">偵測速度</div>
          <div class="value" id="fps">—</div>
        </div>
        <div class="status-item">
          <div class="label">障礙物數</div>
          <div class="value" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="label">最近距離</div>
          <div class="value" id="closestDistance">— 公尺</div>
        </div>
      </div>

      <div class="status-grid">
        <div class="status-item">
          <div class="label">GPS狀態</div>
          <div class="value" id="gpsStatus">未連接</div>
        </div>
        <div class="status-item">
          <div class="label">距家距離</div>
          <div class="value" id="homeDistance">--</div>
        </div>
        <div class="status-item">
          <div class="label">當前環境</div>
          <div class="value" id="currentModule">戶外</div>
        </div>
        <div class="status-item">
          <div class="label">語音狀態</div>
          <div class="value" id="voiceStatus">開啟</div>
        </div>
      </div>

      <div id="debugPanel" class="debug-panel">
        <div><strong>除錯資訊:</strong></div>
        <div id="debugInfo">等待開始偵測...</div>
      </div>
    </section>

    <!-- 側邊欄 -->
    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">
        即時偵測 <span id="activeModuleTag" class="module-tag">戶外模式</span>
      </h3>
      <div id="detectionList" class="detection-list">
        <div class="detection-chip" style="text-align:center; color:var(--muted);">
          等待開始偵測…
        </div>
      </div>
      <footer>
        專為視障朋友設計 · 安全出行伴侶<br>
        請在光線充足環境使用
      </footer>
    </aside>
  </div>

  <script>
    // 配置參數 - 使用可靠的模型來源
    const MODEL_SOURCES = [
      // 主要使用本地模型
      'yolov8n.onnx',
      // 備用來源
      'https://raw.githubusercontent.com/ultralytics/assets/main/yolov8n.onnx',
      'https://models.roboflow.com/object-detection/yolov8n/1/model.onnx'
    ];

    const INPUT_SIZE = 640;
    const SCORE_THRESHOLD = 0.25;
    const IOU_THRESHOLD = 0.45;
    const TARGET_FPS = 10;

    // COCO 類別名稱
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light',
      'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
      'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee',
      'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle',
      'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange',
      'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed',
      'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven',
      'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    // 重要障礙物類別
    const IMPORTANT_CLASSES = [
      'person', 'car', 'motorcycle', 'bus', 'truck', 'bicycle', 
      'chair', 'bench', 'bed', 'couch', 'table'
    ];

    // 環境模組
    const ENVIRONMENT_MODULES = {
      outdoor: {
        name: '戶外模式',
        objects: ['person', 'car', 'motorcycle', 'bus', 'truck', 'bicycle', 'bench']
      },
      indoor: {
        name: '室內模式', 
        objects: ['person', 'chair', 'bed', 'couch', 'table', 'tv']
      }
    };

    // 全局變數
    let session = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let debugMode = false;
    let frameCount = 0;
    let lastFpsTime = 0;
    let currentEnvironment = 'outdoor';
    let gpsNavigator = null;

    // GPS 導航類
    class GPSNavigator {
      constructor() {
        this.homePosition = null;
        this.currentPosition = null;
        this.isTracking = false;
        this.watchId = null;
        this.returnHomeInterval = null;
        this.loadHomePosition();
      }

      loadHomePosition() {
        const saved = localStorage.getItem('homePosition');
        if (saved) {
          this.homePosition = JSON.parse(saved);
          updateGPSStatus('就緒');
          document.getElementById('btnSetHome').classList.add('gps-active');
        }
      }

      setHomePosition() {
        if (!navigator.geolocation) {
          updateVoice('您的裝置不支援GPS定位');
          return;
        }

        updateVoice('正在獲取當前位置...');
        navigator.geolocation.getCurrentPosition(
          (position) => {
            this.homePosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              timestamp: new Date().toISOString()
            };
            localStorage.setItem('homePosition', JSON.stringify(this.homePosition));
            updateVoice(`家的位置已記錄！`);
            updateGPSStatus('已設定家');
            document.getElementById('btnSetHome').classList.add('gps-active');
          },
          (error) => {
            let errorMsg = '無法獲取位置：';
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMsg += '請允許位置權限';
                break;
              case error.POSITION_UNAVAILABLE:
                errorMsg += '位置資訊不可用';
                break;
              case error.TIMEOUT:
                errorMsg += '定位請求超時';
                break;
              default:
                errorMsg += '未知錯誤';
            }
            updateVoice(errorMsg);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          }
        );
      }

      startReturnHome() {
        if (!this.homePosition) {
          updateVoice('請先設定家的位置');
          return;
        }

        this.isTracking = true;
        updateVoice('開始返航導航，請跟隨語音指引');
        updateGPSStatus('返航中');
        document.getElementById('btnReturnHome').classList.add('gps-active');

        this.watchId = navigator.geolocation.watchPosition(
          (position) => {
            this.currentPosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              accuracy: position.coords.accuracy
            };
            this.updateNavigation();
          },
          (error) => {
            updateVoice('GPS信號不穩定');
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 3000
          }
        );

        this.returnHomeInterval = setInterval(() => {
          if (this.currentPosition) {
            this.updateNavigation();
          }
        }, 10000);
      }

      updateNavigation() {
        const navInfo = this.calculateNavigation();
        if (!navInfo) return;

        const { distance, direction } = navInfo;
        document.getElementById('homeDistance').textContent = `${distance}m`;

        if (distance < 20) {
          updateVoice(`已到達家附近，距離${Math.round(distance)}公尺`);
          this.stopReturnHome();
        } else if (distance < 100) {
          updateVoice(`即將到家，距離${Math.round(distance)}公尺，請向${direction}前進`);
        } else {
          updateVoice(`距家${Math.round(distance)}公尺，請向${direction}前進`);
        }
      }

      calculateNavigation() {
        if (!this.currentPosition || !this.homePosition) return null;

        const R = 6371000;
        const φ1 = this.currentPosition.lat * Math.PI/180;
        const φ2 = this.homePosition.lat * Math.PI/180;
        const Δφ = (this.homePosition.lat - this.currentPosition.lat) * Math.PI/180;
        const Δλ = (this.homePosition.lng - this.currentPosition.lng) * Math.PI/180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = Math.round(R * c);

        const y = Math.sin(Δλ) * Math.cos(φ2);
        const x = Math.cos(φ1) * Math.sin(φ2) -
                  Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
        const θ = Math.atan2(y, x);
        const bearing = (θ * 180/Math.PI + 360) % 360;

        const direction = this.getDirectionFromBearing(bearing);
        return { distance, direction };
      }

      getDirectionFromBearing(bearing) {
        const directions = ['北', '東北', '東', '東南', '南', '西南', '西', '西北'];
        const index = Math.round(bearing / 45) % 8;
        return directions[index];
      }

      stopReturnHome() {
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
          this.watchId = null;
        }
        if (this.returnHomeInterval) {
          clearInterval(this.returnHomeInterval);
          this.returnHomeInterval = null;
        }
        this.isTracking = false;
        updateGPSStatus('就緒');
        document.getElementById('btnReturnHome').classList.remove('gps-active');
        updateVoice('返航導航結束');
      }
    }

    // 初始化模型 - 修復版本
    async function initModel() {
      try {
        showProgress('正在初始化 ONNX Runtime...', 10);
        
        ort.env.wasm.numThreads = 1;
        
        let modelLoaded = false;
        let lastError = null;
        
        // 嘗試所有模型來源
        for (let i = 0; i < MODEL_SOURCES.length; i++) {
          const modelUrl = MODEL_SOURCES[i];
          try {
            showProgress(`嘗試載入模型來源 ${i + 1}/${MODEL_SOURCES.length}...`, 30 + (i * 20));
            updateDebugInfo(`嘗試載入: ${modelUrl}`);
            
            session = await ort.InferenceSession.create(modelUrl, {
              executionProviders: ['wasm']
            });
            
            modelLoaded = true;
            updateDebugInfo(`✅ 模型載入成功！來源: ${modelUrl}`);
            updateDebugInfo(`輸入名稱: ${session.inputNames[0]}`);
            updateDebugInfo(`輸出名稱: ${session.outputNames[0]}`);
            break;
            
          } catch (error) {
            lastError = error;
            updateDebugInfo(`❌ 模型來源 ${i + 1} 失敗: ${error.message}`);
            continue;
          }
        }
        
        if (!modelLoaded) {
          throw new Error(`所有模型來源都失敗。最後錯誤: ${lastError?.message}`);
        }
        
        showProgress('模型初始化完成', 100);
        updateVoice('AI 模型載入完成！請點擊開始檢測');
        updateStatus('準備就緒');
        
        // 初始化 GPS
        gpsNavigator = new GPSNavigator();
        
        setTimeout(() => {
          hideProgress();
        }, 1000);
        
      } catch (error) {
        console.error('模型載入失敗:', error);
        updateDebugInfo(`❌ 模型載入最終錯誤: ${error.message}`);
        updateVoice('模型載入失敗，請檢查網路連接或確保模型檔案存在');
        hideProgress();
        
        // 提供具體解決方案
        if (error.message.includes('yolov8n.onnx')) {
          updateDebugInfo('💡 解決方案: 請確保 yolov8n.onnx 檔案與 HTML 在同目錄');
        } else if (error.message.includes('Failed to fetch')) {
          updateDebugInfo('💡 解決方案: 請檢查網路連接或使用本地模型檔案');
        }
      }
    }

    // 設定相機
    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        updateDebugInfo('請求相機權限...');
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        });
        
        video.srcObject = stream;
        
        return new Promise((resolve, reject) => {
          video.onloadedmetadata = () => {
            video.play().then(() => {
              updateDebugInfo(`✅ 相機就緒: ${video.videoWidth}x${video.videoHeight}`);
              resolve(video);
            }).catch(reject);
          };
          video.onerror = reject;
        });
      } catch (error) {
        console.error('相機錯誤:', error);
        updateDebugInfo(`❌ 相機錯誤: ${error.message}`);
        updateVoice('無法存取相機，請確認權限設定');
        return null;
      }
    }

    // 開始檢測
    async function startDetection() {
      if (!session) {
        updateVoice('模型尚未載入完成');
        return;
      }

      updateDebugInfo('開始設定相機...');
      const video = await setupCamera();
      if (!video) return;

      isDetecting = true;
      updateStatus('檢測中');
      updateVoice('開始障礙物檢測，請緩慢移動裝置');

      // 開始檢測循環
      detectionLoop(video);
    }

    // 停止檢測
    function stopDetection() {
      isDetecting = false;
      updateStatus('已停止');
      
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
        video.srcObject = null;
      }
      
      if (gpsNavigator) {
        gpsNavigator.stopReturnHome();
      }
      
      updateVoice('檢測已停止');
      updateDebugInfo('檢測已停止');
    }

    // 主檢測循環
    async function detectionLoop(video) {
      if (!isDetecting) return;

      const startTime = performance.now();

      try {
        // 1. 捕捉畫面
        const imageData = captureFrame(video);
        if (!imageData) {
          setTimeout(() => detectionLoop(video), 1000 / TARGET_FPS);
          return;
        }

        // 2. 預處理
        const inputTensor = preprocess(imageData);
        
        // 3. 推理
        const feeds = { [session.inputNames[0]]: inputTensor };
        const results = await session.run(feeds);
        
        // 4. 後處理
        const predictions = postprocess(results, video.videoWidth, video.videoHeight);
        
        // 5. 處理結果
        processPredictions(predictions);
        
        // 6. 繪製結果
        drawPredictions(predictions, video);
        
        // 更新 FPS
        updateFPS(performance.now() - startTime);

      } catch (error) {
        console.error('檢測錯誤:', error);
        updateDebugInfo(`檢測錯誤: ${error.message}`);
      }

      // 繼續下一幀
      if (isDetecting) {
        setTimeout(() => detectionLoop(video), 1000 / TARGET_FPS);
      }
    }

    // 捕捉畫面
    function captureFrame(video) {
      if (!video.videoWidth || !video.videoHeight) {
        return null;
      }

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      // 正常繪製，不翻轉
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    // 預處理
    function preprocess(imageData) {
      const { data, width, height } = imageData;
      const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
      
      // 簡單的預處理：調整大小 + 歸一化
      for (let c = 0; c < 3; c++) {
        for (let h = 0; h < INPUT_SIZE; h++) {
          for (let w = 0; w < INPUT_SIZE; w++) {
            // 計算對應的原圖座標
            const srcX = Math.floor(w * width / INPUT_SIZE);
            const srcY = Math.floor(h * height / INPUT_SIZE);
            const srcIndex = (srcY * width + srcX) * 4;
            
            const pixelValue = data[srcIndex + c] / 255.0; // 歸一化到 [0,1]
            input[c * INPUT_SIZE * INPUT_SIZE + h * INPUT_SIZE + w] = pixelValue;
          }
        }
      }
      
      return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
    }

    // 後處理
    function postprocess(outputs, originalWidth, originalHeight) {
      const predictions = [];
      const output = outputs[session.outputNames[0]];
      
      if (!output || !output.data) {
        updateDebugInfo('沒有輸出數據');
        return predictions;
      }

      const outputData = output.data;
      const numDetections = output.dims[1];
      const numClasses = output.dims[2] - 4;

      for (let i = 0; i < numDetections; i++) {
        const offset = i * (numClasses + 4);
        const [x, y, width, height, ...scores] = Array.from(outputData.slice(offset, offset + numClasses + 4));
        
        // 找到最高分數的類別
        const maxScore = Math.max(...scores);
        const classId = scores.indexOf(maxScore);

        if (maxScore > SCORE_THRESHOLD && classId < CLASS_NAMES.length) {
          // 轉換座標到原圖尺寸
          const scaleX = originalWidth / INPUT_SIZE;
          const scaleY = originalHeight / INPUT_SIZE;
          
          const bbox = [
            (x - width / 2) * scaleX,  // x
            (y - height / 2) * scaleY, // y
            width * scaleX,            // width
            height * scaleY            // height
          ];

          // 確保座標在合理範圍內
          if (bbox[0] >= 0 && bbox[1] >= 0 && bbox[2] > 10 && bbox[3] > 10) {
            predictions.push({
              class: CLASS_NAMES[classId],
              score: maxScore,
              bbox: bbox,
              distance: estimateDistance(bbox[2], bbox[3], CLASS_NAMES[classId])
            });
          }
        }
      }

      updateDebugInfo(`檢測到 ${predictions.length} 個物體`);
      return nonMaxSuppression(predictions, IOU_THRESHOLD);
    }

    // 非極大值抑制
    function nonMaxSuppression(predictions, iouThreshold) {
      if (predictions.length === 0) return predictions;
      
      predictions.sort((a, b) => b.score - a.score);
      const selected = [];

      while (predictions.length > 0) {
        const current = predictions[0];
        selected.push(current);

        predictions = predictions.slice(1).filter(pred => {
          return calculateIOU(current.bbox, pred.bbox) < iouThreshold;
        });
      }

      return selected;
    }

    // 計算 IoU
    function calculateIOU(box1, box2) {
      const [x1, y1, w1, h1] = box1;
      const [x2, y2, w2, h2] = box2;

      const xLeft = Math.max(x1, x2);
      const yTop = Math.max(y1, y2);
      const xRight = Math.min(x1 + w1, x2 + w2);
      const yBottom = Math.min(y1 + h1, y2 + h2);

      if (xRight < xLeft || yBottom < yTop) return 0.0;

      const intersectionArea = (xRight - xLeft) * (yBottom - yTop);
      const box1Area = w1 * h1;
      const box2Area = w2 * h2;

      return intersectionArea / (box1Area + box2Area - intersectionArea);
    }

    // 估算距離
    function estimateDistance(width, height, className) {
      const area = width * height;
      let referenceArea = 10000;

      if (className === 'person') referenceArea = 8000;
      else if (className === 'car') referenceArea = 30000;
      else if (className === 'chair') referenceArea = 5000;

      const distance = Math.sqrt(referenceArea / area) * 2;
      return Math.min(Math.max(distance, 0.5), 20);
    }

    // 處理預測結果
    function processPredictions(predictions) {
      const currentModule = ENVIRONMENT_MODULES[currentEnvironment];
      const obstacles = predictions.filter(p => currentModule.objects.includes(p.class));
      const obstacleCount = obstacles.length;
      
      document.getElementById('obstacleCount').textContent = obstacleCount;

      // 找到最近障礙物
      let closestDistance = Infinity;
      let closestObstacle = null;

      obstacles.forEach(obstacle => {
        if (obstacle.distance < closestDistance) {
          closestDistance = obstacle.distance;
          closestObstacle = obstacle;
        }
      });

      // 更新顯示
      const distanceElement = document.getElementById('closestDistance');
      if (closestObstacle) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' 公尺';
        
        // 語音警告
        if (voiceEnabled && closestDistance < 5) {
          const now = Date.now();
          if (now - lastSpeechTime > 3000) {
            let message = `前方${closestDistance.toFixed(1)}公尺有${closestObstacle.class}`;
            if (closestDistance < 2) message = `警告！${message}，請小心`;
            else if (closestDistance < 3) message = `注意！${message}`;
            updateVoice(message);
            lastSpeechTime = now;
          }
        }
      } else {
        distanceElement.textContent = '— 公尺';
      }

      updateDetectionList(obstacles);
    }

    let lastSpeechTime = 0;

    // 繪製檢測結果
    function drawPredictions(predictions, video) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      predictions.forEach(pred => {
        const currentModule = ENVIRONMENT_MODULES[currentEnvironment];
        if (!currentModule.objects.includes(pred.class)) return;
        
        const [x, y, w, h] = pred.bbox;
        
        // 選擇顏色
        let color;
        if (pred.distance < 2) color = '#ff0000';
        else if (pred.distance < 4) color = '#ff9900';
        else color = '#00ff00';
        
        // 繪製邊框
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        // 繪製標籤
        const label = `${pred.class} ${pred.distance.toFixed(1)}m`;
        ctx.font = 'bold 14px Arial';
        const textWidth = ctx.measureText(label).width;
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y - 20, textWidth + 10, 20);
        
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 5, y - 5);
      });
    }

    // 更新偵測列表
    function updateDetectionList(predictions) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="detection-chip" style="text-align:center; color:var(--muted);">未偵測到障礙物</div>';
        return;
      }
      
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        let chipClass = '';
        if (pred.distance < 2) chipClass = 'danger';
        else if (pred.distance < 4) chipClass = 'warning';
        
        return `
          <div class="detection-chip ${chipClass}">
            <strong>${pred.class}</strong><br>
            距離: ${pred.distance.toFixed(1)}公尺 | 置信度: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    // FPS 計算
    function updateFPS(processingTime) {
      frameCount++;
      const now = performance.now();
      
      if (now - lastFpsTime >= 1000) {
        const fps = Math.round(frameCount * 1000 / (now - lastFpsTime));
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        lastFpsTime = now;
        
        if (debugMode) {
          updateDebugInfo(`FPS: ${fps}, 處理時間: ${processingTime.toFixed(1)}ms`);
        }
      }
    }

    // 工具函數
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      voiceAlert.classList.remove('loading');
      
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateGPSStatus(status) {
      document.getElementById('gpsStatus').textContent = status;
    }

    function updateDebugInfo(info) {
      if (debugMode) {
        document.getElementById('debugInfo').textContent = info;
      }
    }

    function showProgress(message, percent) {
      updateVoice(message);
      document.getElementById('progressBar').style.display = 'block';
      document.getElementById('progressFill').style.width = percent + '%';
    }

    function hideProgress() {
      document.getElementById('progressBar').style.display = 'none';
    }

    // 環境切換
    function loadEnvironmentModule() {
      const environments = Object.keys(ENVIRONMENT_MODULES);
      const currentIndex = environments.indexOf(currentEnvironment);
      const nextIndex = (currentIndex + 1) % environments.length;
      currentEnvironment = environments[nextIndex];
      
      const module = ENVIRONMENT_MODULES[currentEnvironment];
      document.getElementById('currentModule').textContent = module.name;
      document.getElementById('activeModuleTag').textContent = module.name;
      
      updateVoice(`切換到${module.name}環境`);
    }

    // 緊急求助
    function emergencyAlert() {
      const button = document.getElementById('btnEmergency');
      button.classList.add('emergency-alert');
      
      updateVoice('緊急求助！正在發送位置資訊給緊急聯絡人');
      
      if (gpsNavigator && gpsNavigator.currentPosition) {
        const { lat, lng } = gpsNavigator.currentPosition;
        console.log(`緊急位置發送: 緯度 ${lat.toFixed(6)}, 經度 ${lng.toFixed(6)}`);
      }
      
      setTimeout(() => {
        button.classList.remove('emergency-alert');
      }, 5000);
    }

    // 事件監聽器
    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnDebug').addEventListener('click', toggleDebug);
      document.getElementById('btnSetHome').addEventListener('click', () => gpsNavigator.setHomePosition());
      document.getElementById('btnReturnHome').addEventListener('click', () => gpsNavigator.startReturnHome());
      document.getElementById('btnLoadModule').addEventListener('click', loadEnvironmentModule);
      document.getElementById('btnEmergency').addEventListener('click', emergencyAlert);
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const status = document.getElementById('voiceStatus');
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        status.textContent = '開啟';
        button.textContent = '語音關閉';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('語音提示已開啟');
      } else {
        status.textContent = '關閉';
        button.textContent = '語音開啟';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleDebug() {
      debugMode = !debugMode;
      const panel = document.getElementById('debugPanel');
      const button = document.getElementById('btnDebug');
      
      if (debugMode) {
        panel.style.display = 'block';
        button.textContent = '隱藏除錯';
        updateDebugInfo('除錯模式已開啟');
      } else {
        panel.style.display = 'none';
        button.textContent = '顯示除錯';
      }
    }

    // 初始化應用
    window.addEventListener('DOMContentLoaded', () => {
      initEventListeners();
      initModel();
    });
  </script>
</body>
</html>