<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆªç³»çµ± - å³æ™‚éšœç¤™ç‰©æª¢æ¸¬èˆ‡GPSè¿”èˆª" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</title>
  
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    header.card {
      padding: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: 20px;
      margin: 0;
      font-weight: 700;
    }
    
    .tips {
      font-size: 12px;
      color: var(--muted);
    }
    
    .camera-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera-container video, 
    .camera-container canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
      font-family: inherit;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .btn.primary {
      background: var(--good);
      color: #fff;
    }
    
    .btn.warning {
      background: var(--warn);
      color: #fff;
    }
    
    .btn.danger {
      background: var(--bad);
      color: #fff;
    }
    
    .btn.secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .value {
      font-weight: 800;
      font-size: 16px;
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .detection-list {
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding-right: 4px;
    }
    
    .detection-chip {
      background: var(--glass-strong);
      padding: 12px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
      border-left: 4px solid var(--good);
    }
    
    .detection-chip.warning {
      border-left-color: var(--warn);
    }
    
    .detection-chip.danger {
      border-left-color: var(--bad);
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .debug-panel {
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
      display: none;
    }
    
    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--glass-strong);
      border-radius: 3px;
      margin: 10px 0;
      overflow: hidden;
      display: none;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--good);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }

    .gps-active {
      background: var(--good) !important;
    }

    .emergency-alert {
      animation: pulse 1s infinite;
      border: 2px solid var(--bad);
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    .module-tag {
      display: inline-block;
      background: var(--warn);
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 10px;
      margin-left: 8px;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- æ¨™é¡Œå€ -->
    <header class="card">
      <h1>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</h1>
      <div class="tips">å®‰å…¨å‡ºè¡Œ Â· éšœç¤™æª¢æ¸¬ Â· èªéŸ³å°èˆª</div>
    </header>

    <!-- ç›¸æ©Ÿå€ -->
    <section class="card camera-container">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
    </section>

    <!-- æ§åˆ¶å€ -->
    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">ç³»çµ±åˆå§‹åŒ–ä¸­â€¦</div>
      
      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      
      <!-- ä¸»è¦æ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnStart" class="btn primary">é–‹å§‹æª¢æ¸¬</button>
        <button id="btnVoice" class="btn secondary">èªéŸ³é–‹å•Ÿ</button>
        <button id="btnMode" class="btn primary">æ­¥è¡Œæ¨¡å¼</button>
        <button id="btnStop" class="btn danger">åœæ­¢æª¢æ¸¬</button>
      </div>

      <!-- å°èˆªæ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnSetHome" class="btn primary">è¨­å®šå®¶çš„ä½ç½®</button>
        <button id="btnReturnHome" class="btn warning">ä¸€éµè¿”èˆª</button>
        <button id="btnLoadModule" class="btn primary">åˆ‡æ›ç’°å¢ƒ</button>
        <button id="btnEmergency" class="btn danger">ç·Šæ€¥æ±‚åŠ©</button>
      </div>

      <div class="status-grid">
        <div class="status-item">
          <div class="label">ç³»çµ±ç‹€æ…‹</div>
          <div class="value" id="status">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="label">åµæ¸¬é€Ÿåº¦</div>
          <div class="value" id="fps">â€”</div>
        </div>
        <div class="status-item">
          <div class="label">éšœç¤™ç‰©æ•¸</div>
          <div class="value" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="label">æœ€è¿‘è·é›¢</div>
          <div class="value" id="closestDistance">â€” å…¬å°º</div>
        </div>
      </div>

      <div class="status-grid">
        <div class="status-item">
          <div class="label">GPSç‹€æ…‹</div>
          <div class="value" id="gpsStatus">æœªé€£æ¥</div>
        </div>
        <div class="status-item">
          <div class="label">è·å®¶è·é›¢</div>
          <div class="value" id="homeDistance">--</div>
        </div>
        <div class="status-item">
          <div class="label">ç•¶å‰ç’°å¢ƒ</div>
          <div class="value" id="currentModule">æˆ¶å¤–</div>
        </div>
        <div class="status-item">
          <div class="label">èªéŸ³ç‹€æ…‹</div>
          <div class="value" id="voiceStatus">é–‹å•Ÿ</div>
        </div>
      </div>

      <div id="debugPanel" class="debug-panel">
        <div><strong>é™¤éŒ¯è³‡è¨Š:</strong></div>
        <div id="debugInfo">ç­‰å¾…é–‹å§‹åµæ¸¬...</div>
      </div>
    </section>

    <!-- å´é‚Šæ¬„ -->
    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">
        å³æ™‚åµæ¸¬ <span id="activeModuleTag" class="module-tag">æˆ¶å¤–æ¨¡å¼</span>
      </h3>
      <div id="detectionList" class="detection-list">
        <div class="detection-chip" style="text-align:center; color:var(--muted);">
          ç­‰å¾…é–‹å§‹åµæ¸¬â€¦
        </div>
      </div>
      <footer>
        å°ˆç‚ºè¦–éšœæœ‹å‹è¨­è¨ˆ Â· å®‰å…¨å‡ºè¡Œä¼´ä¾¶<br>
        è«‹åœ¨å…‰ç·šå……è¶³ç’°å¢ƒä½¿ç”¨
      </footer>
    </aside>
  </div>

  <script>
    // é…ç½®åƒæ•¸ - ä½¿ç”¨å¯é çš„æ¨¡å‹ä¾†æº
    const MODEL_SOURCES = [
      // ä¸»è¦ä½¿ç”¨æœ¬åœ°æ¨¡å‹
      'yolov8n.onnx',
      // å‚™ç”¨ä¾†æº
      'https://raw.githubusercontent.com/ultralytics/assets/main/yolov8n.onnx',
      'https://models.roboflow.com/object-detection/yolov8n/1/model.onnx'
    ];

    const INPUT_SIZE = 640;
    const SCORE_THRESHOLD = 0.25;
    const IOU_THRESHOLD = 0.45;
    const TARGET_FPS = 10;

    // COCO é¡åˆ¥åç¨±
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light',
      'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
      'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee',
      'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle',
      'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange',
      'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed',
      'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven',
      'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    // é‡è¦éšœç¤™ç‰©é¡åˆ¥
    const IMPORTANT_CLASSES = [
      'person', 'car', 'motorcycle', 'bus', 'truck', 'bicycle', 
      'chair', 'bench', 'bed', 'couch', 'table'
    ];

    // ç’°å¢ƒæ¨¡çµ„
    const ENVIRONMENT_MODULES = {
      outdoor: {
        name: 'æˆ¶å¤–æ¨¡å¼',
        objects: ['person', 'car', 'motorcycle', 'bus', 'truck', 'bicycle', 'bench']
      },
      indoor: {
        name: 'å®¤å…§æ¨¡å¼', 
        objects: ['person', 'chair', 'bed', 'couch', 'table', 'tv']
      }
    };

    // å…¨å±€è®Šæ•¸
    let session = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let debugMode = false;
    let frameCount = 0;
    let lastFpsTime = 0;
    let currentEnvironment = 'outdoor';
    let gpsNavigator = null;

    // GPS å°èˆªé¡
    class GPSNavigator {
      constructor() {
        this.homePosition = null;
        this.currentPosition = null;
        this.isTracking = false;
        this.watchId = null;
        this.returnHomeInterval = null;
        this.loadHomePosition();
      }

      loadHomePosition() {
        const saved = localStorage.getItem('homePosition');
        if (saved) {
          this.homePosition = JSON.parse(saved);
          updateGPSStatus('å°±ç·’');
          document.getElementById('btnSetHome').classList.add('gps-active');
        }
      }

      setHomePosition() {
        if (!navigator.geolocation) {
          updateVoice('æ‚¨çš„è£ç½®ä¸æ”¯æ´GPSå®šä½');
          return;
        }

        updateVoice('æ­£åœ¨ç²å–ç•¶å‰ä½ç½®...');
        navigator.geolocation.getCurrentPosition(
          (position) => {
            this.homePosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              timestamp: new Date().toISOString()
            };
            localStorage.setItem('homePosition', JSON.stringify(this.homePosition));
            updateVoice(`å®¶çš„ä½ç½®å·²è¨˜éŒ„ï¼`);
            updateGPSStatus('å·²è¨­å®šå®¶');
            document.getElementById('btnSetHome').classList.add('gps-active');
          },
          (error) => {
            let errorMsg = 'ç„¡æ³•ç²å–ä½ç½®ï¼š';
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMsg += 'è«‹å…è¨±ä½ç½®æ¬Šé™';
                break;
              case error.POSITION_UNAVAILABLE:
                errorMsg += 'ä½ç½®è³‡è¨Šä¸å¯ç”¨';
                break;
              case error.TIMEOUT:
                errorMsg += 'å®šä½è«‹æ±‚è¶…æ™‚';
                break;
              default:
                errorMsg += 'æœªçŸ¥éŒ¯èª¤';
            }
            updateVoice(errorMsg);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          }
        );
      }

      startReturnHome() {
        if (!this.homePosition) {
          updateVoice('è«‹å…ˆè¨­å®šå®¶çš„ä½ç½®');
          return;
        }

        this.isTracking = true;
        updateVoice('é–‹å§‹è¿”èˆªå°èˆªï¼Œè«‹è·Ÿéš¨èªéŸ³æŒ‡å¼•');
        updateGPSStatus('è¿”èˆªä¸­');
        document.getElementById('btnReturnHome').classList.add('gps-active');

        this.watchId = navigator.geolocation.watchPosition(
          (position) => {
            this.currentPosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              accuracy: position.coords.accuracy
            };
            this.updateNavigation();
          },
          (error) => {
            updateVoice('GPSä¿¡è™Ÿä¸ç©©å®š');
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 3000
          }
        );

        this.returnHomeInterval = setInterval(() => {
          if (this.currentPosition) {
            this.updateNavigation();
          }
        }, 10000);
      }

      updateNavigation() {
        const navInfo = this.calculateNavigation();
        if (!navInfo) return;

        const { distance, direction } = navInfo;
        document.getElementById('homeDistance').textContent = `${distance}m`;

        if (distance < 20) {
          updateVoice(`å·²åˆ°é”å®¶é™„è¿‘ï¼Œè·é›¢${Math.round(distance)}å…¬å°º`);
          this.stopReturnHome();
        } else if (distance < 100) {
          updateVoice(`å³å°‡åˆ°å®¶ï¼Œè·é›¢${Math.round(distance)}å…¬å°ºï¼Œè«‹å‘${direction}å‰é€²`);
        } else {
          updateVoice(`è·å®¶${Math.round(distance)}å…¬å°ºï¼Œè«‹å‘${direction}å‰é€²`);
        }
      }

      calculateNavigation() {
        if (!this.currentPosition || !this.homePosition) return null;

        const R = 6371000;
        const Ï†1 = this.currentPosition.lat * Math.PI/180;
        const Ï†2 = this.homePosition.lat * Math.PI/180;
        const Î”Ï† = (this.homePosition.lat - this.currentPosition.lat) * Math.PI/180;
        const Î”Î» = (this.homePosition.lng - this.currentPosition.lng) * Math.PI/180;

        const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                  Math.cos(Ï†1) * Math.cos(Ï†2) *
                  Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = Math.round(R * c);

        const y = Math.sin(Î”Î») * Math.cos(Ï†2);
        const x = Math.cos(Ï†1) * Math.sin(Ï†2) -
                  Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î”Î»);
        const Î¸ = Math.atan2(y, x);
        const bearing = (Î¸ * 180/Math.PI + 360) % 360;

        const direction = this.getDirectionFromBearing(bearing);
        return { distance, direction };
      }

      getDirectionFromBearing(bearing) {
        const directions = ['åŒ—', 'æ±åŒ—', 'æ±', 'æ±å—', 'å—', 'è¥¿å—', 'è¥¿', 'è¥¿åŒ—'];
        const index = Math.round(bearing / 45) % 8;
        return directions[index];
      }

      stopReturnHome() {
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
          this.watchId = null;
        }
        if (this.returnHomeInterval) {
          clearInterval(this.returnHomeInterval);
          this.returnHomeInterval = null;
        }
        this.isTracking = false;
        updateGPSStatus('å°±ç·’');
        document.getElementById('btnReturnHome').classList.remove('gps-active');
        updateVoice('è¿”èˆªå°èˆªçµæŸ');
      }
    }

    // åˆå§‹åŒ–æ¨¡å‹ - ä¿®å¾©ç‰ˆæœ¬
    async function initModel() {
      try {
        showProgress('æ­£åœ¨åˆå§‹åŒ– ONNX Runtime...', 10);
        
        ort.env.wasm.numThreads = 1;
        
        let modelLoaded = false;
        let lastError = null;
        
        // å˜—è©¦æ‰€æœ‰æ¨¡å‹ä¾†æº
        for (let i = 0; i < MODEL_SOURCES.length; i++) {
          const modelUrl = MODEL_SOURCES[i];
          try {
            showProgress(`å˜—è©¦è¼‰å…¥æ¨¡å‹ä¾†æº ${i + 1}/${MODEL_SOURCES.length}...`, 30 + (i * 20));
            updateDebugInfo(`å˜—è©¦è¼‰å…¥: ${modelUrl}`);
            
            session = await ort.InferenceSession.create(modelUrl, {
              executionProviders: ['wasm']
            });
            
            modelLoaded = true;
            updateDebugInfo(`âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸï¼ä¾†æº: ${modelUrl}`);
            updateDebugInfo(`è¼¸å…¥åç¨±: ${session.inputNames[0]}`);
            updateDebugInfo(`è¼¸å‡ºåç¨±: ${session.outputNames[0]}`);
            break;
            
          } catch (error) {
            lastError = error;
            updateDebugInfo(`âŒ æ¨¡å‹ä¾†æº ${i + 1} å¤±æ•—: ${error.message}`);
            continue;
          }
        }
        
        if (!modelLoaded) {
          throw new Error(`æ‰€æœ‰æ¨¡å‹ä¾†æºéƒ½å¤±æ•—ã€‚æœ€å¾ŒéŒ¯èª¤: ${lastError?.message}`);
        }
        
        showProgress('æ¨¡å‹åˆå§‹åŒ–å®Œæˆ', 100);
        updateVoice('AI æ¨¡å‹è¼‰å…¥å®Œæˆï¼è«‹é»æ“Šé–‹å§‹æª¢æ¸¬');
        updateStatus('æº–å‚™å°±ç·’');
        
        // åˆå§‹åŒ– GPS
        gpsNavigator = new GPSNavigator();
        
        setTimeout(() => {
          hideProgress();
        }, 1000);
        
      } catch (error) {
        console.error('æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
        updateDebugInfo(`âŒ æ¨¡å‹è¼‰å…¥æœ€çµ‚éŒ¯èª¤: ${error.message}`);
        updateVoice('æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥æˆ–ç¢ºä¿æ¨¡å‹æª”æ¡ˆå­˜åœ¨');
        hideProgress();
        
        // æä¾›å…·é«”è§£æ±ºæ–¹æ¡ˆ
        if (error.message.includes('yolov8n.onnx')) {
          updateDebugInfo('ğŸ’¡ è§£æ±ºæ–¹æ¡ˆ: è«‹ç¢ºä¿ yolov8n.onnx æª”æ¡ˆèˆ‡ HTML åœ¨åŒç›®éŒ„');
        } else if (error.message.includes('Failed to fetch')) {
          updateDebugInfo('ğŸ’¡ è§£æ±ºæ–¹æ¡ˆ: è«‹æª¢æŸ¥ç¶²è·¯é€£æ¥æˆ–ä½¿ç”¨æœ¬åœ°æ¨¡å‹æª”æ¡ˆ');
        }
      }
    }

    // è¨­å®šç›¸æ©Ÿ
    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        updateDebugInfo('è«‹æ±‚ç›¸æ©Ÿæ¬Šé™...');
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        });
        
        video.srcObject = stream;
        
        return new Promise((resolve, reject) => {
          video.onloadedmetadata = () => {
            video.play().then(() => {
              updateDebugInfo(`âœ… ç›¸æ©Ÿå°±ç·’: ${video.videoWidth}x${video.videoHeight}`);
              resolve(video);
            }).catch(reject);
          };
          video.onerror = reject;
        });
      } catch (error) {
        console.error('ç›¸æ©ŸéŒ¯èª¤:', error);
        updateDebugInfo(`âŒ ç›¸æ©ŸéŒ¯èª¤: ${error.message}`);
        updateVoice('ç„¡æ³•å­˜å–ç›¸æ©Ÿï¼Œè«‹ç¢ºèªæ¬Šé™è¨­å®š');
        return null;
      }
    }

    // é–‹å§‹æª¢æ¸¬
    async function startDetection() {
      if (!session) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆ');
        return;
      }

      updateDebugInfo('é–‹å§‹è¨­å®šç›¸æ©Ÿ...');
      const video = await setupCamera();
      if (!video) return;

      isDetecting = true;
      updateStatus('æª¢æ¸¬ä¸­');
      updateVoice('é–‹å§‹éšœç¤™ç‰©æª¢æ¸¬ï¼Œè«‹ç·©æ…¢ç§»å‹•è£ç½®');

      // é–‹å§‹æª¢æ¸¬å¾ªç’°
      detectionLoop(video);
    }

    // åœæ­¢æª¢æ¸¬
    function stopDetection() {
      isDetecting = false;
      updateStatus('å·²åœæ­¢');
      
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
        video.srcObject = null;
      }
      
      if (gpsNavigator) {
        gpsNavigator.stopReturnHome();
      }
      
      updateVoice('æª¢æ¸¬å·²åœæ­¢');
      updateDebugInfo('æª¢æ¸¬å·²åœæ­¢');
    }

    // ä¸»æª¢æ¸¬å¾ªç’°
    async function detectionLoop(video) {
      if (!isDetecting) return;

      const startTime = performance.now();

      try {
        // 1. æ•æ‰ç•«é¢
        const imageData = captureFrame(video);
        if (!imageData) {
          setTimeout(() => detectionLoop(video), 1000 / TARGET_FPS);
          return;
        }

        // 2. é è™•ç†
        const inputTensor = preprocess(imageData);
        
        // 3. æ¨ç†
        const feeds = { [session.inputNames[0]]: inputTensor };
        const results = await session.run(feeds);
        
        // 4. å¾Œè™•ç†
        const predictions = postprocess(results, video.videoWidth, video.videoHeight);
        
        // 5. è™•ç†çµæœ
        processPredictions(predictions);
        
        // 6. ç¹ªè£½çµæœ
        drawPredictions(predictions, video);
        
        // æ›´æ–° FPS
        updateFPS(performance.now() - startTime);

      } catch (error) {
        console.error('æª¢æ¸¬éŒ¯èª¤:', error);
        updateDebugInfo(`æª¢æ¸¬éŒ¯èª¤: ${error.message}`);
      }

      // ç¹¼çºŒä¸‹ä¸€å¹€
      if (isDetecting) {
        setTimeout(() => detectionLoop(video), 1000 / TARGET_FPS);
      }
    }

    // æ•æ‰ç•«é¢
    function captureFrame(video) {
      if (!video.videoWidth || !video.videoHeight) {
        return null;
      }

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      // æ­£å¸¸ç¹ªè£½ï¼Œä¸ç¿»è½‰
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    // é è™•ç†
    function preprocess(imageData) {
      const { data, width, height } = imageData;
      const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
      
      // ç°¡å–®çš„é è™•ç†ï¼šèª¿æ•´å¤§å° + æ­¸ä¸€åŒ–
      for (let c = 0; c < 3; c++) {
        for (let h = 0; h < INPUT_SIZE; h++) {
          for (let w = 0; w < INPUT_SIZE; w++) {
            // è¨ˆç®—å°æ‡‰çš„åŸåœ–åº§æ¨™
            const srcX = Math.floor(w * width / INPUT_SIZE);
            const srcY = Math.floor(h * height / INPUT_SIZE);
            const srcIndex = (srcY * width + srcX) * 4;
            
            const pixelValue = data[srcIndex + c] / 255.0; // æ­¸ä¸€åŒ–åˆ° [0,1]
            input[c * INPUT_SIZE * INPUT_SIZE + h * INPUT_SIZE + w] = pixelValue;
          }
        }
      }
      
      return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
    }

    // å¾Œè™•ç†
    function postprocess(outputs, originalWidth, originalHeight) {
      const predictions = [];
      const output = outputs[session.outputNames[0]];
      
      if (!output || !output.data) {
        updateDebugInfo('æ²’æœ‰è¼¸å‡ºæ•¸æ“š');
        return predictions;
      }

      const outputData = output.data;
      const numDetections = output.dims[1];
      const numClasses = output.dims[2] - 4;

      for (let i = 0; i < numDetections; i++) {
        const offset = i * (numClasses + 4);
        const [x, y, width, height, ...scores] = Array.from(outputData.slice(offset, offset + numClasses + 4));
        
        // æ‰¾åˆ°æœ€é«˜åˆ†æ•¸çš„é¡åˆ¥
        const maxScore = Math.max(...scores);
        const classId = scores.indexOf(maxScore);

        if (maxScore > SCORE_THRESHOLD && classId < CLASS_NAMES.length) {
          // è½‰æ›åº§æ¨™åˆ°åŸåœ–å°ºå¯¸
          const scaleX = originalWidth / INPUT_SIZE;
          const scaleY = originalHeight / INPUT_SIZE;
          
          const bbox = [
            (x - width / 2) * scaleX,  // x
            (y - height / 2) * scaleY, // y
            width * scaleX,            // width
            height * scaleY            // height
          ];

          // ç¢ºä¿åº§æ¨™åœ¨åˆç†ç¯„åœå…§
          if (bbox[0] >= 0 && bbox[1] >= 0 && bbox[2] > 10 && bbox[3] > 10) {
            predictions.push({
              class: CLASS_NAMES[classId],
              score: maxScore,
              bbox: bbox,
              distance: estimateDistance(bbox[2], bbox[3], CLASS_NAMES[classId])
            });
          }
        }
      }

      updateDebugInfo(`æª¢æ¸¬åˆ° ${predictions.length} å€‹ç‰©é«”`);
      return nonMaxSuppression(predictions, IOU_THRESHOLD);
    }

    // éæ¥µå¤§å€¼æŠ‘åˆ¶
    function nonMaxSuppression(predictions, iouThreshold) {
      if (predictions.length === 0) return predictions;
      
      predictions.sort((a, b) => b.score - a.score);
      const selected = [];

      while (predictions.length > 0) {
        const current = predictions[0];
        selected.push(current);

        predictions = predictions.slice(1).filter(pred => {
          return calculateIOU(current.bbox, pred.bbox) < iouThreshold;
        });
      }

      return selected;
    }

    // è¨ˆç®— IoU
    function calculateIOU(box1, box2) {
      const [x1, y1, w1, h1] = box1;
      const [x2, y2, w2, h2] = box2;

      const xLeft = Math.max(x1, x2);
      const yTop = Math.max(y1, y2);
      const xRight = Math.min(x1 + w1, x2 + w2);
      const yBottom = Math.min(y1 + h1, y2 + h2);

      if (xRight < xLeft || yBottom < yTop) return 0.0;

      const intersectionArea = (xRight - xLeft) * (yBottom - yTop);
      const box1Area = w1 * h1;
      const box2Area = w2 * h2;

      return intersectionArea / (box1Area + box2Area - intersectionArea);
    }

    // ä¼°ç®—è·é›¢
    function estimateDistance(width, height, className) {
      const area = width * height;
      let referenceArea = 10000;

      if (className === 'person') referenceArea = 8000;
      else if (className === 'car') referenceArea = 30000;
      else if (className === 'chair') referenceArea = 5000;

      const distance = Math.sqrt(referenceArea / area) * 2;
      return Math.min(Math.max(distance, 0.5), 20);
    }

    // è™•ç†é æ¸¬çµæœ
    function processPredictions(predictions) {
      const currentModule = ENVIRONMENT_MODULES[currentEnvironment];
      const obstacles = predictions.filter(p => currentModule.objects.includes(p.class));
      const obstacleCount = obstacles.length;
      
      document.getElementById('obstacleCount').textContent = obstacleCount;

      // æ‰¾åˆ°æœ€è¿‘éšœç¤™ç‰©
      let closestDistance = Infinity;
      let closestObstacle = null;

      obstacles.forEach(obstacle => {
        if (obstacle.distance < closestDistance) {
          closestDistance = obstacle.distance;
          closestObstacle = obstacle;
        }
      });

      // æ›´æ–°é¡¯ç¤º
      const distanceElement = document.getElementById('closestDistance');
      if (closestObstacle) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' å…¬å°º';
        
        // èªéŸ³è­¦å‘Š
        if (voiceEnabled && closestDistance < 5) {
          const now = Date.now();
          if (now - lastSpeechTime > 3000) {
            let message = `å‰æ–¹${closestDistance.toFixed(1)}å…¬å°ºæœ‰${closestObstacle.class}`;
            if (closestDistance < 2) message = `è­¦å‘Šï¼${message}ï¼Œè«‹å°å¿ƒ`;
            else if (closestDistance < 3) message = `æ³¨æ„ï¼${message}`;
            updateVoice(message);
            lastSpeechTime = now;
          }
        }
      } else {
        distanceElement.textContent = 'â€” å…¬å°º';
      }

      updateDetectionList(obstacles);
    }

    let lastSpeechTime = 0;

    // ç¹ªè£½æª¢æ¸¬çµæœ
    function drawPredictions(predictions, video) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      predictions.forEach(pred => {
        const currentModule = ENVIRONMENT_MODULES[currentEnvironment];
        if (!currentModule.objects.includes(pred.class)) return;
        
        const [x, y, w, h] = pred.bbox;
        
        // é¸æ“‡é¡è‰²
        let color;
        if (pred.distance < 2) color = '#ff0000';
        else if (pred.distance < 4) color = '#ff9900';
        else color = '#00ff00';
        
        // ç¹ªè£½é‚Šæ¡†
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        // ç¹ªè£½æ¨™ç±¤
        const label = `${pred.class} ${pred.distance.toFixed(1)}m`;
        ctx.font = 'bold 14px Arial';
        const textWidth = ctx.measureText(label).width;
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y - 20, textWidth + 10, 20);
        
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 5, y - 5);
      });
    }

    // æ›´æ–°åµæ¸¬åˆ—è¡¨
    function updateDetectionList(predictions) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="detection-chip" style="text-align:center; color:var(--muted);">æœªåµæ¸¬åˆ°éšœç¤™ç‰©</div>';
        return;
      }
      
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        let chipClass = '';
        if (pred.distance < 2) chipClass = 'danger';
        else if (pred.distance < 4) chipClass = 'warning';
        
        return `
          <div class="detection-chip ${chipClass}">
            <strong>${pred.class}</strong><br>
            è·é›¢: ${pred.distance.toFixed(1)}å…¬å°º | ç½®ä¿¡åº¦: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    // FPS è¨ˆç®—
    function updateFPS(processingTime) {
      frameCount++;
      const now = performance.now();
      
      if (now - lastFpsTime >= 1000) {
        const fps = Math.round(frameCount * 1000 / (now - lastFpsTime));
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        lastFpsTime = now;
        
        if (debugMode) {
          updateDebugInfo(`FPS: ${fps}, è™•ç†æ™‚é–“: ${processingTime.toFixed(1)}ms`);
        }
      }
    }

    // å·¥å…·å‡½æ•¸
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      voiceAlert.classList.remove('loading');
      
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateGPSStatus(status) {
      document.getElementById('gpsStatus').textContent = status;
    }

    function updateDebugInfo(info) {
      if (debugMode) {
        document.getElementById('debugInfo').textContent = info;
      }
    }

    function showProgress(message, percent) {
      updateVoice(message);
      document.getElementById('progressBar').style.display = 'block';
      document.getElementById('progressFill').style.width = percent + '%';
    }

    function hideProgress() {
      document.getElementById('progressBar').style.display = 'none';
    }

    // ç’°å¢ƒåˆ‡æ›
    function loadEnvironmentModule() {
      const environments = Object.keys(ENVIRONMENT_MODULES);
      const currentIndex = environments.indexOf(currentEnvironment);
      const nextIndex = (currentIndex + 1) % environments.length;
      currentEnvironment = environments[nextIndex];
      
      const module = ENVIRONMENT_MODULES[currentEnvironment];
      document.getElementById('currentModule').textContent = module.name;
      document.getElementById('activeModuleTag').textContent = module.name;
      
      updateVoice(`åˆ‡æ›åˆ°${module.name}ç’°å¢ƒ`);
    }

    // ç·Šæ€¥æ±‚åŠ©
    function emergencyAlert() {
      const button = document.getElementById('btnEmergency');
      button.classList.add('emergency-alert');
      
      updateVoice('ç·Šæ€¥æ±‚åŠ©ï¼æ­£åœ¨ç™¼é€ä½ç½®è³‡è¨Šçµ¦ç·Šæ€¥è¯çµ¡äºº');
      
      if (gpsNavigator && gpsNavigator.currentPosition) {
        const { lat, lng } = gpsNavigator.currentPosition;
        console.log(`ç·Šæ€¥ä½ç½®ç™¼é€: ç·¯åº¦ ${lat.toFixed(6)}, ç¶“åº¦ ${lng.toFixed(6)}`);
      }
      
      setTimeout(() => {
        button.classList.remove('emergency-alert');
      }, 5000);
    }

    // äº‹ä»¶ç›£è½å™¨
    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnDebug').addEventListener('click', toggleDebug);
      document.getElementById('btnSetHome').addEventListener('click', () => gpsNavigator.setHomePosition());
      document.getElementById('btnReturnHome').addEventListener('click', () => gpsNavigator.startReturnHome());
      document.getElementById('btnLoadModule').addEventListener('click', loadEnvironmentModule);
      document.getElementById('btnEmergency').addEventListener('click', emergencyAlert);
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const status = document.getElementById('voiceStatus');
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        status.textContent = 'é–‹å•Ÿ';
        button.textContent = 'èªéŸ³é—œé–‰';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('èªéŸ³æç¤ºå·²é–‹å•Ÿ');
      } else {
        status.textContent = 'é—œé–‰';
        button.textContent = 'èªéŸ³é–‹å•Ÿ';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleDebug() {
      debugMode = !debugMode;
      const panel = document.getElementById('debugPanel');
      const button = document.getElementById('btnDebug');
      
      if (debugMode) {
        panel.style.display = 'block';
        button.textContent = 'éš±è—é™¤éŒ¯';
        updateDebugInfo('é™¤éŒ¯æ¨¡å¼å·²é–‹å•Ÿ');
      } else {
        panel.style.display = 'none';
        button.textContent = 'é¡¯ç¤ºé™¤éŒ¯';
      }
    }

    // åˆå§‹åŒ–æ‡‰ç”¨
    window.addEventListener('DOMContentLoaded', () => {
      initEventListeners();
      initModel();
    });
  </script>
</body>
</html>