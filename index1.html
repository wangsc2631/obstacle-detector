<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆªç³»çµ± - å³æ™‚éšœç¤™ç‰©æª¢æ¸¬èˆ‡GPSè¿”èˆª" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</title>
  
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    /* å®Œæ•´ CSS æ¨£å¼ */
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    header.card {
      padding: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: 20px;
      margin: 0;
      font-weight: 700;
    }
    
    .tips {
      font-size: 12px;
      color: var(--muted);
    }
    
    .camera-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .camera-container video, 
    .camera-container canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
      font-family: inherit;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .btn.primary {
      background: var(--good);
      color: #fff;
    }
    
    .btn.warning {
      background: var(--warn);
      color: #fff;
    }
    
    .btn.danger {
      background: var(--bad);
      color: #fff;
    }
    
    .btn.secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .value {
      font-weight: 800;
      font-size: 16px;
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .detection-list {
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding-right: 4px;
    }
    
    .detection-chip {
      background: var(--glass-strong);
      padding: 12px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
      border-left: 4px solid var(--good);
    }
    
    .detection-chip.warning {
      border-left-color: var(--warn);
    }
    
    .detection-chip.danger {
      border-left-color: var(--bad);
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .debug-panel {
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
      display: none;
    }
    
    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--glass-strong);
      border-radius: 3px;
      margin: 10px 0;
      overflow: hidden;
      display: none;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--good);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }

    /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
    @media (min-width: 768px) {
      .app {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-areas: 
          "header header"
          "camera sidebar"
          "controls sidebar"
          "status sidebar";
        gap: 12px;
      }
      
      header.card { grid-area: header; }
      .camera-container { grid-area: camera; }
      .panel:first-of-type { grid-area: controls; }
      .panel:last-of-type { grid-area: sidebar; }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- æ¨™é¡Œå€ -->
    <header class="card">
      <h1>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</h1>
      <div class="tips">å®‰å…¨å‡ºè¡Œ Â· éšœç¤™æª¢æ¸¬ Â· èªéŸ³å°èˆª</div>
    </header>

    <!-- ç›¸æ©Ÿå€ -->
    <section class="card camera-container">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
    </section>

    <!-- æ§åˆ¶å€ -->
    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">ç³»çµ±åˆå§‹åŒ–ä¸­â€¦</div>
      
      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      
      <div class="controls">
        <button id="btnStart" class="btn primary">é–‹å§‹æª¢æ¸¬</button>
        <button id="btnStop" class="btn danger" disabled>åœæ­¢æª¢æ¸¬</button>
        <button id="btnVoice" class="btn secondary">èªéŸ³é–‹å•Ÿ</button>
        <button id="btnDebug" class="btn warning">é¡¯ç¤ºé™¤éŒ¯</button>
      </div>

      <div class="status-grid">
        <div class="status-item">
          <div class="label">ç³»çµ±ç‹€æ…‹</div>
          <div class="value" id="status">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="label">åµæ¸¬é€Ÿåº¦</div>
          <div class="value" id="fps">â€”</div>
        </div>
        <div class="status-item">
          <div class="label">éšœç¤™ç‰©æ•¸</div>
          <div class="value" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="label">æœ€è¿‘è·é›¢</div>
          <div class="value" id="closestDistance">â€” å…¬å°º</div>
        </div>
      </div>

      <div id="debugPanel" class="debug-panel">
        <div><strong>é™¤éŒ¯è³‡è¨Š:</strong></div>
        <div id="debugInfo">ç­‰å¾…é–‹å§‹åµæ¸¬...</div>
      </div>
    </section>

    <!-- å´é‚Šæ¬„ -->
    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">å³æ™‚åµæ¸¬çµæœ</h3>
      <div id="detectionList" class="detection-list">
        <div class="detection-chip" style="text-align:center; color:var(--muted);">
          ç­‰å¾…é–‹å§‹åµæ¸¬â€¦
        </div>
      </div>
      <footer>
        å°ˆç‚ºè¦–éšœæœ‹å‹è¨­è¨ˆ Â· å®‰å…¨å‡ºè¡Œä¼´ä¾¶<br>
        è«‹åœ¨å…‰ç·šå……è¶³ç’°å¢ƒä½¿ç”¨
      </footer>
    </aside>
  </div>

  <script>
    // é…ç½®åƒæ•¸
    const CONFIG = {
      modelUrl: 'https://raw.githubusercontent.com/ultralytics/assets/main/yolov8n.onnx',
      inputSize: 640,
      scoreThreshold: 0.3,
      iouThreshold: 0.5,
      targetFPS: 8
    };

    // COCO é¡åˆ¥åç¨±
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light',
      'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
      'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee',
      'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle',
      'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange',
      'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed',
      'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven',
      'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    // é‡è¦éšœç¤™ç‰©é¡åˆ¥
    const IMPORTANT_CLASSES = [
      'person', 'car', 'motorcycle', 'bus', 'truck', 'bicycle', 
      'chair', 'bench', 'bed', 'couch', 'table'
    ];

    // å…¨å±€è®Šæ•¸
    let session = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let debugMode = false;
    let frameCount = 0;
    let lastFpsTime = 0;

    // åˆå§‹åŒ–æ¨¡å‹
    async function initModel() {
      try {
        showProgress('æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...', 0);
        
        ort.env.wasm.numThreads = 1;
        
        showProgress('ä¸‹è¼‰æ¨¡å‹ä¸­...', 30);
        updateDebugInfo('é–‹å§‹è¼‰å…¥ YOLOv8 æ¨¡å‹...');
        
        // ä½¿ç”¨æ›´å¯é çš„æ¨¡å‹ä¾†æº
        session = await ort.InferenceSession.create(CONFIG.modelUrl, {
          executionProviders: ['wasm']
        });
        
        showProgress('æ¨¡å‹åˆå§‹åŒ–å®Œæˆ', 100);
        updateDebugInfo(`æ¨¡å‹è¼‰å…¥æˆåŠŸï¼è¼¸å…¥: ${session.inputNames[0]}`);
        updateVoice('æ¨¡å‹è¼‰å…¥å®Œæˆï¼è«‹é»æ“Šé–‹å§‹æª¢æ¸¬');
        updateStatus('æº–å‚™å°±ç·’');
        
        setTimeout(() => {
          hideProgress();
        }, 1000);
        
      } catch (error) {
        console.error('æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
        updateDebugInfo(`éŒ¯èª¤: ${error.message}`);
        updateVoice('æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥');
        hideProgress();
      }
    }

    // è¨­å®šç›¸æ©Ÿ
    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        updateDebugInfo('è«‹æ±‚ç›¸æ©Ÿæ¬Šé™...');
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        });
        
        video.srcObject = stream;
        
        return new Promise((resolve, reject) => {
          video.onloadedmetadata = () => {
            video.play().then(() => {
              updateDebugInfo(`ç›¸æ©Ÿå°±ç·’: ${video.videoWidth}x${video.videoHeight}`);
              resolve(video);
            }).catch(reject);
          };
          video.onerror = reject;
        });
      } catch (error) {
        console.error('ç›¸æ©ŸéŒ¯èª¤:', error);
        updateDebugInfo(`ç›¸æ©ŸéŒ¯èª¤: ${error.message}`);
        updateVoice('ç„¡æ³•å­˜å–ç›¸æ©Ÿï¼Œè«‹ç¢ºèªæ¬Šé™è¨­å®š');
        return null;
      }
    }

    // é–‹å§‹æª¢æ¸¬
    async function startDetection() {
      if (!session) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆ');
        return;
      }

      updateDebugInfo('é–‹å§‹è¨­å®šç›¸æ©Ÿ...');
      const video = await setupCamera();
      if (!video) return;

      // å•Ÿç”¨æŒ‰éˆ•ç‹€æ…‹
      document.getElementById('btnStart').disabled = true;
      document.getElementById('btnStop').disabled = false;

      isDetecting = true;
      updateStatus('æª¢æ¸¬ä¸­');
      updateVoice('é–‹å§‹éšœç¤™ç‰©æª¢æ¸¬ï¼Œè«‹ç·©æ…¢ç§»å‹•è£ç½®');

      // é–‹å§‹æª¢æ¸¬å¾ªç’°
      detectionLoop(video);
    }

    // åœæ­¢æª¢æ¸¬
    function stopDetection() {
      isDetecting = false;
      updateStatus('å·²åœæ­¢');
      
      // æ¢å¾©æŒ‰éˆ•ç‹€æ…‹
      document.getElementById('btnStart').disabled = false;
      document.getElementById('btnStop').disabled = true;
      
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
        video.srcObject = null;
      }
      
      updateVoice('æª¢æ¸¬å·²åœæ­¢');
      updateDebugInfo('æª¢æ¸¬å·²åœæ­¢');
    }

    // ä¸»æª¢æ¸¬å¾ªç’°
    async function detectionLoop(video) {
      if (!isDetecting) return;

      const startTime = performance.now();

      try {
        // 1. æ•æ‰ç•«é¢
        const imageData = captureFrame(video);
        if (!imageData) {
          setTimeout(() => detectionLoop(video), 1000 / CONFIG.targetFPS);
          return;
        }

        // 2. é è™•ç†
        const inputTensor = preprocess(imageData);
        
        // 3. æ¨ç†
        const feeds = { [session.inputNames[0]]: inputTensor };
        const results = await session.run(feeds);
        
        // 4. å¾Œè™•ç†
        const predictions = postprocess(results, video.videoWidth, video.videoHeight);
        
        // 5. è™•ç†çµæœ
        processPredictions(predictions);
        
        // 6. ç¹ªè£½çµæœ
        drawPredictions(predictions, video);
        
        // æ›´æ–° FPS
        updateFPS(performance.now() - startTime);

      } catch (error) {
        console.error('æª¢æ¸¬éŒ¯èª¤:', error);
        updateDebugInfo(`æª¢æ¸¬éŒ¯èª¤: ${error.message}`);
      }

      // ç¹¼çºŒä¸‹ä¸€å¹€
      if (isDetecting) {
        setTimeout(() => detectionLoop(video), 1000 / CONFIG.targetFPS);
      }
    }

    // æ•æ‰ç•«é¢
    function captureFrame(video) {
      if (!video.videoWidth || !video.videoHeight) {
        return null;
      }

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      // æ­£å¸¸ç¹ªè£½ï¼Œä¸ç¿»è½‰
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    // é è™•ç†
    function preprocess(imageData) {
      const { data, width, height } = imageData;
      const input = new Float32Array(3 * CONFIG.inputSize * CONFIG.inputSize);
      
      const scale = Math.min(CONFIG.inputSize / width, CONFIG.inputSize / height);
      const scaledWidth = Math.floor(width * scale);
      const scaledHeight = Math.floor(height * scale);
      const xOffset = Math.floor((CONFIG.inputSize - scaledWidth) / 2);
      const yOffset = Math.floor((CONFIG.inputSize - scaledHeight) / 2);
      
      // å¡«å……é»‘è‰²èƒŒæ™¯
      for (let i = 0; i < input.length; i++) {
        input[i] = 0.0;
      }
      
      // å¡«å……å½±åƒæ•¸æ“š
      for (let c = 0; c < 3; c++) {
        for (let h = 0; h < scaledHeight; h++) {
          for (let w = 0; w < scaledWidth; w++) {
            const srcX = Math.floor(w / scale);
            const srcY = Math.floor(h / scale);
            const srcIndex = (srcY * width + srcX) * 4;
            
            const pixelValue = data[srcIndex + c] / 255.0;
            const dstIndex = c * CONFIG.inputSize * CONFIG.inputSize + 
                            (h + yOffset) * CONFIG.inputSize + 
                            (w + xOffset);
            input[dstIndex] = pixelValue;
          }
        }
      }
      
      return new ort.Tensor('float32', input, [1, 3, CONFIG.inputSize, CONFIG.inputSize]);
    }

    // å¾Œè™•ç†
    function postprocess(results, originalWidth, originalHeight) {
      const predictions = [];
      const output = results[session.outputNames[0]];
      
      if (!output || !output.data) {
        return predictions;
      }

      const outputData = output.data;
      const numDetections = output.dims[1];
      const numClasses = output.dims[2] - 4;

      for (let i = 0; i < numDetections; i++) {
        const offset = i * (numClasses + 4);
        const [x, y, w, h, ...scores] = Array.from(outputData.slice(offset, offset + numClasses + 4));
        
        const maxScore = Math.max(...scores);
        const classId = scores.indexOf(maxScore);

        if (maxScore > CONFIG.scoreThreshold && classId < CLASS_NAMES.length) {
          // è½‰æ›åº§æ¨™å›åŸåœ–å°ºå¯¸
          const scale = Math.min(CONFIG.inputSize / originalWidth, CONFIG.inputSize / originalHeight);
          const scaledWidth = originalWidth * scale;
          const scaledHeight = originalHeight * scale;
          const xOffset = (CONFIG.inputSize - scaledWidth) / 2;
          const yOffset = (CONFIG.inputSize - scaledHeight) / 2;
          
          const bbox = [
            (x - xOffset - w/2) / scale,
            (y - yOffset - h/2) / scale,
            w / scale,
            h / scale
          ];

          // ç¢ºä¿åº§æ¨™åœ¨åˆç†ç¯„åœå…§
          if (bbox[0] >= 0 && bbox[1] >= 0 && bbox[2] > 10 && bbox[3] > 10) {
            predictions.push({
              class: CLASS_NAMES[classId],
              score: maxScore,
              bbox: bbox,
              distance: estimateDistance(bbox[2], bbox[3], CLASS_NAMES[classId])
            });
          }
        }
      }

      return nonMaxSuppression(predictions, CONFIG.iouThreshold);
    }

    // éæ¥µå¤§å€¼æŠ‘åˆ¶
    function nonMaxSuppression(predictions, iouThreshold) {
      if (predictions.length === 0) return predictions;
      
      predictions.sort((a, b) => b.score - a.score);
      const selected = [];

      while (predictions.length > 0) {
        const current = predictions[0];
        selected.push(current);

        predictions = predictions.slice(1).filter(pred => {
          return calculateIOU(current.bbox, pred.bbox) < iouThreshold;
        });
      }

      return selected;
    }

    // è¨ˆç®— IoU
    function calculateIOU(box1, box2) {
      const [x1, y1, w1, h1] = box1;
      const [x2, y2, w2, h2] = box2;

      const xLeft = Math.max(x1, x2);
      const yTop = Math.max(y1, y2);
      const xRight = Math.min(x1 + w1, x2 + w2);
      const yBottom = Math.min(y1 + h1, y2 + h2);

      if (xRight < xLeft || yBottom < yTop) return 0.0;

      const intersectionArea = (xRight - xLeft) * (yBottom - yTop);
      const box1Area = w1 * h1;
      const box2Area = w2 * h2;

      return intersectionArea / (box1Area + box2Area - intersectionArea);
    }

    // ä¼°ç®—è·é›¢
    function estimateDistance(width, height, className) {
      const area = width * height;
      let referenceArea = 10000;

      if (className === 'person') referenceArea = 8000;
      else if (className === 'car') referenceArea = 30000;
      else if (className === 'chair') referenceArea = 5000;

      const distance = Math.sqrt(referenceArea / area) * 3;
      return Math.min(Math.max(distance, 0.5), 20);
    }

    // è™•ç†é æ¸¬çµæœ
    function processPredictions(predictions) {
      const obstacles = predictions.filter(p => IMPORTANT_CLASSES.includes(p.class));
      const obstacleCount = obstacles.length;
      
      document.getElementById('obstacleCount').textContent = obstacleCount;
      updateDebugInfo(`æª¢æ¸¬åˆ° ${predictions.length} å€‹ç‰©é«”ï¼Œ${obstacleCount} å€‹éšœç¤™ç‰©`);

      // æ‰¾åˆ°æœ€è¿‘éšœç¤™ç‰©
      let closestDistance = Infinity;
      let closestObstacle = null;

      obstacles.forEach(obstacle => {
        if (obstacle.distance < closestDistance) {
          closestDistance = obstacle.distance;
          closestObstacle = obstacle;
        }
      });

      // æ›´æ–°é¡¯ç¤º
      const distanceElement = document.getElementById('closestDistance');
      if (closestObstacle) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' å…¬å°º';
        
        // èªéŸ³è­¦å‘Š
        if (voiceEnabled && closestDistance < 5) {
          const now = Date.now();
          if (now - lastSpeechTime > 3000) {
            let message = `å‰æ–¹${closestDistance.toFixed(1)}å…¬å°ºæœ‰${closestObstacle.class}`;
            if (closestDistance < 2) message = `è­¦å‘Šï¼${message}ï¼Œè«‹å°å¿ƒ`;
            else if (closestDistance < 3) message = `æ³¨æ„ï¼${message}`;
            updateVoice(message);
            lastSpeechTime = now;
          }
        }
      } else {
        distanceElement.textContent = 'â€” å…¬å°º';
      }

      updateDetectionList(obstacles);
    }

    let lastSpeechTime = 0;

    // ç¹ªè£½æª¢æ¸¬çµæœ
    function drawPredictions(predictions, video) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      predictions.forEach(pred => {
        if (!IMPORTANT_CLASSES.includes(pred.class)) return;
        
        const [x, y, w, h] = pred.bbox;
        
        // é¸æ“‡é¡è‰²
        let color;
        if (pred.distance < 2) color = '#ff0000';
        else if (pred.distance < 4) color = '#ff9900';
        else color = '#00ff00';
        
        // ç¹ªè£½é‚Šæ¡†
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        // ç¹ªè£½æ¨™ç±¤
        const label = `${pred.class} ${pred.distance.toFixed(1)}m`;
        ctx.font = 'bold 14px Arial';
        const textWidth = ctx.measureText(label).width;
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y - 20, textWidth + 10, 20);
        
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 5, y - 5);
      });
    }

    // æ›´æ–°åµæ¸¬åˆ—è¡¨
    function updateDetectionList(predictions) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="detection-chip" style="text-align:center; color:var(--muted);">æœªåµæ¸¬åˆ°éšœç¤™ç‰©</div>';
        return;
      }
      
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        let chipClass = '';
        if (pred.distance < 2) chipClass = 'danger';
        else if (pred.distance < 4) chipClass = 'warning';
        
        return `
          <div class="detection-chip ${chipClass}">
            <strong>${pred.class}</strong><br>
            è·é›¢: ${pred.distance.toFixed(1)}å…¬å°º | ç½®ä¿¡åº¦: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    // FPS è¨ˆç®—
    function updateFPS(processingTime) {
      frameCount++;
      const now = performance.now();
      
      if (now - lastFpsTime >= 1000) {
        const fps = Math.round(frameCount * 1000 / (now - lastFpsTime));
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        lastFpsTime = now;
        
        if (debugMode) {
          updateDebugInfo(`FPS: ${fps}, è™•ç†æ™‚é–“: ${processingTime.toFixed(1)}ms`);
        }
      }
    }

    // å·¥å…·å‡½æ•¸
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      voiceAlert.classList.remove('loading');
      
      if (voiceEnabled && window.speechSynthesis) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateDebugInfo(info) {
      if (debugMode) {
        document.getElementById('debugInfo').textContent = info;
      }
    }

    function showProgress(message, percent) {
      updateVoice(message);
      document.getElementById('progressBar').style.display = 'block';
      document.getElementById('progressFill').style.width = percent + '%';
    }

    function hideProgress() {
      document.getElementById('progressBar').style.display = 'none';
    }

    // äº‹ä»¶ç›£è½å™¨
    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnDebug').addEventListener('click', toggleDebug);
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        button.textContent = 'èªéŸ³é—œé–‰';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('èªéŸ³æç¤ºå·²é–‹å•Ÿ');
      } else {
        button.textContent = 'èªéŸ³é–‹å•Ÿ';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleDebug() {
      debugMode = !debugMode;
      const panel = document.getElementById('debugPanel');
      const button = document.getElementById('btnDebug');
      
      if (debugMode) {
        panel.style.display = 'block';
        button.textContent = 'éš±è—é™¤éŒ¯';
        updateDebugInfo('é™¤éŒ¯æ¨¡å¼å·²é–‹å•Ÿ');
      } else {
        panel.style.display = 'none';
        button.textContent = 'é¡¯ç¤ºé™¤éŒ¯';
      }
    }

    // åˆå§‹åŒ–æ‡‰ç”¨
    window.addEventListener('DOMContentLoaded', () => {
      initEventListeners();
      initModel();
    });
  </script>
</body>
</html>