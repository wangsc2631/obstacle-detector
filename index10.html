<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>æ¼¢ä¾†å³¶èª - å™¨çš¿è¦–è¦ºç›¤é»ç³»çµ±</title>
  <style>
    /* é€™è£¡æ‚¨å¯ä»¥ä¿ç•™æ‚¨åŸæœ‰çš„æ‰€æœ‰ CSS æ¨£å¼ */
    /* ä»¥ä¸‹æ˜¯åŸºç¤æ¨£å¼ï¼Œæ‚¨å¯ä»¥æ ¹æ“šéœ€æ±‚ä¿®æ”¹ */
    body {
      font-family: 'Microsoft JhengHei', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #f0f0f0, #ffffff);
      margin: 0;
      padding: 0;
      color: #333;
      min-height: 100vh;
    }
    .container {
      width: 95%;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background-color: white;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      border-radius: 12px;
      margin-top: 20px;
    }
    #videoCanvas, #overlayCanvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      background: #000;
    }
    .status-bar {
      margin-top: 15px;
      padding: 10px;
      background-color: #e3f2fd;
      border-radius: 6px;
      font-size: 1.1em;
      color: #1565c0;
    }
    .results-table {
      width: 100%;
      margin-top: 20px;
      border-collapse: collapse;
      text-align: left;
      font-size: 0.9em;
    }
    .results-table th, .results-table td {
      padding: 8px;
      border: 1px solid #ddd;
    }
    .results-table th {
      background-color: #f5f5f5;
    }
    .clear-btn {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1em;
    }
    .clear-btn:hover {
      background-color: #d32f2f;
    }
  </style>
</head>
<body>

  <div class="container">
    <h1>å™¨çš¿è¦–è¦ºç›¤é»ç³»çµ±</h1>

    <div style="position: relative;">
      <video id="videoCanvas" playsinline autoplay muted></video>
      <canvas id="overlayCanvas" style="position: absolute; top: 0; left: 0;"></canvas>
    </div>

    <div id="statusInfo" class="status-bar">æ­£åœ¨åˆå§‹åŒ–...</div>

    <h2>ç›¤é»çµæœ</h2>
    <table class="results-table">
      <thead>
        <tr>
          <th>æ–™ä»¶ç·¨è™Ÿ (å“å)</th>
          <th>æ•¸é‡</th>
        </tr>
      </thead>
      <tbody id="resultsTableBody">
        <tr><td colspan="2">å°šæœªåµæ¸¬åˆ°å™¨çš¿</td></tr>
      </tbody>
    </table>

    <button class="clear-btn" onclick="clearResults()">æ¸…é™¤ç›¤é»çµæœ</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <script>
    // --- YOLOv8 å°ˆç”¨è¨­å®š (å„ªåŒ–é…ç½®) ---
    const MODEL_INPUT_SIZE = 640;
    const CONF_THRESHOLD = 0.2; // åµæ¸¬éˆæ•åº¦
    const IOU_THRESHOLD = 0.45; 
    const DETECTION_INTERVAL = 500; // æ¯ 0.5 ç§’åµæ¸¬ä¸€æ¬¡
    
    let yoloDetector;
    let videoCanvas = document.getElementById('videoCanvas');
    let overlayCanvas = document.getElementById('overlayCanvas');
    let ctx = overlayCanvas.getContext('2d');
    let statusInfo = document.getElementById('statusInfo');
    let resultsTableBody = document.getElementById('resultsTableBody');
    let transaction = {}; // ç›¤é»çµæœå„²å­˜ { item_id: count }
    let isDetecting = false;
    let lastDetectionTime = 0;
    let animationFrameId = null; // ç”¨ä¾†æ§åˆ¶ requestAnimationFrame çš„ ID

    // --- COCO é¡åˆ¥å°æ‡‰åˆ° æ–™ä»¶ç·¨è™Ÿ (æ ¹æ“šæ‚¨æä¾›çš„æ¸…å–®å„ªåŒ–) ---
    const COCO_TO_ITEM_ID = {
      // æ‰˜ç›¤
      'tray': '160100000126',      // æ­¢æ»‘åœ“æ‰˜ç›¤16å‹
      
      // ç¢Ÿ/ç›¤/ç¢—
      'bowl': '160101000599',       // é£¯ç¢—(è©©ç¾…æ©)
      'plate': '160101000539',      // CLASSICåœ“é¤ç›¤
      'cup': '160104000052',        // å’–å•¡æ¯/é’æ‰è—
      'wine glass': '160200000308', // VINOç´…é…’æ¯(Ocean)
      'bottle': '160200000095',      // (æš«å®š)æœæ±å£º/è€ç†±å£º
      
      // é¤å…·
      'knife': '160306000275',      // Arthur Kruppä¸»é¤åˆ€
      'fork': '160306000276',       // Arthur Kruppä¸»é¤å‰
      'spoon': '160306000280',      // Arthur Kruppåœ“æ¹¯åŒ™
      
      // å…¶ä»– (é€šç”¨COCOé¡åˆ¥)
      'remote': '160400000001',      // é™æ§å™¨
      'cell phone': '160400000002',  // æ‰‹æ©Ÿ
      'person': 'IGNORE',            // å¿½ç•¥äººç‰©åµæ¸¬
    };
    
    // --- å“å/è¦æ ¼ å°æ‡‰è¡¨ (ç”¨æ–¼é¡¯ç¤ºåœ¨è¡¨æ ¼ä¸­) ---
    const ITEM_ID_TO_NAME = {
      '160100000126': 'æ­¢æ»‘åœ“æ‰˜ç›¤16å‹',
      '160101000599': 'é£¯ç¢—(è©©ç¾…æ©)/12cm',
      '160101000539': 'CLASSICåœ“é¤ç›¤',
      '160104000052': 'å’–å•¡æ¯/é’æ‰è—',
      '160200000308': 'VINOç´…é…’æ¯(Ocean)',
      '160200000095': 'æœæ±å£º/è€ç†±å£º',
      '160306000275': 'Arthur Kruppä¸»é¤åˆ€',
      '160306000276': 'Arthur Kruppä¸»é¤å‰',
      '160306000280': 'Arthur Kruppåœ“æ¹¯åŒ™',
      '160400000001': 'é™æ§å™¨',
      '160400000002': 'æ‰‹æ©Ÿ',
      'IGNORE': 'å¿½ç•¥ (äººç‰©)',
    };


    // --- ç›¤é»çµæœè™•ç†å‡½å¼ (ä¿æŒä¸è®Š) ---
    function updateResults(detections) {
      if (detections.length === 0) {
        return;
      }

      let newTransaction = {};
      detections.forEach(detection => {
        const cocoClass = detection.class;
        const itemId = COCO_TO_ITEM_ID[cocoClass]; 

        if (itemId && itemId !== 'IGNORE') {
          newTransaction[itemId] = (newTransaction[itemId] || 0) + 1;
        }
      });
      
      transaction = newTransaction;
      renderResultsTable();
    }

    function renderResultsTable() {
      if (Object.keys(transaction).length === 0) {
        resultsTableBody.innerHTML = '<tr><td colspan="2">å°šæœªåµæ¸¬åˆ°å™¨çš¿</td></tr>';
        return;
      }

      let html = '';
      for (const itemId in transaction) {
        const name = ITEM_ID_TO_NAME[itemId] || `æœªçŸ¥å“é … (${itemId})`;
        const count = transaction[itemId];
        html += `
          <tr>
            <td>${itemId} (${name})</td>
            <td>${count}</td>
          </tr>
        `;
      }
      resultsTableBody.innerHTML = html;
    }

    function clearResults() {
      transaction = {};
      renderResultsTable();
      statusInfo.textContent = 'ç›¤é»çµæœå·²æ¸…é™¤ã€‚';
    }


    // --- YOLOv8 åµæ¸¬é¡åˆ¥ (ä¿æŒä¸è®Š) ---
    class YOLOv8Detector {
      // ... (YOLOv8Detector é¡åˆ¥å…§å®¹ä¸è®Š)
      constructor(modelPath) {
        this.modelPath = modelPath;
        this.session = null;
        this.cocoLabels = [ /* COCO 80 å€‹é¡åˆ¥ */
            "person", "bicycle", "car", "motorcycle", "airplane", "bus", "train", "truck", "boat", "traffic light",
            "fire hydrant", "stop sign", "parking meter", "bench", "bird", "cat", "dog", "horse", "sheep", "cow",
            "elephant", "bear", "zebra", "giraffe", "backpack", "umbrella", "handbag", "tie", "suitcase", "frisbee",
            "skis", "snowboard", "sports ball", "kite", "baseball bat", "baseball glove", "skateboard", "surfboard",
            "tennis racket", "bottle", "wine glass", "cup", "fork", "knife", "spoon", "bowl", "banana", "apple",
            "sandwich", "orange", "broccoli", "carrot", "hot dog", "pizza", "donut", "cake", "chair", "couch",
            "potted plant", "bed", "dining table", "toilet", "tv", "laptop", "mouse", "remote", "keyboard", "cell phone",
            "microwave", "oven", "toaster", "sink", "refrigerator", "book", "clock", "vase", "scissors", "teddy bear",
            "hair drier", "toothbrush"
        ];
      }

      async loadModel() {
        statusInfo.textContent = `è¼‰å…¥ AI æ¨¡å‹ä¸­... (æ­£åœ¨ä¸‹è¼‰ 42.8 MB æ¨¡å‹)`;
        try {
            this.session = await ort.InferenceSession.create(this.modelPath, {
                executionProviders: ['wasm'], 
                graphOptimizationLevel: 'all',
                logLevel: 'error'
            });

            statusInfo.textContent = 'âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸï¼æ­£åœ¨é–‹å•Ÿé¡é ­...';
            return true;

        } catch (error) {
            console.error('æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
            statusInfo.textContent = `âŒ YOLOv8 æ¨¡å‹è¼‰å…¥å¤±æ•—: ${error.message}. è«‹ç¢ºèªæ¨¡å‹ç›´éˆå¯è¨ªå•ã€‚`;
            return false;
        }
      }

      async preprocess(source) {
        let tensor = tf.browser.fromPixels(source);
        let [h, w] = tensor.shape;
        const resizeRatio = Math.min(MODEL_INPUT_SIZE / h, MODEL_INPUT_SIZE / w);

        const targetW = Math.round(w * resizeRatio);
        const targetH = Math.round(h * resizeRatio);
        
        tensor = tf.image.resizeBilinear(tensor, [targetH, targetW]);
        
        const paddingW = MODEL_INPUT_SIZE - targetW;
        const paddingH = MODEL_INPUT_SIZE - targetH;
        
        tensor = tf.pad(tensor, [
          [0, paddingH], [0, paddingW], [0, 0]
        ], 0);

        tensor = tensor.div(255.0);
        tensor = tensor.transpose([2, 0, 1]);
        tensor = tensor.expandDims(0);

        const inputData = new Float32Array(tensor.dataSync());
        tf.dispose(tensor);

        return { 
          inputTensor: new ort.Tensor('float32', inputData, [1, 3, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]),
          ratio: resizeRatio,
          sourceWidth: w,
          sourceHeight: h
        };
      }

      async detect(source) {
        if (!this.session) return [];

        const { inputTensor, ratio, sourceWidth, sourceHeight } = await this.preprocess(source);
        
        const feeds = { 'images': inputTensor };
        const results = await this.session.run(feeds);
        
        const outputTensor = results.output0.data;

        return this.postprocess(outputTensor, ratio, sourceWidth, sourceHeight);
      }

      postprocess(outputData, ratio, sourceWidth, sourceHeight) {
        const [numClasses, numBoxes] = [this.cocoLabels.length, 8400];
        const boxSize = 4 + numClasses;
        
        let boxes = [];
        for (let i = 0; i < numBoxes; i++) {
          let boxData = outputData.slice(i * boxSize, (i + 1) * boxSize);
          
          let scores = boxData.slice(4, 4 + numClasses);
          let maxScore = Math.max(...scores);
          
          if (maxScore > CONF_THRESHOLD) {
            let classId = scores.indexOf(maxScore);
            
            let x = boxData[0];
            let y = boxData[1];
            let w = boxData[2];
            let h = boxData[3];
            
            let xmin = (x - w / 2) / ratio;
            let ymin = (y - h / 2) / ratio;
            let xmax = (x + w / 2) / ratio;
            let ymax = (y + h / 2) / ratio;

            xmin = Math.max(0, xmin);
            ymin = Math.max(0, ymin);
            xmax = Math.min(sourceWidth, xmax);
            ymax = Math.min(sourceHeight, ymax);

            boxes.push({
              xmin: xmin,
              ymin: ymin,
              xmax: xmax,
              ymax: ymax,
              score: maxScore,
              classId: classId,
              class: this.cocoLabels[classId]
            });
          }
        }
        
        return this.nonMaxSuppression(boxes);
      }

      nonMaxSuppression(boxes) {
        if (boxes.length === 0) return [];

        const sortedBoxes = boxes.sort((a, b) => b.score - a.score);
        const selected = [];

        while (sortedBoxes.length > 0) {
          const first = sortedBoxes[0];
          selected.push(first);
          
          const iouFilter = sortedBoxes.slice(1).filter(box => {
            const iou = this.intersectionOverUnion(first, box);
            return iou < IOU_THRESHOLD || first.classId !== box.classId; 
          });

          sortedBoxes.splice(0, sortedBoxes.length, ...iouFilter);
        }

        return selected;
      }

      intersectionOverUnion(box1, box2) {
        const xA = Math.max(box1.xmin, box2.xmin);
        const yA = Math.max(box1.ymin, box2.ymin);
        const xB = Math.min(box1.xmax, box2.xmax);
        const yB = Math.min(box1.ymax, box2.ymax);

        const intersection = Math.max(0, xB - xA) * Math.max(0, yB - yA);
        
        const area1 = (box1.xmax - box1.xmin) * (box1.ymax - box1.ymin);
        const area2 = (box2.xmax - box2.xmin) * (box2.ymax - box2.ymin);
        
        if (area1 <= 0 || area2 <= 0) return 0;

        return intersection / (area1 + area2 - intersection);
      }
    }


    // --- æ”å½±æ©Ÿè¨­å®šèˆ‡å¹€åµæ¸¬ ---

    async function setupCamera() {
      // å„ªå…ˆå˜—è©¦å¾Œç½®é¡é ­
      const constraintsEnv = {
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 640 },
          height: { ideal: 480 }
        }
      };

      // å‚™ç”¨ï¼šå˜—è©¦ä»»æ„é¡é ­
      const constraintsAny = {
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 }
        }
      };

      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia(constraintsEnv);
      } catch (err) {
        console.warn("å¾Œç½®é¡é ­è«‹æ±‚å¤±æ•—ï¼Œå˜—è©¦ä»»æ„é¡é ­:", err);
        try {
          stream = await navigator.mediaDevices.getUserMedia(constraintsAny);
        } catch (err2) {
          // æœ€çµ‚å¤±æ•—
          console.error("ç„¡æ³•é–‹å•Ÿä»»ä½•é¡é ­:", err2);
          statusInfo.textContent = 'âŒ ç„¡æ³•é–‹å•Ÿé¡é ­ï¼Œè«‹æª¢æŸ¥æ¬Šé™æˆ–è¨­å‚™ã€‚éŒ¯èª¤ï¼š' + err2.name;
          // **[ä¿®å¾©é»ä¸‰]ï¼šç›¸æ©Ÿå•Ÿå‹•å¤±æ•—æ™‚ï¼Œç¢ºä¿ animationFrameId æ­¸é›¶ï¼Œé˜»æ­¢ detectFrame éè¿´**
          if (animationFrameId) {
             cancelAnimationFrame(animationFrameId);
             animationFrameId = null;
          }
          return; 
        }
      }

      // é¡é ­å•Ÿå‹•æˆåŠŸ
      videoCanvas.srcObject = stream;
      videoCanvas.onloadedmetadata = () => {
        videoCanvas.play();
        overlayCanvas.width = videoCanvas.videoWidth;
        overlayCanvas.height = videoCanvas.videoHeight;
        statusInfo.textContent = 'ğŸ¥ é¡é ­é–‹å•ŸæˆåŠŸï¼é–‹å§‹åµæ¸¬å™¨çš¿...';
        
        // åªæœ‰é¡é ­æˆåŠŸé–‹å•Ÿå¾Œæ‰å•Ÿå‹•åµæ¸¬è¿´åœˆ
        if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(detectFrame);
        }
      };
    }

    async function detectFrame(now) {
      // **[ä¿®å¾©é»å››]ï¼šç¢ºä¿æœ‰æœ‰æ•ˆçš„å½±åƒä¸²æµ**
      if (isDetecting || !yoloDetector || !videoCanvas.srcObject || videoCanvas.videoWidth === 0) {
        // å¦‚æœæ²’æœ‰æœ‰æ•ˆçš„è¦–é »æµï¼Œæ¸…ç©ºç•«å¸ƒï¼Œé¿å…é¡¯ç¤ºèˆŠçš„ç´…æ¡†
        if (!videoCanvas.srcObject || videoCanvas.videoWidth === 0) {
           ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); 
           transaction = {}; // æ¸…ç©ºèª¤å ±çµæœ
           renderResultsTable();
        }
        animationFrameId = requestAnimationFrame(detectFrame);
        return;
      }
      
      // æ§åˆ¶åµæ¸¬é »ç‡
      if (now - lastDetectionTime < DETECTION_INTERVAL) {
        animationFrameId = requestAnimationFrame(detectFrame);
        return;
      }
      lastDetectionTime = now;
      
      isDetecting = true;
      try {
        const detections = await yoloDetector.detect(videoCanvas);
        
        updateResults(detections); 
        drawBoundingBoxes(detections);
        
      } catch (error) {
        console.error('YOLOv8 åµæ¸¬éŒ¯èª¤:', error);
        statusInfo.textContent = 'YOLOv8 åµæ¸¬éŒ¯èª¤';
      }

      isDetecting = false;
      animationFrameId = requestAnimationFrame(detectFrame);
    }

    function drawBoundingBoxes(detections) {
      // ... (ç¹ªè£½é‚è¼¯ä¿æŒä¸è®Š)
      ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      ctx.strokeStyle = '#FF0000';
      ctx.lineWidth = 3;
      ctx.font = '16px Arial';
      ctx.fillStyle = '#FF0000';

      detections.forEach(detection => {
        const x = detection.xmin;
        const y = detection.ymin;
        const w = detection.xmax - detection.xmin;
        const h = detection.ymax - detection.ymin;
        
        const itemId = COCO_TO_ITEM_ID[detection.class];
        const name = ITEM_ID_TO_NAME[itemId] || detection.class;
        
        if (itemId === 'IGNORE') return; // å¿½ç•¥äººç‰©åµæ¸¬

        // ç¹ªè£½é‚Šç•Œæ¡†
        ctx.beginPath();
        ctx.rect(x, y, w, h);
        ctx.stroke();

        // ç¹ªè£½æ¨™ç±¤
        const label = `${name} (${(detection.score * 100).toFixed(1)}%)`;
        ctx.fillText(label, x, y > 20 ? y - 5 : y + 15);
      });
    }

    // --- å•Ÿå‹•å‡½å¼ ---

    async function loadModel() {
      // *** ä½¿ç”¨æ‚¨æä¾›çš„ Hugging Face ç›´éˆ (FP32 æ¨¡å‹) ***
      const HF_MODEL_URL = 'https://huggingface.co/wang2631/YOLOv8s-web-deployment/resolve/main/yolov8s.onnx';
      
      try {
        yoloDetector = new YOLOv8Detector(HF_MODEL_URL); 
        
        const success = await yoloDetector.loadModel();
        
        if (success) {
            setupCamera();
        } 

      } catch (error) {
        console.error('ç³»çµ±å•Ÿå‹•å¤±æ•—:', error);
        statusInfo.textContent = 'ç³»çµ±å•Ÿå‹•å¤±æ•—ï¼Œè«‹æª¢æŸ¥ä¸»æ§å°';
      }
    }

    // å•Ÿå‹•æ‡‰ç”¨
    window.onload = loadModel;
  </script>

</body>
</html>