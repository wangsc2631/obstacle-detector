<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>æ¼¢ä¾†å³¶èª - å™¨çš¿è¦–è¦ºç›¤é»ç³»çµ±</title>
  <style>
    /* é€™è£¡æ‚¨å¯ä»¥ä¿ç•™æ‚¨åŸæœ‰çš„æ‰€æœ‰ CSS æ¨£å¼ */
    /* ä»¥ä¸‹æ˜¯åŸºç¤æ¨£å¼ï¼Œæ‚¨å¯ä»¥æ ¹æ“šéœ€æ±‚ä¿®æ”¹ */
    body {
      font-family: 'Microsoft JhengHei', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #f0f0f0, #ffffff);
      margin: 0;
      padding: 0;
      color: #333;
      min-height: 100vh;
    }
    .container {
      width: 95%;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background-color: white;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      border-radius: 12px;
      margin-top: 20px;
    }
    #videoCanvas, #overlayCanvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      background: #000;
    }
    .status-bar {
      margin-top: 15px;
      padding: 10px;
      background-color: #e3f2fd;
      border-radius: 6px;
      font-size: 1.1em;
      color: #1565c0;
    }
    .results-table {
      width: 100%;
      margin-top: 20px;
      border-collapse: collapse;
      text-align: left;
      font-size: 0.9em;
    }
    .results-table th, .results-table td {
      padding: 8px;
      border: 1px solid #ddd;
    }
    .results-table th {
      background-color: #f5f5f5;
    }
    .clear-btn {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1em;
    }
    .clear-btn:hover {
      background-color: #d32f2f;
    }
  </style>
</head>
<body>

  <div class="container">
    <h1>å™¨çš¿è¦–è¦ºç›¤é»ç³»çµ±</h1>

    <div style="position: relative;">
      <video id="videoCanvas" playsinline autoplay muted></video>
      <canvas id="overlayCanvas" style="position: absolute; top: 0; left: 0;"></canvas>
    </div>

    <div id="statusInfo" class="status-bar">æ­£åœ¨åˆå§‹åŒ–...</div>

    <h2>ç›¤é»çµæœ</h2>
    <table class="results-table">
      <thead>
        <tr>
          <th>æ–™ä»¶ç·¨è™Ÿ (å“å)</th>
          <th>æ•¸é‡</th>
        </tr>
      </thead>
      <tbody id="resultsTableBody">
        <tr><td colspan="2">å°šæœªåµæ¸¬åˆ°å™¨çš¿</td></tr>
      </tbody>
    </table>

    <button class="clear-btn" onclick="clearResults()">æ¸…é™¤ç›¤é»çµæœ</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <script>
    // --- YOLOv8 å°ˆç”¨è¨­å®š (å„ªåŒ–é…ç½®) ---
    const MODEL_INPUT_SIZE = 640;
    const CONF_THRESHOLD = 0.2; // åµæ¸¬éˆæ•åº¦
    const IOU_THRESHOLD = 0.45; 
    const DETECTION_INTERVAL = 500; // æ¯ 0.5 ç§’åµæ¸¬ä¸€æ¬¡
    
    let yoloDetector;
    let videoCanvas = document.getElementById('videoCanvas');
    let overlayCanvas = document.getElementById('overlayCanvas');
    let ctx = overlayCanvas.getContext('2d');
    let statusInfo = document.getElementById('statusInfo');
    let resultsTableBody = document.getElementById('resultsTableBody');
    let transaction = {}; // ç›¤é»çµæœå„²å­˜ { item_id: count }
    let isDetecting = false;
    let lastDetectionTime = 0;

    // --- COCO é¡åˆ¥å°æ‡‰åˆ° æ–™ä»¶ç·¨è™Ÿ (æ ¹æ“šæ‚¨æä¾›çš„æ¸…å–®å„ªåŒ–) ---
    const COCO_TO_ITEM_ID = {
      // æ‰˜ç›¤
      'tray': '160100000126',      // æ­¢æ»‘åœ“æ‰˜ç›¤16å‹
      
      // ç¢Ÿ/ç›¤/ç¢—
      'bowl': '160101000599',       // é£¯ç¢—(è©©ç¾…æ©)
      'plate': '160101000539',      // CLASSICåœ“é¤ç›¤
      'cup': '160104000052',        // å’–å•¡æ¯/é’æ‰è—
      'wine glass': '160200000308', // VINOç´…é…’æ¯(Ocean)
      'bottle': '160200000095',      // (æš«å®š)æœæ±å£º/è€ç†±å£º
      
      // é¤å…·
      'knife': '160306000275',      // Arthur Kruppä¸»é¤åˆ€
      'fork': '160306000276',       // Arthur Kruppä¸»é¤å‰
      'spoon': '160306000280',      // Arthur Kruppåœ“æ¹¯åŒ™
      
      // å…¶ä»– (é€šç”¨COCOé¡åˆ¥)
      'remote': '160400000001',      // é™æ§å™¨
      'cell phone': '160400000002',  // æ‰‹æ©Ÿ
      'person': 'IGNORE',            // å¿½ç•¥äººç‰©åµæ¸¬
    };
    
    // --- å“å/è¦æ ¼ å°æ‡‰è¡¨ (ç”¨æ–¼é¡¯ç¤ºåœ¨è¡¨æ ¼ä¸­) ---
    const ITEM_ID_TO_NAME = {
      '160100000126': 'æ­¢æ»‘åœ“æ‰˜ç›¤16å‹',
      '160101000599': 'é£¯ç¢—(è©©ç¾…æ©)/12cm',
      '160101000539': 'CLASSICåœ“é¤ç›¤',
      '160104000052': 'å’–å•¡æ¯/é’æ‰è—',
      '160200000308': 'VINOç´…é…’æ¯(Ocean)',
      '160200000095': 'æœæ±å£º/è€ç†±å£º',
      '160306000275': 'Arthur Kruppä¸»é¤åˆ€',
      '160306000276': 'Arthur Kruppä¸»é¤å‰',
      '160306000280': 'Arthur Kruppåœ“æ¹¯åŒ™',
      '160400000001': 'é™æ§å™¨',
      '160400000002': 'æ‰‹æ©Ÿ',
      'IGNORE': 'å¿½ç•¥ (äººç‰©)',
    };


    // --- ç›¤é»çµæœè™•ç†å‡½å¼ ---
    function updateResults(detections) {
      if (detections.length === 0) {
        // å¦‚æœæ²’æœ‰åµæ¸¬åˆ°æ±è¥¿ï¼Œä¿ç•™èˆŠçš„ç›¤é»çµæœï¼Œä¸åšæ›´æ–°
        return;
      }

      // 1. è™•ç†æ–°çš„åµæ¸¬çµæœ
      let newTransaction = {};

      detections.forEach(detection => {
        const cocoClass = detection.class;
        // å˜—è©¦ä½¿ç”¨ COCO é¡åˆ¥ä½œç‚ºéµï¼Œå¦‚æœæ‰¾ä¸åˆ°å‰‡å¿½ç•¥
        const itemId = COCO_TO_ITEM_ID[cocoClass]; 

        if (itemId && itemId !== 'IGNORE') {
          newTransaction[itemId] = (newTransaction[itemId] || 0) + 1;
        }
      });
      
      // 2. æ›´æ–°å…¨åŸŸäº¤æ˜“ç´€éŒ„ (åªä¿ç•™ç•¶å‰åµæ¸¬åˆ°çš„ç‰©å“)
      transaction = newTransaction;

      // 3. æ›´æ–° UI è¡¨æ ¼
      renderResultsTable();
    }

    function renderResultsTable() {
      if (Object.keys(transaction).length === 0) {
        resultsTableBody.innerHTML = '<tr><td colspan="2">å°šæœªåµæ¸¬åˆ°å™¨çš¿</td></tr>';
        return;
      }

      let html = '';
      for (const itemId in transaction) {
        const name = ITEM_ID_TO_NAME[itemId] || `æœªçŸ¥å“é … (${itemId})`;
        const count = transaction[itemId];
        html += `
          <tr>
            <td>${itemId} (${name})</td>
            <td>${count}</td>
          </tr>
        `;
      }
      resultsTableBody.innerHTML = html;
    }

    function clearResults() {
      transaction = {};
      renderResultsTable();
      statusInfo.textContent = 'ç›¤é»çµæœå·²æ¸…é™¤ã€‚';
    }


    // --- YOLOv8 åµæ¸¬é¡åˆ¥ ---
    class YOLOv8Detector {
      constructor(modelPath) {
        this.modelPath = modelPath;
        this.session = null;
        this.cocoLabels = [ /* COCO 80 å€‹é¡åˆ¥ */
            "person", "bicycle", "car", "motorcycle", "airplane", "bus", "train", "truck", "boat", "traffic light",
            "fire hydrant", "stop sign", "parking meter", "bench", "bird", "cat", "dog", "horse", "sheep", "cow",
            "elephant", "bear", "zebra", "giraffe", "backpack", "umbrella", "handbag", "tie", "suitcase", "frisbee",
            "skis", "snowboard", "sports ball", "kite", "baseball bat", "baseball glove", "skateboard", "surfboard",
            "tennis racket", "bottle", "wine glass", "cup", "fork", "knife", "spoon", "bowl", "banana", "apple",
            "sandwich", "orange", "broccoli", "carrot", "hot dog", "pizza", "donut", "cake", "chair", "couch",
            "potted plant", "bed", "dining table", "toilet", "tv", "laptop", "mouse", "remote", "keyboard", "cell phone",
            "microwave", "oven", "toaster", "sink", "refrigerator", "book", "clock", "vase", "scissors", "teddy bear",
            "hair drier", "toothbrush"
        ];
      }

      async loadModel() {
        statusInfo.textContent = `è¼‰å…¥ AI æ¨¡å‹ä¸­... (æ­£åœ¨ä¸‹è¼‰ 42.8 MB æ¨¡å‹)`;
        try {
            this.session = await ort.InferenceSession.create(this.modelPath, {
                executionProviders: ['wasm'], // å¼·åˆ¶ä½¿ç”¨ WASM å¾Œç«¯ï¼Œæé«˜ç©©å®šæ€§
                graphOptimizationLevel: 'all',
                logLevel: 'error'
            });

            statusInfo.textContent = 'âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸï¼æ­£åœ¨é–‹å•Ÿé¡é ­...';
            return true;

        } catch (error) {
            console.error('æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
            statusInfo.textContent = `âŒ YOLOv8 æ¨¡å‹è¼‰å…¥å¤±æ•—: ${error.message}. è«‹ç¢ºèªæ¨¡å‹ç›´éˆå¯è¨ªå•ã€‚`;
            return false;
        }
      }

      // å½±åƒå‰ç½®è™•ç† (ä¿ç•™åŸé‚è¼¯)
      async preprocess(source) {
        let tensor = tf.browser.fromPixels(source);
        let [h, w] = tensor.shape;
        const resizeRatio = Math.min(MODEL_INPUT_SIZE / h, MODEL_INPUT_SIZE / w);

        const targetW = Math.round(w * resizeRatio);
        const targetH = Math.round(h * resizeRatio);
        
        // èª¿æ•´å°ºå¯¸ï¼Œä¸¦ä½¿ç”¨ padding è£œé½Šåˆ° 640x640
        tensor = tf.image.resizeBilinear(tensor, [targetH, targetW]);
        
        // é€²è¡Œ Padding (é€™è£¡ä½¿ç”¨å³ä¸‹è§’ paddingï¼Œä»¥ç¶­æŒå½±åƒæ¯”ä¾‹)
        const paddingW = MODEL_INPUT_SIZE - targetW;
        const paddingH = MODEL_INPUT_SIZE - targetH;
        
        tensor = tf.pad(tensor, [
          [0, paddingH], [0, paddingW], [0, 0]
        ], 0); // é»‘è‰² padding

        tensor = tensor.div(255.0); // æ­¸ä¸€åŒ–
        tensor = tensor.transpose([2, 0, 1]); // HWC to CHW
        tensor = tensor.expandDims(0); // Add batch dim: CHW to NCHW

        // æ³¨æ„ï¼šé€™è£¡å¿…é ˆä½¿ç”¨ Float32Arrayï¼Œå› ç‚ºæˆ‘å€‘è¼‰å…¥çš„æ˜¯ FP32 æ¨¡å‹
        const inputData = new Float32Array(tensor.dataSync());
        tf.dispose(tensor); // é‡‹æ”¾ GPU è¨˜æ†¶é«”

        return { 
          inputTensor: new ort.Tensor('float32', inputData, [1, 3, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]),
          ratio: resizeRatio,
          sourceWidth: w,
          sourceHeight: h
        };
      }

      // åŸ·è¡Œæ¨ç† (ä¿ç•™åŸé‚è¼¯)
      async detect(source) {
        if (!this.session) return [];

        const { inputTensor, ratio, sourceWidth, sourceHeight } = await this.preprocess(source);
        
        const feeds = { 'images': inputTensor }; // YOLOv8 æ¨¡å‹çš„æ¨™æº–è¼¸å…¥åç¨±
        const results = await this.session.run(feeds);
        
        const outputTensor = results.output0.data; // YOLOv8 çš„è¼¸å‡ºåç¨±é€šå¸¸æ˜¯ output0

        return this.postprocess(outputTensor, ratio, sourceWidth, sourceHeight);
      }

      // å¾Œè™•ç†èˆ‡ NMS (éæ¥µå¤§å€¼æŠ‘åˆ¶) (ä¿ç•™åŸé‚è¼¯)
      postprocess(outputData, ratio, sourceWidth, sourceHeight) {
        const [numClasses, numBoxes] = [this.cocoLabels.length, 8400]; // COCO 80 é¡åˆ¥
        const boxSize = 4 + numClasses;
        
        let boxes = [];
        for (let i = 0; i < numBoxes; i++) {
          let boxData = outputData.slice(i * boxSize, (i + 1) * boxSize);
          
          let scores = boxData.slice(4, 4 + numClasses);
          let maxScore = Math.max(...scores);
          
          if (maxScore > CONF_THRESHOLD) {
            let classId = scores.indexOf(maxScore);
            
            // Box åº§æ¨™è½‰æ›
            let x = boxData[0];
            let y = boxData[1];
            let w = boxData[2];
            let h = boxData[3];
            
            // è½‰æ›å›åŸå§‹å½±åƒåº§æ¨™ (å·²è€ƒæ…® padding)
            let xmin = (x - w / 2) / ratio;
            let ymin = (y - h / 2) / ratio;
            let xmax = (x + w / 2) / ratio;
            let ymax = (y + h / 2) / ratio;

            // è£å‰ªåˆ°å½±åƒé‚Šç•Œ
            xmin = Math.max(0, xmin);
            ymin = Math.max(0, ymin);
            xmax = Math.min(sourceWidth, xmax);
            ymax = Math.min(sourceHeight, ymax);

            boxes.push({
              xmin: xmin,
              ymin: ymin,
              xmax: xmax,
              ymax: ymax,
              score: maxScore,
              classId: classId,
              class: this.cocoLabels[classId]
            });
          }
        }
        
        // åŸ·è¡Œ NMS (éæ¥µå¤§å€¼æŠ‘åˆ¶)
        return this.nonMaxSuppression(boxes);
      }

      // NMS é‚è¼¯ (ä¿ç•™åŸé‚è¼¯)
      nonMaxSuppression(boxes) {
        if (boxes.length === 0) return [];

        const sortedBoxes = boxes.sort((a, b) => b.score - a.score);
        const selected = [];

        while (sortedBoxes.length > 0) {
          const first = sortedBoxes[0];
          selected.push(first);
          
          const iouFilter = sortedBoxes.slice(1).filter(box => {
            const iou = this.intersectionOverUnion(first, box);
            return iou < IOU_THRESHOLD || first.classId !== box.classId; // ä¸åŒé¡åˆ¥ä¸æŠ‘åˆ¶
          });

          sortedBoxes.splice(0, sortedBoxes.length, ...iouFilter);
        }

        return selected;
      }

      // IoU è¨ˆç®— (ä¿ç•™åŸé‚è¼¯)
      intersectionOverUnion(box1, box2) {
        const xA = Math.max(box1.xmin, box2.xmin);
        const yA = Math.max(box1.ymin, box2.ymin);
        const xB = Math.min(box1.xmax, box2.xmax);
        const yB = Math.min(box1.ymax, box2.ymax);

        const intersection = Math.max(0, xB - xA) * Math.max(0, yB - yA);
        
        const area1 = (box1.xmax - box1.xmin) * (box1.ymax - box1.ymin);
        const area2 = (box2.xmax - box2.xmin) * (box2.ymax - box2.ymin);
        
        if (area1 <= 0 || area2 <= 0) return 0;

        return intersection / (area1 + area2 - intersection);
      }
    }


    // --- æ”å½±æ©Ÿè¨­å®šèˆ‡å¹€åµæ¸¬ ---

    function setupCamera() {
      // **[ä¿®å¾©é»ä¸€]ï¼šç§»é™¤ facingMode é™åˆ¶ï¼Œå…ˆå˜—è©¦ç²å–ä»»ä½•å¯ç”¨çš„è¦–é »æµ**
      const constraints = {
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 }
        }
      };

      navigator.mediaDevices.getUserMedia(constraints)
        .then(stream => {
          videoCanvas.srcObject = stream;
          videoCanvas.onloadedmetadata = () => {
            videoCanvas.play();
            // ç¢ºä¿ canvas å°ºå¯¸èˆ‡ video åŒ¹é…
            overlayCanvas.width = videoCanvas.videoWidth;
            overlayCanvas.height = videoCanvas.videoHeight;
            statusInfo.textContent = 'ğŸ¥ é¡é ­é–‹å•ŸæˆåŠŸï¼é–‹å§‹åµæ¸¬å™¨çš¿...';
            requestAnimationFrame(detectFrame);
          };
        })
        .catch(err => {
          console.error("ç„¡æ³•é–‹å•Ÿé¡é ­:", err);
          // å¤±æ•—æ™‚æ›´æ–° UI ç‹€æ…‹ï¼Œæç¤ºç”¨æˆ¶æª¢æŸ¥æ¬Šé™
          statusInfo.textContent = 'âŒ ç„¡æ³•é–‹å•Ÿé¡é ­ï¼Œè«‹æª¢æŸ¥æ¬Šé™æˆ–è¨­å‚™ã€‚éŒ¯èª¤ï¼š' + err.name;
        });
    }

    async function detectFrame(now) {
      // **[ä¿®å¾©é»äºŒ]ï¼šå¢åŠ æª¢æŸ¥ videoWidth/Heightï¼Œç¢ºä¿æœ‰æœ‰æ•ˆçš„å½±åƒä¸²æµ**
      // å¦‚æœæ²’æœ‰æˆåŠŸçš„è¦–é »æµï¼ˆå¯¬é«˜ç‚º 0ï¼‰ï¼Œå‰‡è·³éåµæ¸¬ä¸¦æ¸…é™¤ç•«å¸ƒã€‚
      if (isDetecting || !yoloDetector || !videoCanvas.srcObject || videoCanvas.videoWidth === 0) {
        // æ¸…ç©ºèª¤å ±çš„ç´…æ¡†
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); 
        requestAnimationFrame(detectFrame);
        return;
      }
      
      
      // æ ¹æ“šè¨­å®šçš„é–“éš”æ™‚é–“é€²è¡Œåµæ¸¬
      if (now - lastDetectionTime < DETECTION_INTERVAL) {
        requestAnimationFrame(detectFrame);
        return;
      }
      lastDetectionTime = now;
      
      isDetecting = true;
      try {
        const detections = await yoloDetector.detect(videoCanvas);
        
        // è™•ç†ç›¤é»çµæœ
        updateResults(detections); 
        
        // ç¹ªè£½é‚Šç•Œæ¡†
        drawBoundingBoxes(detections);
        
      } catch (error) {
        console.error('YOLOv8 åµæ¸¬éŒ¯èª¤:', error);
        statusInfo.textContent = 'YOLOv8 åµæ¸¬éŒ¯èª¤';
      }

      isDetecting = false;
      requestAnimationFrame(detectFrame);
    }

    function drawBoundingBoxes(detections) {
      ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      ctx.strokeStyle = '#FF0000';
      ctx.lineWidth = 3;
      ctx.font = '16px Arial';
      ctx.fillStyle = '#FF0000';

      detections.forEach(detection => {
        const x = detection.xmin;
        const y = detection.ymin;
        const w = detection.xmax - detection.xmin;
        const h = detection.ymax - detection.ymin;
        
        const itemId = COCO_TO_ITEM_ID[detection.class];
        const name = ITEM_ID_TO_NAME[itemId] || detection.class;

        // ç¹ªè£½é‚Šç•Œæ¡†
        ctx.beginPath();
        ctx.rect(x, y, w, h);
        ctx.stroke();

        // ç¹ªè£½æ¨™ç±¤
        const label = `${name} (${(detection.score * 100).toFixed(1)}%)`;
        ctx.fillText(label, x, y > 20 ? y - 5 : y + 15);
      });
    }

    // --- å•Ÿå‹•å‡½å¼ ---

    async function loadModel() {
      // *** ä½¿ç”¨æ‚¨æä¾›çš„ Hugging Face ç›´éˆ (FP32 æ¨¡å‹) ***
      const HF_MODEL_URL = 'https://huggingface.co/wang2631/YOLOv8s-web-deployment/resolve/main/yolov8s.onnx';
      
      try {
        yoloDetector = new YOLOv8Detector(HF_MODEL_URL); 
        
        const success = await yoloDetector.loadModel();
        
        if (success) {
            setupCamera();
        } 

      } catch (error) {
        console.error('ç³»çµ±å•Ÿå‹•å¤±æ•—:', error);
        statusInfo.textContent = 'ç³»çµ±å•Ÿå‹•å¤±æ•—ï¼Œè«‹æª¢æŸ¥ä¸»æ§å°';
      }
    }

    // å•Ÿå‹•æ‡‰ç”¨
    window.onload = loadModel;

  </script>

</body>
</html>