<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å™¨çš¿åƒ¹æ ¼æƒæèˆ‡ç´¯è¨ˆç³»çµ±</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'PingFang TC', 'Helvetica Neue', Arial, sans-serif;
        }
        
        body {
            background-color: #f5f5f7;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 100%;
            padding: 15px;
        }
        
        header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 1.4rem;
            margin-bottom: 5px;
        }
        
        .subtitle {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .camera-section {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        #camera-container {
            width: 100%;
            height: 300px;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
            position: relative;
        }
        
        #camera-view {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #captured-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: black;
            display: none;
        }
        
        .camera-controls {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.3s;
            flex: 1;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        #capture-btn {
            background-color: #e74c3c;
        }
        
        #capture-btn:hover {
            background-color: #c0392b;
        }
        
        #retake-btn {
            background-color: #f39c12;
            display: none;
        }
        
        .upload-section {
            margin-top: 15px;
            text-align: center;
        }
        
        #file-input {
            display: none;
        }
        
        .upload-btn {
            background-color: #9b59b6;
            display: inline-block;
            width: 100%;
        }
        
        .training-section {
            background-color: #e8f4fd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 2px dashed #3498db;
        }
        
        .training-section h3 {
            color: #2980b9;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .training-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .training-btn {
            background-color: #2980b9;
            font-size: 0.75rem;
            padding: 8px 5px;
        }
        
        .training-btn:hover {
            background-color: #2471a3;
        }
        
        .result-section {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: none;
        }
        
        .result-section.active {
            display: block;
        }
        
        .item-info {
            margin-bottom: 15px;
        }
        
        .item-name {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .item-price {
            font-size: 1.3rem;
            color: #e74c3c;
            font-weight: bold;
        }
        
        .confidence {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .detection-info {
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .action-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        #confirm-btn {
            background-color: #2ecc71;
            flex: 2;
        }
        
        #confirm-btn:hover {
            background-color: #27ae60;
        }
        
        #cancel-btn {
            background-color: #95a5a6;
            flex: 1;
        }
        
        #cancel-btn:hover {
            background-color: #7f8c8d;
        }
        
        .summary-section {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .total-amount {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
            text-align: center;
            margin: 10px 0;
        }
        
        .history-section {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .history-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .history-item {
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
        }
        
        .history-item:last-child {
            border-bottom: none;
        }
        
        .history-name {
            flex: 2;
            font-size: 0.9rem;
        }
        
        .history-price {
            flex: 1;
            text-align: right;
            color: #e74c3c;
            font-weight: bold;
        }
        
        .save-section {
            margin-top: 20px;
            text-align: center;
        }
        
        #save-btn {
            background-color: #9b59b6;
            width: 100%;
            padding: 12px;
        }
        
        #save-btn:hover {
            background-color: #8e44ad;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 10px;
            color: #3498db;
        }
        
        .loading.active {
            display: block;
        }
        
        .manual-select {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .manual-select select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 5px;
            font-size: 0.9rem;
        }
        
        .detection-hint {
            text-align: center;
            color: #7f8c8d;
            font-size: 0.8rem;
            margin-top: 5px;
        }
        
        .model-status {
            text-align: center;
            padding: 5px;
            font-size: 0.8rem;
            border-radius: 4px;
            margin-bottom: 10px;
            background-color: #d1ecf1;
            color: #0c5460;
        }
        
        .tips-section {
            background-color: #fff3cd;
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
        }
        
        .tips-section h4 {
            color: #856404;
            margin-bottom: 8px;
            text-align: center;
        }
        
        .tip-item {
            font-size: 0.75rem;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
        }
        
        .tip-item::before {
            content: "ğŸ’¡";
            margin-right: 5px;
        }
        
        @media (min-width: 768px) {
            .container {
                max-width: 600px;
                margin: 0 auto;
            }
            
            #camera-container {
                height: 400px;
            }
            
            .training-buttons {
                grid-template-columns: 1fr 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>å™¨çš¿åƒ¹æ ¼æƒæèˆ‡ç´¯è¨ˆç³»çµ±</h1>
            <div class="subtitle">æ¼¢ä¾†ç¾é£Ÿè‚¡ä»½æœ‰é™å…¬å¸ - å—æ¸¯å³¶èª</div>
        </header>
        
        <section class="camera-section">
            <div class="model-status">
                âœ… ä½¿ç”¨é¤ç›¤å°ˆç”¨è­˜åˆ¥ç®—æ³• | ç‰¹å¾µ: å½¢ç‹€+é¡è‰²+ç´‹ç†+å°ºå¯¸
            </div>
            <div id="camera-container">
                <video id="camera-view" autoplay playsinline></video>
                <canvas id="canvas-overlay"></canvas>
                <img id="captured-image">
            </div>
            <div class="camera-controls">
                <button id="start-camera">é–‹å•Ÿç›¸æ©Ÿ</button>
                <button id="capture-btn" disabled>æ‹ç…§è¾¨è­˜</button>
                <button id="retake-btn">é‡æ–°æ‹æ”</button>
            </div>
            <div class="detection-hint" id="detection-hint">
                ğŸ¯ å°‡é¤ç›¤å¹³æ”¾ï¼Œå°æº–ä¸­å¤®ï¼Œç¢ºä¿å…‰ç·šå‡å‹»
            </div>
            
            <div class="tips-section">
                <h4>æé«˜è­˜åˆ¥æº–ç¢ºåº¦æŠ€å·§</h4>
                <div class="tip-item">ä½¿ç”¨ç´”è‰²èƒŒæ™¯ï¼ˆå»ºè­°ç™½è‰²æˆ–é»‘è‰²ï¼‰</div>
                <div class="tip-item">ä¿æŒç›¸åŒæ‹æ”è·é›¢ï¼ˆç´„30-40å…¬åˆ†ï¼‰</div>
                <div class="tip-item">é¿å…å¼·çƒˆåå…‰å’Œé™°å½±</div>
                <div class="tip-item">æ‹æ”å‰å…ˆè¨“ç·´åƒè€ƒç…§ç‰‡</div>
            </div>
            
            <div class="training-section">
                <h3>ğŸ“¸ è¨“ç·´åƒè€ƒç…§ç‰‡ï¼ˆé‡è¦ï¼ï¼‰</h3>
                <p style="text-align: center; font-size: 0.75rem; margin-bottom: 10px; color: #666;">
                    æ¯å€‹é¤ç›¤æ‹æ”2-3å¼µä¸åŒè§’åº¦ï¼Œå¤§å¹…æé«˜æº–ç¢ºç‡
                </p>
                <div class="training-buttons" id="training-buttons">
                    <!-- è¨“ç·´æŒ‰éˆ•æœƒå‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>
            
            <div class="upload-section">
                <input type="file" id="file-input" accept="image/*">
                <button class="upload-btn" onclick="document.getElementById('file-input').click()">ä¸Šå‚³åœ–ç‰‡è¾¨è­˜</button>
            </div>
            <div class="loading" id="loading">åˆ†æé¤ç›¤ç‰¹å¾µä¸­...</div>
            <div class="manual-select">
                <label>æˆ–æ‰‹å‹•é¸æ“‡å™¨çš¿ï¼š</label>
                <select id="manual-select">
                    <option value="">è«‹é¸æ“‡å™¨çš¿...</option>
                </select>
            </div>
        </section>
        
        <section class="result-section" id="result-section">
            <div class="item-info">
                <div class="item-name" id="item-name">è¾¨è­˜ä¸­...</div>
                <div class="item-price" id="item-price">NT$ 0</div>
                <div class="confidence" id="confidence">ç‰¹å¾µåŒ¹é…åº¦: 0%</div>
                <div class="detection-info" id="detection-info">ä½¿ç”¨é¤ç›¤å°ˆç”¨ç®—æ³•</div>
            </div>
            <div class="action-buttons">
                <button id="cancel-btn">å–æ¶ˆ</button>
                <button id="confirm-btn">ç¢ºèªåŠ å…¥</button>
            </div>
        </section>
        
        <section class="summary-section">
            <h2>ç¸½è¨ˆé‡‘é¡</h2>
            <div class="total-amount" id="total-amount">NT$ 0</div>
        </section>
        
        <section class="history-section">
            <h2>å·²æƒæé …ç›®</h2>
            <div class="history-list" id="history-list">
                <div style="text-align: center; color: #7f8c8d; padding: 20px;">å°šæœªæƒæä»»ä½•å™¨çš¿</div>
            </div>
            <div class="save-section">
                <button id="save-btn">å„²å­˜è¨˜éŒ„</button>
            </div>
        </section>
    </div>

    <script>
        // é¤ç›¤å°ˆç”¨è³‡æ–™åº« - é‡å°é¤ç›¤ç‰¹å¾µå„ªåŒ–
        const itemsDatabase = [
            { 
                id: 1, code: "160100000126", name: "æ­¢æ»‘åœ“æ‰˜ç›¤16å‹/ç›´å¾‘41cm", price: 235, type: "ç›¤å­", 
                features: { 
                    shape: "round", size: "large", color: "white", texture: "non_slip",
                    diameter: 41, edges: "smooth", thickness: "medium"
                }
            },
            { 
                id: 2, code: "160100000987", name: "å¥¶æ²¹ç¢Ÿ(å‘³ç¢Ÿ)2.8å‹/è±¡ç‰™å¼·åŒ–/æ¸¯å¼å°ç¢Ÿ/169éŠ€æ²³ç³»", price: 21, type: "ç¢Ÿå­", 
                features: { 
                    shape: "round", size: "small", color: "ivory", texture: "smooth",
                    diameter: 7, edges: "thin", thickness: "thin"
                }
            },
            { 
                id: 3, code: "160100000994", name: "å¯ç–Šå°æ–™ç¢Ÿ(å¸ƒä¸ç¢Ÿ)ç™½/78*30mm", price: 45, type: "ç¢Ÿå­", 
                features: { 
                    shape: "round", size: "small", color: "white", texture: "smooth",
                    diameter: 7.8, edges: "stackable", thickness: "thin"
                }
            },
            { 
                id: 4, code: "160101000478", name: "æ¡ƒå‹å°ç¼½4å‹/10.3*9*H4.3cm", price: 27, type: "ç¢—", 
                features: { 
                    shape: "oval", size: "small", color: "white", texture: "smooth",
                    diameter: 10.3, edges: "curved", thickness: "medium"
                }
            },
            { 
                id: 5, code: "160101000479", name: "åœ“ç›¤6å‹/15*H2cm", price: 25, type: "ç›¤å­", 
                features: { 
                    shape: "round", size: "medium", color: "white", texture: "smooth",
                    diameter: 15, edges: "smooth", thickness: "thin"
                }
            },
            { 
                id: 6, code: "160101000539", name: "CLASSICåœ“é¤ç›¤(æµ®é›•ç›´ç·šç´‹)RAK/240mm", price: 100, type: "ç›¤å­", 
                features: { 
                    shape: "round", size: "large", color: "white", texture: "embossed",
                    diameter: 24, edges: "patterned", thickness: "medium"
                }
            },
            { 
                id: 7, code: "160101000540", name: "NANOåœ“å¹³ç›¤(æµ®é›•ç›´ç·šç´‹)RAK/240mm", price: 100, type: "ç›¤å­", 
                features: { 
                    shape: "round", size: "large", color: "white", texture: "embossed",
                    diameter: 24, edges: "patterned", thickness: "thin"
                }
            },
            { 
                id: 10, code: "160102000317", name: "éº»å¸ƒç´‹åœ“æ·ºç›¤8.25å‹/21cm", price: 230, type: "ç›¤å­", 
                features: { 
                    shape: "round", size: "medium", color: "white", texture: "linen",
                    diameter: 21, edges: "textured", thickness: "thin"
                }
            },
            { 
                id: 11, code: "160102000318", name: "åœ“æ·ºç›¤(æ·±è—)/10å‹/25.4cm", price: 250, type: "ç›¤å­", 
                features: { 
                    shape: "round", size: "large", color: "blue", texture: "smooth",
                    diameter: 25.4, edges: "smooth", thickness: "thin"
                }
            },
            { 
                id: 14, code: "160104000052", name: "å’–å•¡æ¯/é‡è‘‰æ—-é’æ‰è—/æ—¥æœ¬NORITAKE/8*6.2cm/220ml", price: 128, type: "æ¯å­", 
                features: { 
                    shape: "cup", size: "medium", color: "blue", texture: "glossy",
                    diameter: 8, edges: "with_handle", thickness: "medium"
                }
            },
            { 
                id: 26, code: "160200000255", name: "è–„åº•åœ“é…’æ¯(æ°´æ¯)/(LIBBEY )/5.8*H10.1cm/348cc", price: 35, type: "æ¯å­", 
                features: { 
                    shape: "glass", size: "medium", color: "clear", texture: "smooth",
                    diameter: 5.8, edges: "thin", thickness: "thin"
                }
            }
        ];

        // DOMå…ƒç´ 
        const cameraView = document.getElementById('camera-view');
        const canvasOverlay = document.getElementById('canvas-overlay');
        const capturedImage = document.getElementById('captured-image');
        const startCameraBtn = document.getElementById('start-camera');
        const captureBtn = document.getElementById('capture-btn');
        const retakeBtn = document.getElementById('retake-btn');
        const resultSection = document.getElementById('result-section');
        const itemName = document.getElementById('item-name');
        const itemPrice = document.getElementById('item-price');
        const confidence = document.getElementById('confidence');
        const detectionInfo = document.getElementById('detection-info');
        const confirmBtn = document.getElementById('confirm-btn');
        const cancelBtn = document.getElementById('cancel-btn');
        const totalAmount = document.getElementById('total-amount');
        const historyList = document.getElementById('history-list');
        const saveBtn = document.getElementById('save-btn');
        const loading = document.getElementById('loading');
        const fileInput = document.getElementById('file-input');
        const manualSelect = document.getElementById('manual-select');
        const detectionHint = document.getElementById('detection-hint');
        const trainingButtons = document.getElementById('training-buttons');

        // æ‡‰ç”¨ç‹€æ…‹
        let stream = null;
        let currentItem = null;
        let scannedItems = [];
        let total = 0;
        let currentImage = null;
        let referenceTemplates = {}; // å„²å­˜æ¨¡æ¿åœ–ç‰‡

        // é¤ç›¤å°ˆç”¨ç‰¹å¾µæª¢æ¸¬å™¨
        class PlateFeatureDetector {
            constructor() {
                this.templates = {};
                this.featureWeights = {
                    shape: 0.25,
                    size: 0.20,
                    color: 0.20,
                    texture: 0.15,
                    edges: 0.10,
                    brightness: 0.10
                };
            }
            
            // æå–é¤ç›¤ç‰¹å¾µ
            extractPlateFeatures(image) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 100;
                canvas.height = 100;
                ctx.drawImage(image, 0, 0, 100, 100);
                
                const imageData = ctx.getImageData(0, 0, 100, 100);
                const data = imageData.data;
                
                return {
                    shape: this.detectPlateShape(data, 100, 100),
                    size: this.estimatePlateSize(data, 100, 100),
                    color: this.analyzePlateColor(data),
                    texture: this.analyzeTexture(data, 100, 100),
                    edges: this.analyzeEdges(data, 100, 100),
                    brightness: this.getAverageBrightness(data),
                    contrast: this.getContrast(data)
                };
            }
            
            // æª¢æ¸¬é¤ç›¤å½¢ç‹€
            detectPlateShape(data, width, height) {
                const centerX = width / 2;
                const centerY = height / 2;
                let platePixels = 0;
                let roundPixels = 0;
                let totalPixels = 0;
                
                // æª¢æ¸¬åœ“å½¢åº¦
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        
                        if (brightness > 50) { // é¤ç›¤å€åŸŸ
                            platePixels++;
                            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                            if (distance < 45) {
                                roundPixels++;
                            }
                        }
                        totalPixels++;
                    }
                }
                
                const roundness = roundPixels / platePixels;
                const coverage = platePixels / totalPixels;
                
                if (roundness > 0.85) return "round";
                if (roundness > 0.6) return "oval";
                if (coverage > 0.7) return "rectangular";
                return "irregular";
            }
            
            // ä¼°è¨ˆé¤ç›¤å°ºå¯¸
            estimatePlateSize(data, width, height) {
                let platePixels = 0;
                let totalPixels = width * height;
                
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    if (brightness > 50) {
                        platePixels++;
                    }
                }
                
                const coverage = platePixels / totalPixels;
                if (coverage > 0.6) return "large";
                if (coverage > 0.3) return "medium";
                return "small";
            }
            
            // åˆ†æé¤ç›¤é¡è‰²
            analyzePlateColor(data) {
                let totalR = 0, totalG = 0, totalB = 0;
                let count = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    if (brightness > 50 && brightness < 240) { // æ’é™¤èƒŒæ™¯å’Œéäº®å€åŸŸ
                        totalR += data[i];
                        totalG += data[i + 1];
                        totalB += data[i + 2];
                        count++;
                    }
                }
                
                if (count === 0) return "unknown";
                
                const avgR = totalR / count;
                const avgG = totalG / count;
                const avgB = totalB / count;
                const brightness = (avgR + avgG + avgB) / 3;
                
                if (brightness > 200) return "white";
                if (brightness > 180 && brightness < 200) return "ivory";
                if (avgB > avgR + 20 && avgB > avgG + 20) return "blue";
                if (Math.abs(avgR - avgG) < 10 && Math.abs(avgR - avgB) < 10) return "gray";
                if (brightness < 100) return "dark";
                return "light";
            }
            
            // åˆ†æç´‹ç†
            analyzeTexture(data, width, height) {
                let edgeCount = 0;
                let variance = 0;
                const brightnessValues = [];
                
                // æ”¶é›†äº®åº¦å€¼
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    brightnessValues.push(brightness);
                }
                
                // è¨ˆç®—æ–¹å·®
                const mean = brightnessValues.reduce((a, b) => a + b) / brightnessValues.length;
                variance = brightnessValues.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / brightnessValues.length;
                
                // é‚Šç·£æª¢æ¸¬
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        const current = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        
                        const right = (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3;
                        const bottom = (data[idx + width * 4] + data[idx + width * 4 + 1] + data[idx + width * 4 + 2]) / 3;
                        
                        if (Math.abs(current - right) > 25 || Math.abs(current - bottom) > 25) {
                            edgeCount++;
                        }
                    }
                }
                
                const edgeDensity = edgeCount / (width * height);
                
                if (variance > 800) return "embossed";
                if (variance > 500) return "linen";
                if (edgeDensity > 0.1) return "patterned";
                return "smooth";
            }
            
            // åˆ†æé‚Šç·£ç‰¹å¾µ
            analyzeEdges(data, width, height) {
                let sharpEdgeCount = 0;
                let gradualEdgeCount = 0;
                
                // æª¢æ¸¬é‚Šç·£éæ¸¡
                for (let y = 10; y < height - 10; y += 5) {
                    for (let x = 10; x < width - 10; x += 5) {
                        const idx = (y * width + x) * 4;
                        const current = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        
                        // æª¢æŸ¥å¾‘å‘æ¢¯åº¦
                        const distances = [5, 10, 15];
                        let maxGradient = 0;
                        
                        for (const dist of distances) {
                            const rightIdx = (y * width + Math.min(x + dist, width - 1)) * 4;
                            const right = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;
                            maxGradient = Math.max(maxGradient, Math.abs(current - right));
                        }
                        
                        if (maxGradient > 60) sharpEdgeCount++;
                        else if (maxGradient > 20) gradualEdgeCount++;
                    }
                }
                
                if (sharpEdgeCount > gradualEdgeCount * 2) return "sharp";
                if (gradualEdgeCount > sharpEdgeCount * 2) return "curved";
                return "smooth";
            }
            
            // å¹³å‡äº®åº¦
            getAverageBrightness(data) {
                let total = 0;
                for (let i = 0; i < data.length; i += 4) {
                    total += (data[i] + data[i + 1] + data[i + 2]) / 3;
                }
                return total / (data.length / 4);
            }
            
            // å°æ¯”åº¦
            getContrast(data) {
                let min = 255, max = 0;
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    if (brightness < min) min = brightness;
                    if (brightness > max) max = brightness;
                }
                return max - min;
            }
            
            // è¨ˆç®—ç‰¹å¾µç›¸ä¼¼åº¦
            calculateSimilarity(features1, features2) {
                let totalScore = 0;
                let maxScore = 0;
                
                for (const [feature, weight] of Object.entries(this.featureWeights)) {
                    const score = this.compareFeature(feature, features1[feature], features2[feature]);
                    totalScore += score * weight;
                    maxScore += weight;
                }
                
                return (totalScore / maxScore) * 100;
            }
            
            // æ¯”è¼ƒå–®å€‹ç‰¹å¾µ
            compareFeature(feature, value1, value2) {
                if (feature === 'brightness' || feature === 'contrast') {
                    const diff = Math.abs(value1 - value2);
                    return Math.max(0, 1 - diff / 100);
                }
                return value1 === value2 ? 1 : 0;
            }
            
            // æ·»åŠ æ¨¡æ¿
            addTemplate(itemId, image) {
                if (!this.templates[itemId]) {
                    this.templates[itemId] = [];
                }
                const features = this.extractPlateFeatures(image);
                this.templates[itemId].push(features);
            }
            
            // è­˜åˆ¥é¤ç›¤
            recognizePlate(image) {
                const features = this.extractPlateFeatures(image);
                let bestMatch = null;
                let bestScore = 0;
                
                for (const [itemId, templateList] of Object.entries(this.templates)) {
                    for (const templateFeatures of templateList) {
                        const score = this.calculateSimilarity(features, templateFeatures);
                        if (score > bestScore && score > 65) {
                            bestScore = score;
                            bestMatch = itemsDatabase.find(item => item.id == itemId);
                        }
                    }
                }
                
                // å¦‚æœæ²’æœ‰æ¨¡æ¿åŒ¹é…ï¼Œå˜—è©¦åŸºæ–¼è¦å‰‡çš„åŒ¹é…
                if (!bestMatch) {
                    const ruleBased = this.ruleBasedRecognition(features);
                    if (ruleBased.confidence > 55) {
                        return ruleBased;
                    }
                }
                
                return bestMatch ? { item: bestMatch, confidence: bestScore } : null;
            }
            
            // è¦å‰‡åŸºç¤è­˜åˆ¥
            ruleBasedRecognition(features) {
                let bestMatch = null;
                let bestScore = 0;
                
                itemsDatabase.forEach(item => {
                    let score = 0;
                    
                    // å½¢ç‹€åŒ¹é…
                    if (features.shape === item.features.shape) score += 30;
                    
                    // å°ºå¯¸åŒ¹é…
                    if (features.size === item.features.size) score += 25;
                    
                    // é¡è‰²åŒ¹é…
                    if (features.color === item.features.color) score += 20;
                    
                    // ç´‹ç†åŒ¹é…
                    if (features.texture === item.features.texture) score += 15;
                    
                    // é‚Šç·£åŒ¹é…
                    if (features.edges === item.features.edges) score += 10;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = item;
                    }
                });
                
                return {
                    item: bestMatch,
                    confidence: Math.min(bestScore * 1.3, 90)
                };
            }
        }

        // åˆå§‹åŒ–ç‰¹å¾µæª¢æ¸¬å™¨
        const plateDetector = new PlateFeatureDetector();

        // åˆå§‹åŒ–è¨“ç·´æŒ‰éˆ•
        function initTrainingButtons() {
            trainingButtons.innerHTML = '';
            
            itemsDatabase.forEach(item => {
                const button = document.createElement('button');
                button.className = 'training-btn';
                button.textContent = `${item.name.split('/')[0]}`;
                button.title = item.name;
                button.onclick = () => trainPlateTemplate(item.id, item.name);
                trainingButtons.appendChild(button);
            });
        }

        // è¨“ç·´é¤ç›¤æ¨¡æ¿
        function trainPlateTemplate(itemId, itemName) {
            if (!stream) {
                alert('è«‹å…ˆé–‹å•Ÿç›¸æ©Ÿ');
                return;
            }
            
            try {
                loading.classList.add('active');
                detectionHint.textContent = `å­¸ç¿’ ${itemName} çš„ç‰¹å¾µ...`;
                
                const canvas = document.createElement('canvas');
                canvas.width = cameraView.videoWidth;
                canvas.height = cameraView.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(cameraView, 0, 0);
                
                const tempImage = new Image();
                tempImage.onload = () => {
                    plateDetector.addTemplate(itemId, tempImage);
                    
                    loading.classList.remove('active');
                    detectionHint.textContent = `âœ… æˆåŠŸå­¸ç¿’ ${itemName}ï¼å»ºè­°æ‹æ”2-3å€‹è§’åº¦`;
                    
                    setTimeout(() => {
                        detectionHint.textContent = "ğŸ¯ å°‡é¤ç›¤å¹³æ”¾ï¼Œå°æº–ä¸­å¤®ï¼Œç¢ºä¿å…‰ç·šå‡å‹»";
                    }, 3000);
                };
                tempImage.src = canvas.toDataURL('image/jpeg');
                
            } catch (error) {
                console.error('è¨“ç·´å¤±æ•—:', error);
                loading.classList.remove('active');
                detectionHint.textContent = "è¨“ç·´å¤±æ•—ï¼Œè«‹é‡è©¦";
            }
        }

        // åœ–åƒè­˜åˆ¥
        async function recognizeImage(image) {
            loading.classList.add('active');
            detectionHint.textContent = "åˆ†æé¤ç›¤ç‰¹å¾µä¸­...";
            
            try {
                const result = plateDetector.recognizePlate(image);
                
                loading.classList.remove('active');
                
                if (result) {
                    detectionHint.textContent = "âœ… è­˜åˆ¥æˆåŠŸï¼";
                    detectionInfo.textContent = "ä½¿ç”¨é¤ç›¤å°ˆç”¨ç®—æ³•";
                    return {
                        ...result,
                        detection: {
                            x: image.width * 0.2,
                            y: image.height * 0.2,
                            width: image.width * 0.6,
                            height: image.height * 0.6
                        }
                    };
                } else {
                    throw new Error('ç„¡æ³•è­˜åˆ¥æ­¤é¤ç›¤ï¼Œè«‹æ‹æ”åƒè€ƒç…§ç‰‡æˆ–æ‰‹å‹•é¸æ“‡');
                }
                
            } catch (error) {
                loading.classList.remove('active');
                detectionHint.textContent = "âŒ è­˜åˆ¥å¤±æ•—";
                throw error;
            }
        }

        // ç¹ªè£½æª¢æ¸¬çµæœ
        function drawDetectionResult(detection, label, confidence) {
            const ctx = canvasOverlay.getContext('2d');
            ctx.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
            
            const { x, y, width, height } = detection;
            const color = confidence > 80 ? '#00ff00' : confidence > 65 ? '#ff9900' : '#ff4444';
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.strokeRect(x, y, width, height);
            
            ctx.fillStyle = color;
            const text = `${label.split('/')[0]} (${confidence.toFixed(1)}%)`;
            const textWidth = ctx.measureText(text).width;
            ctx.fillRect(x, y - 25, textWidth + 10, 25);
            
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(text, x + 5, y - 8);
        }

        // åˆå§‹åŒ–æ‰‹å‹•é¸æ“‡é¸é …
        function initManualSelect() {
            const groupedItems = {};
            itemsDatabase.forEach(item => {
                if (!groupedItems[item.type]) {
                    groupedItems[item.type] = [];
                }
                groupedItems[item.type].push(item);
            });

            Object.keys(groupedItems).forEach(type => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = type;
                
                groupedItems[type].forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id;
                    option.textContent = `${item.name} - NT$ ${item.price}`;
                    optgroup.appendChild(option);
                });
                
                manualSelect.appendChild(optgroup);
            });
            
            manualSelect.addEventListener('change', function() {
                if (this.value) {
                    const selectedItem = itemsDatabase.find(item => item.id == this.value);
                    if (selectedItem) {
                        showRecognitionResult({
                            item: selectedItem,
                            confidence: 100,
                            detection: { x: 100, y: 100, width: 200, height: 200 }
                        });
                    }
                }
            });
        }

        // é¡¯ç¤ºè­˜åˆ¥çµæœ
        function showRecognitionResult(result) {
            currentItem = result.item;
            
            itemName.textContent = result.item.name;
            itemPrice.textContent = `NT$ ${result.item.price}`;
            confidence.textContent = `ç‰¹å¾µåŒ¹é…åº¦: ${result.confidence.toFixed(1)}%`;
            
            if (currentImage) {
                drawDetectionResult(result.detection, result.item.name, result.confidence);
            }
            
            resultSection.classList.add('active');
        }

        // åˆå§‹åŒ–
        function init() {
            updateTotalAmount();
            initManualSelect();
            initTrainingButtons();
        }

        // é–‹å•Ÿç›¸æ©Ÿ
        startCameraBtn.addEventListener('click', async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                cameraView.srcObject = stream;
                captureBtn.disabled = false;
                startCameraBtn.disabled = true;
                
                cameraView.addEventListener('loadedmetadata', () => {
                    canvasOverlay.width = cameraView.videoWidth;
                    canvasOverlay.height = cameraView.videoHeight;
                });
            } catch (err) {
                alert('ç„¡æ³•é–‹å•Ÿç›¸æ©Ÿ: ' + err.message);
            }
        });

        // æ‹ç…§è¾¨è­˜
        captureBtn.addEventListener('click', async () => {
            if (!stream) return;
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = cameraView.videoWidth;
                canvas.height = cameraView.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(cameraView, 0, 0);
                
                capturedImage.src = canvas.toDataURL('image/jpeg');
                capturedImage.style.display = 'block';
                cameraView.style.display = 'none';
                currentImage = capturedImage;
                captureBtn.style.display = 'none';
                retakeBtn.style.display = 'block';
                
                const result = await recognizeImage(capturedImage);
                showRecognitionResult(result);
                
            } catch (error) {
                alert(error.message);
                resetCameraView();
            }
        });

        // é‡æ–°æ‹æ”
        retakeBtn.addEventListener('click', resetCameraView);

        // ä¸Šå‚³åœ–ç‰‡è¾¨è­˜
        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                capturedImage.onload = async () => {
                    capturedImage.style.display = 'block';
                    cameraView.style.display = 'none';
                    currentImage = capturedImage;
                    captureBtn.style.display = 'none';
                    retakeBtn.style.display = 'block';
                    
                    try {
                        const result = await recognizeImage(capturedImage);
                        showRecognitionResult(result);
                    } catch (error) {
                        alert(error.message);
                    }
                };
                capturedImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        // ç¢ºèªåŠ å…¥
        confirmBtn.addEventListener('click', () => {
            if (currentItem) {
                scannedItems.push({
                    ...currentItem,
                    timestamp: new Date()
                });
                
                total += currentItem.price;
                updateTotalAmount();
                updateHistoryList();
                resetCameraView();
                detectionHint.textContent = "ğŸ¯ å°‡é¤ç›¤å¹³æ”¾ï¼Œå°æº–ä¸­å¤®ï¼Œç¢ºä¿å…‰ç·šå‡å‹»";
            }
        });

        // å–æ¶ˆ
        cancelBtn.addEventListener('click', () => {
            resetCameraView();
            detectionHint.textContent = "ğŸ¯ å°‡é¤ç›¤å¹³æ”¾ï¼Œå°æº–ä¸­å¤®ï¼Œç¢ºä¿å…‰ç·šå‡å‹»";
        });

        // é‡ç½®ç›¸æ©Ÿè¦–åœ–
        function resetCameraView() {
            resultSection.classList.remove('active');
            currentItem = null;
            capturedImage.style.display = 'none';
            cameraView.style.display = 'block';
            captureBtn.style.display = 'block';
            retakeBtn.style.display = 'none';
            
            const ctx = canvasOverlay.getContext('2d');
            ctx.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
        }

        // æ›´æ–°ç¸½é‡‘é¡
        function updateTotalAmount() {
            totalAmount.textContent = `NT$ ${total}`;
        }

        // æ›´æ–°æ­·å²è¨˜éŒ„
        function updateHistoryList() {
            historyList.innerHTML = '';
            
            if (scannedItems.length === 0) {
                historyList.innerHTML = '<div style="text-align: center; color: #7f8c8d; padding: 20px;">å°šæœªæƒæä»»ä½•å™¨çš¿</div>';
                return;
            }
            
            scannedItems.forEach(item => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                historyItem.innerHTML = `
                    <div class="history-name">${item.name}</div>
                    <div class="history-price">NT$ ${item.price}</div>
                `;
                historyList.appendChild(historyItem);
            });
        }

        // å„²å­˜è¨˜éŒ„
        saveBtn.addEventListener('click', () => {
            if (scannedItems.length === 0) {
                alert('æ²’æœ‰å¯å„²å­˜çš„è¨˜éŒ„');
                return;
            }
            
            const now = new Date();
            const dateStr = `${now.getFullYear()}-${(now.getMonth()+1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            const timeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
            
            const record = {
                date: dateStr,
                time: timeStr,
                items: scannedItems,
                total: total
            };
            
            const dataStr = JSON.stringify(record, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `å™¨çš¿ç›¤é»è¨˜éŒ„_${dateStr}_${timeStr.replace(':', '')}.json`;
            link.click();
            
            alert(`è¨˜éŒ„å·²å„²å­˜!\næ—¥æœŸ: ${dateStr}\næ™‚é–“: ${timeStr}\nç¸½é‡‘é¡: NT$ ${total}`);
        });

        // åˆå§‹åŒ–æ‡‰ç”¨
        init();
    </script>
</body>
</html>