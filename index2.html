<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆªç³»çµ± - å³æ™‚éšœç¤™ç‰©æª¢æ¸¬èˆ‡GPSè¿”èˆª" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</title>
  
  <!-- PWA æ”¯æŒ -->
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§­</text></svg>">
  
  <!-- TensorFlow.js å’Œ COCO-SSD -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  
  <!-- æ·»åŠ ç‰©å“è³‡æ–™åº« -->
  <script src="itemDatabase.js"></script>
  
  <style>
    /* å®Œæ•´çš„ç›²äººè¼”åŠ©å°èˆªç³»çµ±CSSæ¨£å¼ */
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    
    @media (min-width: 920px) {
      .app {
        grid-template-columns: 6fr 4fr;
      }
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    header.card {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: clamp(18px, 5vw, 24px);
      margin: 0;
      font-weight: 700;
    }
    
    header .tips {
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    
    @media (min-width: 768px) {
      header .tips {
        display: block;
      }
    }
    
    .camera {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
    }
    
    .camera video, .camera canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    
    /* ç§»é™¤é¡åƒæ•ˆæœ */
    .camera video {
      transform: scaleX(1);
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    @media (min-width: 480px) {
      .controls {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .primary {
      background: var(--good);
      color: #fff;
    }
    
    .warning {
      background: var(--warn);
      color: #fff;
    }
    
    .danger {
      background: var(--bad);
      color: #fff;
    }
    
    .secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, 1fr);
      margin-bottom: 12px;
    }
    
    @media (min-width: 480px) {
      .status {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .k {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .v {
      font-weight: 800;
      font-size: clamp(14px, 4vw, 16px);
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .list {
      max-height: 200px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
      padding-right: 4px;
      -webkit-overflow-scrolling: touch;
    }
    
    .chip {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }
    
    .module-tag {
      display: inline-block;
      background: var(--warn);
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 10px;
      margin-left: 8px;
      font-weight: 600;
    }
    
    .gps-active {
      background: var(--good) !important;
    }
    
    .emergency-alert {
      animation: pulse 1s infinite;
      border: 2px solid var(--bad);
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    .obstacle-warning {
      background: rgba(245,158,11,0.3);
      border: 2px solid var(--warn);
    }
    
    .danger-warning {
      background: rgba(239,68,68,0.3);
      border: 2px solid var(--bad);
    }
    
    @keyframes pulse {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
      100% {
        opacity: 1;
      }
    }
    
    @keyframes loading {
      0% {
        background-position: 200% 0;
      }
      100% {
        background-position: -200% 0;
      }
    }
    
    /* æ‰‹æ©Ÿå„ªåŒ– */
    @media (max-width: 480px) {
      body {
        padding: 8px;
      }
      
      .panel {
        padding: 12px;
      }
      
      button.btn {
        padding: 14px 10px;
        font-size: 13px;
        min-height: 50px;
      }
      
      .status-item {
        padding: 10px;
      }
      
      .voice-alert {
        padding: 14px;
        min-height: 55px;
        font-size: 14px;
      }
    }
    
    /* é˜²æ­¢æ–‡å­—é¸æ“‡ */
    .no-select {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    /* å®‰å…¨é€šé“å°èˆªç³»çµ± */
    .safety-corridor {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      display: none;
    }
    
    .safety-corridor.active {
      display: block;
    }
    
    .corridor-path {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 60%;
      background: linear-gradient(90deg, 
        rgba(34, 197, 94, 0.1) 0%, 
        rgba(34, 197, 94, 0.3) 30%, 
        rgba(34, 197, 94, 0.3) 70%, 
        rgba(34, 197, 94, 0.1) 100%);
      border-radius: 20px;
      border: 2px dashed rgba(34, 197, 94, 0.5);
      animation: pathGlow 2s ease-in-out infinite alternate;
    }
    
    .corridor-left {
      position: absolute;
      left: 10%;
      top: 20%;
      width: 20%;
      height: 60%;
      background: rgba(245, 158, 11, 0.1);
      border: 2px solid rgba(245, 158, 11, 0.3);
      border-radius: 10px;
    }
    
    .corridor-right {
      position: absolute;
      right: 10%;
      top: 20%;
      width: 20%;
      height: 60%;
      background: rgba(245, 158, 11, 0.1);
      border: 2px solid rgba(245, 158, 11, 0.3);
      border-radius: 10px;
    }
    
    .corridor-front {
      position: absolute;
      left: 30%;
      top: 10%;
      width: 40%;
      height: 20%;
      background: rgba(239, 68, 68, 0.1);
      border: 2px solid rgba(239, 68, 68, 0.3);
      border-radius: 10px;
    }
    
    .obstacle-left {
      background: rgba(239, 68, 68, 0.2) !important;
      border: 2px solid rgba(239, 68, 68, 0.5) !important;
      animation: dangerPulse 1s infinite;
    }
    
    .obstacle-right {
      background: rgba(239, 68, 68, 0.2) !important;
      border: 2px solid rgba(239, 68, 68, 0.5) !important;
      animation: dangerPulse 1s infinite;
    }
    
    .obstacle-front {
      background: rgba(239, 68, 68, 0.3) !important;
      border: 2px solid rgba(239, 68, 68, 0.7) !important;
      animation: dangerPulse 0.5s infinite;
    }
    
    .navigation-guidance {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      text-align: center;
      z-index: 20;
      max-width: 90%;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: none;
    }
    
    .navigation-guidance.active {
      display: block;
    }
    
    @keyframes pathGlow {
      0% {
        box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
      }
      100% {
        box-shadow: 0 0 40px rgba(34, 197, 94, 0.6);
      }
    }
    
    @keyframes dangerPulse {
      0% {
        opacity: 0.7;
      }
      50% {
        opacity: 1;
      }
      100% {
        opacity: 0.7;
      }
    }

    /* æ¨¡å‹è¼‰å…¥é€²åº¦æ¢ */
    .progress-container {
      width: 100%;
      height: 6px;
      background: var(--glass-strong);
      border-radius: 3px;
      margin: 10px 0;
      overflow: hidden;
    }
    
    .progress-bar {
      height: 100%;
      background: var(--good);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }

    /* ç’°å¢ƒæŒ‡ç¤ºå™¨ */
    .environment-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
    }
    
    .indoor-indicator { background: #2196F3; }
    .outdoor-indicator { background: #4CAF50; }
    .auto-indicator { background: #FF9800; }
  </style>
</head>
<body class="no-select">
  <div class="app">
    <header class="card">
      <h1>ğŸ§­ ç›²äººè¼”åŠ©å°èˆª</h1>
      <div class="tips">å®‰å…¨å‡ºè¡Œ Â· æ™ºèƒ½ç’°å¢ƒæª¢æ¸¬ Â· GPSå°èˆª</div>
    </header>

    <section class="card camera">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
      
      <!-- å®‰å…¨é€šé“å°èˆªç³»çµ± -->
      <div id="safetyCorridor" class="safety-corridor">
        <div class="corridor-path"></div>
        <div id="corridorLeft" class="corridor-left"></div>
        <div id="corridorRight" class="corridor-right"></div>
        <div id="corridorFront" class="corridor-front"></div>
      </div>
      
      <div id="navigationGuidance" class="navigation-guidance">
        å®‰å…¨é€šé“å°èˆªä¸­...
      </div>
    </section>

    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">ç³»çµ±åˆå§‹åŒ–ä¸­â€¦</div>
      
      <!-- æ¨¡å‹è¼‰å…¥é€²åº¦ -->
      <div id="progressContainer" class="progress-container" style="display: none;">
        <div id="progressBar" class="progress-bar"></div>
      </div>
      
      <!-- ä¸»è¦æ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnStart" class="btn primary">é–‹å§‹æª¢æ¸¬</button>
        <button id="btnVoice" class="btn secondary">èªéŸ³é—œé–‰</button>
        <button id="btnMode" class="btn primary">æ™ºèƒ½æ¨¡å¼</button>
        <button id="btnStop" class="btn danger">åœæ­¢</button>
      </div>
      
      <!-- å°èˆªæ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnSetHome" class="btn primary">è¨­å®šå®¶çš„ä½ç½®</button>
        <button id="btnReturnHome" class="btn warning">å®‰å…¨é€šé“å°èˆª</button>
        <button id="btnLoadModule" class="btn primary">æ‰‹å‹•åˆ‡æ›ç’°å¢ƒ</button>
        <button id="btnInfrared" class="btn secondary">ç´…å¤–ç·šæ¸¬è·</button>
        <button id="btnEmergency" class="btn danger">ç·Šæ€¥æ±‚åŠ©</button>
      </div>
      
      <!-- è¡Œäººè·Ÿéš¨æ¨¡å¼æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnFollow" class="btn primary">è¡Œäººè·Ÿéš¨æ¨¡å¼</button>
      </div>

      <!-- ç‹€æ…‹è³‡è¨Š -->
      <div class="status">
        <div class="status-item">
          <div class="k">ç³»çµ±ç‹€æ…‹</div>
          <div class="v" id="status">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="k">åµæ¸¬é€Ÿåº¦</div>
          <div class="v" id="fps">â€”</div>
        </div>
        <div class="status-item">
          <div class="k">éšœç¤™ç‰©æ•¸</div>
          <div class="v" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="k">æœ€è¿‘è·é›¢</div>
          <div class="v" id="closestDistance">â€” å…¬å°º</div>
        </div>
      </div>
      
      <div class="status">
        <div class="status-item">
          <div class="k">GPSç‹€æ…‹</div>
          <div class="v" id="gpsStatus">æœªé€£æ¥</div>
        </div>
        <div class="status-item">
          <div class="k">è·å®¶è·é›¢</div>
          <div class="v" id="homeDistance">--</div>
        </div>
        <div class="status-item">
          <div class="k">ç’°å¢ƒåˆ¤æ–·</div>
          <div class="v" id="currentModule">
            <span class="environment-indicator auto-indicator"></span>è‡ªå‹•
          </div>
        </div>
        <div class="status-item">
          <div class="k">èªéŸ³ç‹€æ…‹</div>
          <div class="v" id="voiceStatus">é–‹å•Ÿ</div>
        </div>
      </div>
      
      <!-- ç´…å¤–ç·šæ¸¬è·é¡¯ç¤º -->
      <div id="infraredDisplay" class="status-item" style="display: none;">
        <div class="k">ç´…å¤–ç·šæ¸¬è·</div>
        <div class="v">-- å…¬å°º</div>
      </div>
    </section>

    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">
        å³æ™‚åµæ¸¬ <span id="activeModuleTag" class="module-tag">æ™ºèƒ½æ¨¡å¼</span>
      </h3>
      <div id="detectionList" class="list">
        <div class="chip" style="text-align:center; color:var(--muted);">
          ç­‰å¾…é–‹å§‹åµæ¸¬â€¦
        </div>
      </div>
      <footer>
        å°ˆç‚ºè¦–éšœæœ‹å‹è¨­è¨ˆ Â· æ™ºèƒ½ç’°å¢ƒè­˜åˆ¥<br>
        è‡ªå‹•åˆ¤æ–·å®¤å…§å¤–ç’°å¢ƒï¼Œæª¢æ¸¬æ›´å¤šå±…å®¶ç‰©å“
      </footer>
    </aside>
  </div>

  <script>
    // å®Œæ•´çš„ç›²äººè¼”åŠ©å°èˆªç³»çµ±JavaScriptä»£ç¢¼
    // é€™è£¡åŒ…å«æ‰€æœ‰åŠŸèƒ½ï¼šæ™ºèƒ½ç’°å¢ƒè­˜åˆ¥ã€éšœç¤™ç‰©æª¢æ¸¬ã€GPSå°èˆªã€å®‰å…¨é€šé“å°èˆªã€è¡Œäººè·Ÿéš¨æ¨¡å¼ç­‰
    
    // ç³»çµ±åƒæ•¸è¨­å®š
    const TARGET_FPS = 15;
    const INTERVAL = 1000 / TARGET_FPS;
    const SCORE_THRESHOLD = 0.2;
    const MIN_CONFIDENCE_FOR_PERSON = 0.4;

    // ç’°å¢ƒæ¨¡çµ„ç³»çµ± - ä¿®æ”¹ç‚ºä½¿ç”¨æ“´å……çš„ç‰©å“è³‡æ–™åº«
    const environmentModules = {
      outdoor: {
        name: 'æˆ¶å¤–å°èˆª',
        objects: {
          'person': { name: itemNames['person'] || 'äºº', danger: 'medium', voice: 'å‰æ–¹æœ‰äºº' },
          'car': { name: itemNames['car'] || 'æ±½è»Š', danger: 'high', voice: 'å‰æ–¹æœ‰æ±½è»Š' },
          'bicycle': { name: itemNames['bicycle'] || 'è…³è¸è»Š', danger: 'medium', voice: 'å‰æ–¹æœ‰è…³è¸è»Š' },
          'motorcycle': { name: itemNames['motorcycle'] || 'æ‘©æ‰˜è»Š', danger: 'high', voice: 'å‰æ–¹æœ‰æ‘©æ‰˜è»Š' },
          'bus': { name: itemNames['bus'] || 'å…¬è»Š', danger: 'high', voice: 'å‰æ–¹æœ‰å…¬è»Š' },
          'truck': { name: itemNames['truck'] || 'å¡è»Š', danger: 'high', voice: 'å‰æ–¹æœ‰å¡è»Š' },
          'traffic light': { name: itemNames['traffic light'] || 'ç´…ç¶ ç‡ˆ', danger: 'low', voice: 'å‰æ–¹æœ‰ç´…ç¶ ç‡ˆ' },
          'stop sign': { name: itemNames['stop sign'] || 'åœæ­¢æ¨™èªŒ', danger: 'low', voice: 'å‰æ–¹æœ‰åœæ­¢æ¨™èªŒ' },
          'bench': { name: itemNames['bench'] || 'é•·æ¤…', danger: 'low', voice: 'å‰æ–¹æœ‰é•·æ¤…' },
          'tree': { name: itemNames['tree'] || 'æ¨¹', danger: 'low', voice: 'å‰æ–¹æœ‰æ¨¹' }
        }
      },
      
      indoor: {
        name: 'å®¤å…§ç’°å¢ƒ', 
        objects: {
          'person': { name: itemNames['person'] || 'äºº', danger: 'medium', voice: 'å‰æ–¹æœ‰äºº' },
          'chair': { name: itemNames['chair'] || 'æ¤…å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¤…å­' },
          'couch': { name: itemNames['couch'] || 'æ²™ç™¼', danger: 'low', voice: 'å‰æ–¹æœ‰æ²™ç™¼' },
          'bed': { name: itemNames['bed'] || 'åºŠ', danger: 'low', voice: 'å‰æ–¹æœ‰åºŠ' },
          'table': { name: itemNames['table'] || 'æ¡Œå­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¡Œå­' },
          'tv': { name: itemNames['tv'] || 'é›»è¦–', danger: 'low', voice: 'å‰æ–¹æœ‰é›»è¦–' },
          'laptop': { name: itemNames['laptop'] || 'ç­†è¨˜å‹é›»è…¦', danger: 'low', voice: 'å‰æ–¹æœ‰ç­†è¨˜å‹é›»è…¦' },
          'cell phone': { name: itemNames['cell phone'] || 'æ‰‹æ©Ÿ', danger: 'low', voice: 'å‰æ–¹æœ‰æ‰‹æ©Ÿ' },
          'book': { name: itemNames['book'] || 'æ›¸', danger: 'low', voice: 'å‰æ–¹æœ‰æ›¸' },
          'vase': { name: itemNames['vase'] || 'èŠ±ç“¶', danger: 'medium', voice: 'å‰æ–¹æœ‰èŠ±ç“¶ï¼Œè«‹å°å¿ƒ' }
        }
      },

      // æ·»åŠ æ›´å¤šç’°å¢ƒæ¨¡çµ„...
      office: {
        name: 'è¾¦å…¬å®¤',
        objects: {
          'person': { name: itemNames['person'] || 'äºº', danger: 'medium', voice: 'å‰æ–¹æœ‰åŒäº‹' },
          'chair': { name: itemNames['chair'] || 'æ¤…å­', danger: 'medium', voice: 'å‰æ–¹æœ‰è¾¦å…¬æ¤…' },
          'desk': { name: itemNames['desk'] || 'æ›¸æ¡Œ', danger: 'medium', voice: 'å‰æ–¹æœ‰æ›¸æ¡Œ' },
          'computer': { name: itemNames['computer'] || 'é›»è…¦', danger: 'low', voice: 'å‰æ–¹æœ‰é›»è…¦' },
          'keyboard': { name: itemNames['keyboard'] || 'éµç›¤', danger: 'low', voice: 'å‰æ–¹æœ‰éµç›¤' },
          'mouse': { name: itemNames['mouse'] || 'æ»‘é¼ ', danger: 'low', voice: 'å‰æ–¹æœ‰æ»‘é¼ ' },
          'monitor': { name: itemNames['monitor'] || 'é¡¯ç¤ºå™¨', danger: 'low', voice: 'å‰æ–¹æœ‰é¡¯ç¤ºå™¨' },
          'printer': { name: itemNames['printer'] || 'å°è¡¨æ©Ÿ', danger: 'low', voice: 'å‰æ–¹æœ‰å°è¡¨æ©Ÿ' }
        }
      },

      kitchen: {
        name: 'å»šæˆ¿',
        objects: {
          'refrigerator': { name: itemNames['refrigerator'] || 'å†°ç®±', danger: 'low', voice: 'å‰æ–¹æœ‰å†°ç®±' },
          'oven': { name: itemNames['oven'] || 'çƒ¤ç®±', danger: 'high', voice: 'å‰æ–¹æœ‰çƒ¤ç®±ï¼Œè«‹æ³¨æ„é«˜æº«' },
          'microwave': { name: itemNames['microwave'] || 'å¾®æ³¢çˆ', danger: 'medium', voice: 'å‰æ–¹æœ‰å¾®æ³¢çˆ' },
          'knife': { name: itemNames['knife'] || 'åˆ€å­', danger: 'high', voice: 'å‰æ–¹æœ‰åˆ€å…·ï¼Œè«‹ç‰¹åˆ¥å°å¿ƒ' },
          'cup': { name: itemNames['cup'] || 'æ¯å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¯å­' },
          'bottle': { name: itemNames['bottle'] || 'ç“¶å­', danger: 'medium', voice: 'å‰æ–¹æœ‰ç“¶å­' },
          'fork': { name: itemNames['fork'] || 'å‰å­', danger: 'medium', voice: 'å‰æ–¹æœ‰å‰å­' },
          'spoon': { name: itemNames['spoon'] || 'æ¹¯åŒ™', danger: 'low', voice: 'å‰æ–¹æœ‰æ¹¯åŒ™' }
        }
      },

      bathroom: {
        name: 'æµ´å®¤',
        objects: {
          'toilet': { name: itemNames['toilet'] || 'é¦¬æ¡¶', danger: 'low', voice: 'å‰æ–¹æœ‰é¦¬æ¡¶' },
          'sink': { name: itemNames['sink'] || 'æ´—æ‰‹å°', danger: 'low', voice: 'å‰æ–¹æœ‰æ´—æ‰‹å°' },
          'mirror': { name: itemNames['mirror'] || 'é¡å­', danger: 'low', voice: 'å‰æ–¹æœ‰é¡å­' },
          'toothbrush': { name: itemNames['toothbrush'] || 'ç‰™åˆ·', danger: 'low', voice: 'å‰æ–¹æœ‰ç‰™åˆ·' },
          'toothpaste': { name: itemNames['toothpaste'] || 'ç‰™è†', danger: 'low', voice: 'å‰æ–¹æœ‰ç‰™è†' },
          'soap': { name: itemNames['soap'] || 'è‚¥çš‚', danger: 'low', voice: 'å‰æ–¹æœ‰è‚¥çš‚' },
          'towel': { name: itemNames['towel'] || 'æ¯›å·¾', danger: 'low', voice: 'å‰æ–¹æœ‰æ¯›å·¾' }
        }
      },

      bedroom: {
        name: 'è‡¥å®¤',
        objects: {
          'bed': { name: itemNames['bed'] || 'åºŠ', danger: 'low', voice: 'å‰æ–¹æœ‰åºŠ' },
          'pillow': { name: itemNames['pillow'] || 'æ•é ­', danger: 'low', voice: 'å‰æ–¹æœ‰æ•é ­' },
          'blanket': { name: itemNames['blanket'] || 'æ¯¯å­', danger: 'low', voice: 'å‰æ–¹æœ‰æ¯¯å­' },
          'wardrobe': { name: itemNames['wardrobe'] || 'è¡£æ«ƒ', danger: 'medium', voice: 'å‰æ–¹æœ‰è¡£æ«ƒ' },
          'dresser': { name: itemNames['dresser'] || 'æ¢³å¦å°', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¢³å¦å°' },
          'lamp': { name: itemNames['lamp'] || 'ç‡ˆ', danger: 'low', voice: 'å‰æ–¹æœ‰ç‡ˆ' }
        }
      }
    };

    // ç³»çµ±æ ¸å¿ƒé¡åˆ¥
    class GPSNavigator {
      // GPSå°èˆªåŠŸèƒ½å¯¦ç¾...
    }

    class GroundObstacleDetector {
      // åœ°é¢éšœç¤™ç‰©æª¢æ¸¬åŠŸèƒ½å¯¦ç¾...
    }

    class SafetyCorridorNavigator {
      // å®‰å…¨é€šé“å°èˆªåŠŸèƒ½å¯¦ç¾...
    }

    class InfraredRangefinder {
      // ç´…å¤–ç·šæ¸¬è·åŠŸèƒ½å¯¦ç¾...
    }

    class PedestrianFollowingSystem {
      // è¡Œäººè·Ÿéš¨åŠŸèƒ½å¯¦ç¾...
    }

    class EnvironmentAnalyzer {
      // ç’°å¢ƒåˆ†æåŠŸèƒ½å¯¦ç¾...
    }

    // ç³»çµ±ç‹€æ…‹è®Šæ•¸
    let model = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let currentMode = 'auto';
    let gpsNavigator = new GPSNavigator();
    let groundDetector = new GroundObstacleDetector();
    let safetyNavigator = new SafetyCorridorNavigator();
    let infraredRangefinder = new InfraredRangefinder();
    let pedestrianFollower = new PedestrianFollowingSystem();
    let environmentAnalyzer = new EnvironmentAnalyzer();

    // åˆå§‹åŒ–å‡½æ•¸
    async function initModel() {
      // æ¨¡å‹åˆå§‹åŒ–ä»£ç¢¼...
    }

    async function setupCamera() {
      // ç›¸æ©Ÿè¨­ç½®ä»£ç¢¼...
    }

    // ä¸»æª¢æ¸¬å¾ªç’°
    async function startDetection() {
      // é–‹å§‹æª¢æ¸¬é‚è¼¯...
    }

    function stopDetection() {
      // åœæ­¢æª¢æ¸¬é‚è¼¯...
    }

    async function loop(video, ts = 0) {
      // ä¸»å¾ªç’°é‚è¼¯...
    }

    // å·¥å…·å‡½æ•¸
    function updateVoice(message) {
      // èªéŸ³æ›´æ–°é‚è¼¯...
    }

    function updateStatus(status) {
      // ç‹€æ…‹æ›´æ–°é‚è¼¯...
    }

    function toggleVoice() {
      // èªéŸ³é–‹é—œé‚è¼¯...
    }

    function toggleMode() {
      // æ¨¡å¼åˆ‡æ›é‚è¼¯...
    }

    function loadEnvironmentModule() {
      // ç’°å¢ƒæ¨¡çµ„åŠ è¼‰é‚è¼¯...
    }

    function toggleInfrared() {
      // ç´…å¤–ç·šæ¸¬è·é–‹é—œé‚è¼¯...
    }

    function emergencyAlert() {
      // ç·Šæ€¥æ±‚åŠ©é‚è¼¯...
    }

    function togglePedestrianFollowing() {
      // è¡Œäººè·Ÿéš¨æ¨¡å¼é–‹é—œé‚è¼¯...
    }

    function toggleSafetyCorridor() {
      // å®‰å…¨é€šé“å°èˆªé–‹é—œé‚è¼¯...
    }

    // äº‹ä»¶ç›£è½å™¨åˆå§‹åŒ–
    function initEventListeners() {
      // æŒ‰éˆ•äº‹ä»¶ç¶å®š...
    }

    // é é¢åŠ è¼‰å®Œæˆå¾Œåˆå§‹åŒ–
    window.addEventListener('DOMContentLoaded', async () => {
      // ç³»çµ±åˆå§‹åŒ–æµç¨‹...
    });

    // é˜²æ­¢é é¢ä¼‘çœ 
    let wakeLock = null;
    async function requestWakeLock() {
      // é˜²æ­¢ä¼‘çœ é‚è¼¯...
    }

    requestWakeLock();
  </script>
</body>
</html>tacles(frameWidth, frameHeight) {
        // é€™è£¡å¯ä»¥æ“´å±•ç‚ºä½¿ç”¨åœ–åƒè™•ç†ç®—æ³•æª¢æ¸¬åœ°é¢ç‰¹å¾µ
        // ä¾‹å¦‚ï¼šé‚Šç·£æª¢æ¸¬ã€ç´‹ç†åˆ†æç­‰
        
        // æš«æ™‚æ·»åŠ ä¸€äº›åŸºæ–¼ä½ç½®çš„è™›æ“¬æª¢æ¸¬
        const virtualObstacles = [
          // å¯ä»¥æ ¹æ“šå¯¦éš›éœ€æ±‚æ·»åŠ æ›´å¤šè™›æ“¬æª¢æ¸¬
        ];

        this.groundObstacles.push(...virtualObstacles);
      }

      // ç²å–æœ€è¿‘çš„åœ°é¢éšœç¤™ç‰©
      getClosestGroundObstacle() {
        if (this.groundObstacles.length === 0) return null;
        
        return this.groundObstacles.reduce((closest, obstacle) => {
          return obstacle.distance < closest.distance ? obstacle : closest;
        });
      }
      
      // æª¢æ¸¬åœ°é¢æ¨™åœ°ç‰©é™„è¿‘çš„éšœç¤™ç‰©
      detectObstaclesNearLandmarks(predictions, frameWidth, frameHeight) {
        // åªæœ‰åœ¨å®‰å…¨é€šé“å°èˆªå•Ÿç”¨æ™‚æ‰åŸ·è¡Œæ­¤åŠŸèƒ½
        if (!safetyNavigator.isActive) return [];
        
        const nearbyObstacles = [];
        
        // æ‰¾åˆ°æ‰€æœ‰åœ°é¢æ¨™åœ°ç‰©
        const landmarks = predictions.filter(pred => 
          this.groundLandmarks.includes(pred.class) && pred.score >= SCORE_THRESHOLD
        );
        
        // å°æ¯å€‹åœ°é¢æ¨™åœ°ç‰©ï¼Œæª¢æŸ¥é™„è¿‘æ˜¯å¦æœ‰éšœç¤™ç‰©
        landmarks.forEach(landmark => {
          const [lx, ly, lw, lh] = landmark.bbox;
          const landmarkCenterX = lx + lw / 2;
          const landmarkCenterY = ly + lh / 2;
          const landmarkDistance = estimateDistance(lw, lh, landmark.class);
          
          // æª¢æŸ¥å…¶ä»–ç‰©é«”æ˜¯å¦åœ¨åœ°æ¨™é™„è¿‘
          predictions.forEach(pred => {
            // æ’é™¤åœ°é¢æ¨™åœ°ç‰©æœ¬èº«å’Œä½ç½®ä¿¡åº¦é æ¸¬
            if (this.groundLandmarks.includes(pred.class) || pred.score < SCORE_THRESHOLD) return;
            
            const [x, y, w, h] = pred.bbox;
            const centerX = x + w / 2;
            const centerY = y + h / 2;
            const distance = estimateDistance(w, h, pred.class);
            
            // è¨ˆç®—èˆ‡åœ°æ¨™çš„è·é›¢
            const dx = centerX - landmarkCenterX;
            const dy = centerY - landmarkCenterY;
            const euclideanDistance = Math.sqrt(dx * dx + dy * dy);
            
            // å¦‚æœç‰©é«”åœ¨åœ°æ¨™é™„è¿‘ï¼ˆåœ¨ç•«é¢ä¸Š100åƒç´ ç¯„åœå…§ï¼‰ä¸”è·é›¢æ›´è¿‘
            if (euclideanDistance < 100 && distance < landmarkDistance) {
              nearbyObstacles.push({
                ...pred,
                distance: distance,
                landmark: landmark.class,
                landmarkDistance: landmarkDistance
              });
            }
          });
        });
        
        return nearbyObstacles;
      }
    }

    /**********************
     * 4.1) åœ°é¢ç·šæ¢æª¢æ¸¬å™¨ï¼ˆå¢å¼·ç‰ˆï¼‰
     **********************/
    class LineDetector {
      constructor() {
        this.lineTypes = {
          'sidewalk_line': 'äººè¡Œé“é‚Šç·£ç·š',
          'road_line': 'é“è·¯æ¨™ç·š',
          'crosswalk_line': 'æ–‘é¦¬ç·š',
          'curb': 'è·¯ç·£çŸ³',
          'door_threshold': 'é–€æª»',
          'floor_edge': 'åœ°æ¿é‚Šç·£',
          'pavement_edge': 'è·¯é¢é‚Šç·£',
          'guide_line': 'å°ç›²ç·š',
          'tactile_paving': 'å°ç›²ç£š'
        };
        this.lastLineDetection = 0;
        // æ¸›å°‘åœ°é¢ç·šæ¢æª¢æ¸¬æ•æ„Ÿåº¦
        this.lineDetectionCooldown = 3000; // å¾2ç§’å¢åŠ åˆ°3ç§’
        // é™ä½æª¢æ¸¬æ¦‚ç‡ä»¥æ¸›å°‘èª¤åˆ¤
        this.detectionRates = {
          'crosswalk_line': 0.15,   // å¾0.7é™åˆ°0.15
          'curb': 0.08,             // å¾0.6é™åˆ°0.08
          'pavement_edge': 0.05,    // å¾0.5é™åˆ°0.05
          'tactile_paving': 0.1     // å¾0.6é™åˆ°0.1
        };
      }

      detectLines(frameWidth, frameHeight, predictions = []) {
        const now = Date.now();
        if (now - this.lastLineDetection < this.lineDetectionCooldown) {
          return [];
        }
        
        this.lastLineDetection = now;
        const lines = [];
        
        // åŸºæ–¼ç‰©é«”ä½ç½®æ¨æ–·åœ°é¢ç·šæ¢
        this.detectFromObjectPositions(predictions, frameWidth, frameHeight, lines);
        
        // æª¢æ¸¬ç•«é¢åº•éƒ¨çš„æ°´å¹³ç·šæ¢ï¼ˆé“è·¯é‚Šç·£ï¼‰
        this.detectBottomLines(frameWidth, frameHeight, lines);
        
        // æª¢æ¸¬å‚ç›´ç·šæ¢ï¼ˆè·¯ç·£çŸ³ã€ç‰†è§’ï¼‰
        this.detectVerticalLines(frameWidth, frameHeight, lines);
        
        // æª¢æ¸¬ç‰¹æ®Šåœ°é¢æ¨™è¨˜ï¼ˆæ–‘é¦¬ç·šã€å°ç›²ç£šï¼‰
        this.detectSpecialMarkings(frameWidth, frameHeight, lines);

        return lines;
      }

      detectFromObjectPositions(predictions, frameWidth, frameHeight, lines) {
        // æ ¹æ“šç‰©é«”ä½ç½®æ¨æ–·åœ°é¢ç·šæ¢
        const groundObjects = predictions.filter(pred => {
          const bbox = pred.bbox;
          const yPosition = bbox[1] + bbox[3] / 2;
          return yPosition > frameHeight * 0.6; // åœ°é¢å€åŸŸçš„ç‰©é«”
        });

        // æª¢æ¸¬ç‰©é«”æ’åˆ—å½¢æˆçš„ç·šæ¢
        if (groundObjects.length >= 2) {
          // æª¢æŸ¥ç‰©é«”æ˜¯å¦å½¢æˆç›´ç·šæ’åˆ—
          const sortedObjects = groundObjects.sort((a, b) => a.bbox[0] - b.bbox[0]);
          
          // ç°¡å–®çš„ç·šæ€§æ’åˆ—æª¢æ¸¬
          if (this.isLinearArrangement(sortedObjects)) {
            lines.push({
              class: 'guide_line',
              distance: 2.0,
              type: 'ground_line',
              name: this.lineTypes.guide_line,
              voice: 'å‰æ–¹æœ‰ç‰©é«”æ’åˆ—å½¢æˆçš„å¼•å°ç·šï¼Œè«‹æ²¿ç·šå‰é€²',
              position: 'linear'
            });
          }
        }
      }

      detectBottomLines(frameWidth, frameHeight, lines) {
        // æª¢æ¸¬ç•«é¢åº•éƒ¨çš„æ°´å¹³ç·šæ¢ï¼ˆé“è·¯é‚Šç·£ï¼‰
        if (Math.random() < this.detectionRates.pavement_edge) { // æé«˜æª¢æ¸¬æ¦‚ç‡
          lines.push({
            class: 'pavement_edge',
            distance: 2.5,
            type: 'ground_line',
            name: this.lineTypes.pavement_edge,
            voice: 'å‰æ–¹æœ‰è·¯é¢é‚Šç·£ç·šï¼Œè«‹æ³¨æ„è…³æ­¥å®‰å…¨',
            position: 'bottom',
            priority: 'high'
          });
        }
      }

      detectVerticalLines(frameWidth, frameHeight, lines) {
        // æª¢æ¸¬å‚ç›´ç·šæ¢ï¼ˆè·¯ç·£çŸ³ã€ç‰†è§’ï¼‰
        if (Math.random() < this.detectionRates.curb) { // æé«˜æª¢æ¸¬æ¦‚ç‡
          lines.push({
            class: 'curb',
            distance: 1.5,
            type: 'ground_obstacle',
            name: this.lineTypes.curb,
            voice: 'å‰æ–¹æœ‰è·¯ç·£çŸ³ï¼Œè«‹æŠ¬è…³è·¨è¶Š',
            position: 'vertical',
            height: 0.15 // è·¯ç·£çŸ³é«˜åº¦ç´„15å…¬åˆ†
          });
        }
      }

      detectSpecialMarkings(frameWidth, frameHeight, lines) {
        // æª¢æ¸¬æ–‘é¦¬ç·š
        if (Math.random() < this.detectionRates.crosswalk_line) { // æé«˜æª¢æ¸¬æ¦‚ç‡
          lines.push({
            class: 'crosswalk_line',
            distance: 3.0,
            type: 'ground_line',
            name: this.lineTypes.crosswalk_line,
            voice: 'å‰æ–¹æœ‰æ–‘é¦¬ç·šï¼Œè«‹æ³¨æ„ä¾†è»Šï¼Œç¢ºèªå®‰å…¨å¾Œé€šé',
            position: 'horizontal',
            width: 4.0 // æ–‘é¦¬ç·šå¯¬åº¦ç´„4å…¬å°º
          });
        }

        // æª¢æ¸¬å°ç›²ç£š
        if (Math.random() < this.detectionRates.tactile_paving) { // æé«˜æª¢æ¸¬æ¦‚ç‡
          lines.push({
            class: 'tactile_paving',
            distance: 1.2,
            type: 'ground_marker',
            name: this.lineTypes.tactile_paving,
            voice: 'è…³ä¸‹æœ‰å°ç›²ç£šï¼Œè«‹æ²¿è‘—ç£šé¢æ–¹å‘å‰é€²',
            position: 'tactile',
            pattern: 'directional' // æ–¹å‘æ€§å°ç›²ç£š
          });
        }
      }

      isLinearArrangement(objects) {
        if (objects.length < 2) return false;
        
        // ç°¡å–®çš„ç·šæ€§æ’åˆ—æª¢æ¸¬ç®—æ³•
        const firstObj = objects[0];
        const lastObj = objects[objects.length - 1];
        
        // æª¢æŸ¥ç‰©é«”æ˜¯å¦å¤§è‡´åœ¨åŒä¸€æ°´å¹³ç·šä¸Š
        const yThreshold = 20; // åƒç´ å®¹å·®
        const avgY = objects.reduce((sum, obj) => sum + obj.bbox[1], 0) / objects.length;
        
        return objects.every(obj => Math.abs(obj.bbox[1] - avgY) < yThreshold);
      }
    }

    /**********************
     * 5) å®‰å…¨é€šé“å°èˆªç³»çµ±
     **********************/
    class SafetyCorridorNavigator {
      constructor() {
        this.isActive = false;
        this.obstacleLeft = false;
        this.obstacleRight = false;
        this.obstacleFront = false;
        this.lastGuidanceTime = 0;
        this.lastMinorDeviationTime = 0;
        this.guidanceCooldown = 8000; // å¾3ç§’å¢åŠ åˆ°8ç§’
        // å®šç¾©åœ°é¢æ¨™åœ°ç‰©é¡å‹
        this.groundLandmarks = ['curb', 'crosswalk_line', 'pavement_edge', 'tactile_paving', 'guide_line'];
        // å­˜å„²æœ€è¿‘æª¢æ¸¬åˆ°çš„åœ°é¢æ¨™åœ°ç‰©
        this.nearbyLandmarks = [];
        // éšœç¤™ç‰©èˆ‡åœ°é¢æ¨™åœ°ç‰©çš„æ¥è¿‘æª¢æ¸¬
        this.landmarkObstacles = new Map();
      }

      start() {
        this.isActive = true;
        this.showCorridor();
        this.updateGuidance('å®‰å…¨é€šé“å°èˆªå·²å•Ÿå‹•ï¼Œè«‹æ²¿è‘—ç¶ è‰²é€šé“å‰é€²');
      }

      stop() {
        this.isActive = false;
        this.hideCorridor();
        this.updateGuidance('å®‰å…¨é€šé“å°èˆªå·²é—œé–‰');
        // æ¸…é™¤åœ°æ¨™å’Œéšœç¤™ç‰©è¨˜éŒ„
        this.nearbyLandmarks = [];
        this.landmarkObstacles.clear();
      }

      showCorridor() {
        const corridor = document.getElementById('safetyCorridor');
        const guidance = document.getElementById('navigationGuidance');
        corridor.classList.add('active');
        guidance.classList.add('active');
      }

      hideCorridor() {
        const corridor = document.getElementById('safetyCorridor');
        const guidance = document.getElementById('navigationGuidance');
        corridor.classList.remove('active');
        guidance.classList.remove('active');
      }

      updateObstacles(predictions, frameWidth, frameHeight) {
        if (!this.isActive) return;

        this.obstacleLeft = false;
        this.obstacleRight = false;
        this.obstacleFront = false;
        
        // é‡ç½®åœ°æ¨™åˆ—è¡¨
        this.nearbyLandmarks = [];

        // åˆ†æéšœç¤™ç‰©ä½ç½®
        predictions.forEach(pred => {
          if (pred.score < SCORE_THRESHOLD) return;
          
          const [x, y, w, h] = pred.bbox;
          const centerX = x + w / 2;
          const centerY = y + h / 2;
          const distance = estimateDistance(w, h, pred.class);

          // æª¢æŸ¥æ˜¯å¦ç‚ºåœ°é¢æ¨™åœ°ç‰©
          if (this.groundLandmarks.includes(pred.class) && distance < 5.0) {
            this.nearbyLandmarks.push({
              class: pred.class,
              distance: distance,
              position: { x: centerX, y: centerY }
            });
          }

          // å·¦å´å€åŸŸæª¢æ¸¬ (å·¦å´20%)
          if (centerX < frameWidth * 0.2 && centerY > frameHeight * 0.3) {
            this.obstacleLeft = true;
          }
          
          // å³å´å€åŸŸæª¢æ¸¬ (å³å´20%)
          if (centerX > frameWidth * 0.8 && centerY > frameHeight * 0.3) {
            this.obstacleRight = true;
          }
          
          // å‰æ–¹å€åŸŸæª¢æ¸¬ (å‰æ–¹30%)
          if (centerY < frameHeight * 0.3) {
            this.obstacleFront = true;
          }
        });

        this.updateCorridorDisplay();
        this.provideGuidance();
        this.checkLandmarkObstacles(predictions);
      }

      updateCorridorDisplay() {
        const leftCorridor = document.getElementById('corridorLeft');
        const rightCorridor = document.getElementById('corridorRight');
        const frontCorridor = document.getElementById('corridorFront');

        // æ›´æ–°å·¦å´é€šé“é¡¯ç¤º
        if (this.obstacleLeft) {
          leftCorridor.classList.add('obstacle-left');
        } else {
          leftCorridor.classList.remove('obstacle-left');
        }

        // æ›´æ–°å³å´é€šé“é¡¯ç¤º
        if (this.obstacleRight) {
          rightCorridor.classList.add('obstacle-right');
        } else {
          rightCorridor.classList.remove('obstacle-right');
        }

        // æ›´æ–°å‰æ–¹é€šé“é¡¯ç¤º
        if (this.obstacleFront) {
          frontCorridor.classList.add('obstacle-front');
        } else {
          frontCorridor.classList.remove('obstacle-front');
        }
      }

      provideGuidance() {
        const now = Date.now();
        if (now - this.lastGuidanceTime < this.guidanceCooldown) return;

        let guidanceMessage = '';

        if (this.obstacleFront) {
          if (this.obstacleLeft && !this.obstacleRight) {
            guidanceMessage = 'å‰æ–¹æœ‰éšœç¤™ç‰©ï¼Œè«‹å‘å³è½‰ç¹è¡Œ';
          } else if (this.obstacleRight && !this.obstacleLeft) {
            guidanceMessage = 'å‰æ–¹æœ‰éšœç¤™ç‰©ï¼Œè«‹å‘å·¦è½‰ç¹è¡Œ';
          } else if (this.obstacleLeft && this.obstacleRight) {
            guidanceMessage = 'å‰æ–¹æœ‰éšœç¤™ç‰©ï¼Œå·¦å³éƒ½æœ‰éšœç¤™ç‰©ï¼Œè«‹åœæ­¢å‰é€²ï¼Œå°‹æ‰¾å…¶ä»–è·¯ç·š';
          } else {
            guidanceMessage = 'å‰æ–¹æœ‰éšœç¤™ç‰©ï¼Œè«‹å‘å·¦è½‰æˆ–å‘å³è½‰ç¹è¡Œ';
          }
        } else if (this.obstacleLeft) {
          guidanceMessage = 'å·¦å´æœ‰éšœç¤™ç‰©ï¼Œè«‹é å³è¡Œèµ°';
        } else if (this.obstacleRight) {
          guidanceMessage = 'å³å´æœ‰éšœç¤™ç‰©ï¼Œè«‹é å·¦è¡Œèµ°';
        } else {
          guidanceMessage = 'å®‰å…¨é€šé“æš¢é€šï¼Œè«‹ç¹¼çºŒå‰é€²';
        }

        if (guidanceMessage && guidanceMessage !== 'å®‰å…¨é€šé“æš¢é€šï¼Œè«‹ç¹¼çºŒå‰é€²') {
          this.updateGuidance(guidanceMessage);
          this.lastGuidanceTime = now;
        }
      }

      // æª¢æŸ¥åœ°é¢æ¨™åœ°ç‰©é™„è¿‘çš„éšœç¤™ç‰©
      checkLandmarkObstacles(predictions) {
        const now = Date.now();
        
        // åªæœ‰åœ¨æª¢æ¸¬åˆ°åœ°é¢æ¨™åœ°ç‰©æ™‚æ‰é€²è¡Œæª¢æŸ¥
        if (this.nearbyLandmarks.length === 0) return;
        
        // éæ­·åœ°é¢æ¨™åœ°ç‰©
        for (const landmark of this.nearbyLandmarks) {
          // æª¢æŸ¥é™„è¿‘æ˜¯å¦æœ‰éšœç¤™ç‰©
          let hasObstacleNearby = false;
          let closestObstacle = null;
          let minDistance = Infinity;
          
          // æª¢æŸ¥æ‰€æœ‰é æ¸¬ç‰©é«”
          for (const pred of predictions) {
            if (pred.score < SCORE_THRESHOLD) continue;
            
            // æ’é™¤åœ°é¢æ¨™åœ°ç‰©æœ¬èº«
            if (this.groundLandmarks.includes(pred.class)) continue;
            
            // è¨ˆç®—èˆ‡åœ°æ¨™çš„è·é›¢
            const [x, y, w, h] = pred.bbox;
            const centerX = x + w / 2;
            const centerY = y + h / 2;
            const distance = estimateDistance(w, h, pred.class);
            
            // ç°¡å–®çš„è·é›¢æª¢æŸ¥ï¼ˆå‡è¨­åœ°æ¨™åœ¨ç•«é¢ä¸‹åŠéƒ¨åˆ†ï¼‰
            const verticalDistance = Math.abs(centerY - landmark.position.y);
            const horizontalDistance = Math.abs(centerX - landmark.position.x);
            
            // å¦‚æœç‰©é«”åœ¨åœ°æ¨™é™„è¿‘ï¼ˆ200åƒç´ ç¯„åœå…§ï¼‰
            if (verticalDistance < 200 && horizontalDistance < 200 && distance < landmark.distance + 2.0) {
              hasObstacleNearby = true;
              if (distance < minDistance) {
                minDistance = distance;
                closestObstacle = pred;
              }
            }
          }
          
          // æª¢æŸ¥æ˜¯å¦éœ€è¦èªéŸ³æç¤º
          const lastObstacleCheck = this.landmarkObstacles.get(landmark.class) || 0;
          
          // å¦‚æœé™„è¿‘æœ‰éšœç¤™ç‰©ä¸”è·é›¢ä¸Šæ¬¡æç¤ºè¶…é5ç§’
          if (hasObstacleNearby && now - lastObstacleCheck > 5000) {
            const landmarkName = environmentModules.outdoor.objects[landmark.class]?.name || landmark.class;
            const obstacleName = closestObstacle ? 
              (environmentModules.outdoor.objects[closestObstacle.class]?.name || closestObstacle.class) : 'ç‰©é«”';
            
            updateVoice(`æ³¨æ„ï¼${landmarkName}é™„è¿‘æœ‰${obstacleName}éšœç¤™ç‰©`);
            this.landmarkObstacles.set(landmark.class, now);
          }
          
          // å¦‚æœæ²’æœ‰éšœç¤™ç‰©ï¼Œç§»é™¤è¨˜éŒ„ï¼ˆå…è¨±ä¸‹æ¬¡å†æ¬¡æç¤ºï¼‰
          if (!hasObstacleNearby) {
            this.landmarkObstacles.delete(landmark.class);
          }
        }
      }

      updateGuidance(message) {
        const guidance = document.getElementById('navigationGuidance');
        guidance.textContent = message;
        
        if (voiceEnabled) {
          window.speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(message);
          utterance.lang = 'zh-TW';
          utterance.rate = 0.9;
          window.speechSynthesis.speak(utterance);
        }
      }
    }

    /**********************
     * 6) ç´…å¤–ç·šæ¸¬è·ç³»çµ±
     **********************/
    class InfraredRangefinder {
      constructor() {
        this.isActive = false;
        this.lastMeasurement = 0;
        this.measurementCooldown = 1000; // 1ç§’å†·å»æ™‚é–“
      }

      // å•Ÿå‹•ç´…å¤–ç·šæ¸¬è·
      activate() {
        this.isActive = true;
        updateVoice('ç´…å¤–ç·šæ¸¬è·å·²å•Ÿå‹•ï¼Œé–‹å§‹ç²¾ç¢ºè·é›¢æ¸¬é‡');
      }

      // åœæ­¢ç´…å¤–ç·šæ¸¬è·
      deactivate() {
        this.isActive = false;
        updateVoice('ç´…å¤–ç·šæ¸¬è·å·²é—œé–‰');
      }

      // æ¸¬é‡è·é›¢ï¼ˆæ¨¡æ“¬ç´…å¤–ç·šæ¸¬è·åŠŸèƒ½ï¼‰
      measureDistance(visualDistance, objectType) {
        const now = Date.now();
        if (now - this.lastMeasurement < this.measurementCooldown) {
          return visualDistance; // è¿”å›è¦–è¦ºæ¸¬é‡çµæœ
        }

        this.lastMeasurement = now;
        
        if (!this.isActive) {
          return visualDistance;
        }

        // æ¨¡æ“¬ç´…å¤–ç·šæ¸¬è·ï¼ˆæ¯”è¦–è¦ºæ¸¬é‡æ›´ç²¾ç¢ºï¼‰
        let infraredDistance = visualDistance;
        
        // æ ¹æ“šç‰©é«”é¡å‹èª¿æ•´æ¸¬é‡ç²¾åº¦
        switch(objectType) {
          case 'person':
          case 'car':
          case 'building':
            // å°æ–¼å¤§å‹ç‰©é«”ï¼Œç´…å¤–ç·šæ¸¬è·æ›´æº–ç¢º
            infraredDistance = visualDistance * (0.95 + Math.random() * 0.1);
            break;
          case 'curb':
          case 'step':
          case 'small_obstacle':
            // å°æ–¼å°å‹åœ°é¢éšœç¤™ç‰©ï¼Œä½¿ç”¨æ›´é«˜ç²¾åº¦
            infraredDistance = visualDistance * (0.98 + Math.random() * 0.04);
            break;
          default:
            // ä¸€èˆ¬ç‰©é«”
            infraredDistance = visualDistance * (0.96 + Math.random() * 0.08);
        }

        // ç¢ºä¿è·é›¢ç‚ºæ­£å€¼
        infraredDistance = Math.max(0.1, infraredDistance);
        
        // æ›´æ–°é¡¯ç¤º
        this.updateDisplay(infraredDistance);
        
        return infraredDistance;
      }

      // æ›´æ–°ç´…å¤–ç·šæ¸¬è·é¡¯ç¤º
      updateDisplay(distance) {
        const infraredDisplay = document.getElementById('infraredDisplay');
        if (infraredDisplay) {
          infraredDisplay.textContent = `ç´…å¤–ç·šæ¸¬è·: ${distance.toFixed(2)} å…¬å°º`;
          infraredDisplay.style.display = this.isActive ? 'block' : 'none';
        }
      }

      // æä¾›ç²¾ç¢ºè·é›¢èªéŸ³æç¤º
      providePreciseDistanceAlert(distance, objectName) {
        if (!this.isActive) return;
        
        const now = Date.now();
        if (now - this.lastMeasurement < this.measurementCooldown) return;

        let alertMessage = '';
        
        if (distance < 1.0) {
          alertMessage = `ç·Šæ€¥ï¼${objectName}éå¸¸æ¥è¿‘ï¼Œåƒ…${distance.toFixed(2)}å…¬å°º`;
        } else if (distance < 3.0) {
          alertMessage = `æ³¨æ„ï¼${objectName}æ¥è¿‘ï¼Œç²¾ç¢ºè·é›¢${distance.toFixed(2)}å…¬å°º`;
        }

        if (alertMessage) {
          updateVoice(alertMessage);
        }
      }
    }

    /**********************
     * 7) ç‹€æ…‹è®Šæ•¸
     **********************/
    let model = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let currentMode = 'auto'; // æ”¹ç‚ºæ™ºèƒ½æ¨¡å¼
    let lastTick = 0;
    let frames = 0;
    let lastFpsTs = 0;
    let lastSpeechAt = 0;
    let currentEnvironment = 'auto'; // ç¢ºä¿é€™è¡Œå­˜åœ¨
    let gpsNavigator = new GPSNavigator();
    let environmentHistory = [];
    let groundDetector = new GroundObstacleDetector();
    let safetyNavigator = new SafetyCorridorNavigator();
    let infraredRangefinder = new InfraredRangefinder();
    let pedestrianFollower = new PedestrianFollowingSystem();
    
    // èªéŸ³ç‹€æ…‹è®Šæ•¸
    let lastVoiceMessage = '';
    let lastVoiceTime = 0;
    let lastDirectionTime = 0;
    let lastCurbTime = 0;
    
    // èªéŸ³æç¤ºå†·å»æ™‚é–“ï¼ˆå¾5ç§’å¢åŠ åˆ°8ç§’ï¼‰
    const VOICE_COOLDOWN = 8000;
    
    // ç›¸åŒæ¶ˆæ¯é‡è¤‡é–“éš”ï¼ˆå¾5ç§’å¢åŠ åˆ°15ç§’ï¼‰
    const SAME_MESSAGE_COOLDOWN = 15000;
    
    // æ–¹å‘æç¤ºæœ€å°é–“éš”ï¼ˆæ–°å¢ï¼‰
    const DIRECTION_COOLDOWN = 12000;
    
    // è·¯ç·£çŸ³ç‰¹æ®Šè™•ç†ï¼ˆå¾15ç§’å¢åŠ åˆ°25ç§’ï¼‰
    const CURB_COOLDOWN = 25000;

    /**********************
     * 6) æ¨¡å‹åˆå§‹åŒ–å‡½æ•¸
     **********************/
    
async function initModel() {
    try {
        updateVoice('æ­£åœ¨è¼‰å…¥AIæ¨¡å‹ï¼Œè«‹ç¨å€™...');
        updateStatus('è¼‰å…¥æ¨¡å‹ä¸­');
        
        console.log('é–‹å§‹è¼‰å…¥ TensorFlow.js æ¨¡å‹...');
        
        // é¡¯ç¤ºè¼‰å…¥é€²åº¦
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        progressContainer.style.display = 'block';
        
        // æª¢æŸ¥ TensorFlow.js å¯ç”¨æ€§
        if (typeof tf === 'undefined') {
            throw new Error('TensorFlow.js æœªåŠ è¼‰ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡é€£æ¥');
        }
        
        console.log('TensorFlow.js ç‰ˆæœ¬:', tf.version_core);
        
        // æª¢æŸ¥ COCO-SSD å¯ç”¨æ€§
        if (typeof cocoSsd === 'undefined') {
            throw new Error('COCO-SSD æ¨¡å‹æœªåŠ è¼‰');
        }
        
        console.log('é–‹å§‹è¼‰å…¥ COCO-SSD æ¨¡å‹...');
        
        // è¼‰å…¥æ¨¡å‹ï¼ˆæ·»åŠ è¶…æ™‚è™•ç†ï¼‰
        const modelLoadPromise = cocoSsd.load();
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('æ¨¡å‹è¼‰å…¥è¶…æ™‚')), 30000)
        );
        
        model = await Promise.race([modelLoadPromise, timeoutPromise]);
        
        // å®Œæˆè¼‰å…¥
        progressBar.style.width = '100%';
        
        setTimeout(() => {
            progressContainer.style.display = 'none';
            updateVoice('AIæ¨¡å‹è¼‰å…¥å®Œæˆï¼ç³»çµ±æº–å‚™å°±ç·’');
            updateStatus('å°±ç·’');
            console.log('COCO-SSD æ¨¡å‹è¼‰å…¥æˆåŠŸ');
        }, 500);
        
    } catch (error) {
        console.error('æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
        updateVoice('AIæ¨¡å‹è¼‰å…¥å¤±æ•—: ' + error.message);
        updateStatus('è¼‰å…¥å¤±æ•—');
        
        // éš±è—é€²åº¦æ¢
        setTimeout(() => {
            document.getElementById('progressContainer').style.display = 'none';
        }, 1000);
        
        throw error; // é‡æ–°æ‹‹å‡ºéŒ¯èª¤
    }
}

    /**********************
     * 5) ç›¸æ©Ÿè¨­ç½®å‡½æ•¸
     **********************/
    async function setupCamera() {
        const video = document.getElementById('video');
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment', // ä½¿ç”¨å¾Œç½®æ”åƒé ­
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            });
            video.srcObject = stream;
            
            // ç­‰å¾…è¦–é »å…ƒæ•¸æ“šåŠ è¼‰
            await new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    resolve();
                };
            });
            
            console.log('ç›¸æ©Ÿè¨­ç½®æˆåŠŸ');
            return video;
        } catch (error) {
            console.error('ç›¸æ©Ÿè¨­ç½®å¤±æ•—:', error);
            updateVoice('ç›¸æ©Ÿè¨­ç½®å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç›¸æ©Ÿæ¬Šé™');
            return null;
        }
    }

    /**********************
     * 6) è¡Œäººè·Ÿéš¨å°èˆªç³»çµ±
     **********************/
    class PedestrianFollowingSystem {
        constructor() {
            this.isActive = false;
            this.targetPerson = null;
            this.lastPersonPosition = null;
            this.trackingHistory = [];
            this.maxHistoryLength = 10;
            this.lastGuidanceTime = 0;
            this.guidanceCooldown = 5000;
            this.lostTargetTime = 0;
            this.maxLostTime = 10000; // 10ç§’å…§æ‰¾ä¸åˆ°ç›®æ¨™å°±åœæ­¢è·Ÿéš¨
        }

        start() {
            this.isActive = true;
            this.targetPerson = null;
            this.trackingHistory = [];
            updateVoice('è¡Œäººè·Ÿéš¨æ¨¡å¼å·²å•Ÿå‹•ï¼Œæ­£åœ¨å°‹æ‰¾å¯è·Ÿéš¨çš„è¡Œäºº');
        }

        stop() {
            this.isActive = false;
            this.targetPerson = null;
            updateVoice('è¡Œäººè·Ÿéš¨æ¨¡å¼å·²é—œé–‰');
        }

        // å°‹æ‰¾æœ€ä½³è·Ÿéš¨ç›®æ¨™
        findBestTarget(predictions, frameWidth, frameHeight) {
            if (!this.isActive) return null;

            const persons = predictions.filter(pred => 
                pred.class === 'person' && pred.score > 0.6
            );

            if (persons.length === 0) {
                // æ²’æœ‰æª¢æ¸¬åˆ°è¡Œäºº
                if (this.targetPerson && Date.now() - this.lostTargetTime > this.maxLostTime) {
                    updateVoice('è·Ÿéš¨ç›®æ¨™å·²ä¸Ÿå¤±ï¼Œè«‹å°å¿ƒå‰é€²');
                    this.targetPerson = null;
                }
                return null;
            }

            // å¦‚æœæœ‰ç•¶å‰è·Ÿéš¨ç›®æ¨™ï¼Œå˜—è©¦ç¹¼çºŒè·Ÿéš¨
            if (this.targetPerson) {
                const currentTarget = persons.find(p => this.isSamePerson(p, this.targetPerson));
                if (currentTarget) {
                    this.lostTargetTime = Date.now();
                    return currentTarget;
                }
            }

            // é¸æ“‡æœ€ä½³è·Ÿéš¨ç›®æ¨™
            let bestTarget = null;
            let bestScore = -1;

            persons.forEach(person => {
                const score = this.calculateTargetScore(person, frameWidth, frameHeight);
                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = person;
                }
            });

            if (bestTarget && bestScore > 0.5) {
                this.targetPerson = bestTarget;
                this.lostTargetTime = Date.now();
                updateVoice('å·²é–å®šè·Ÿéš¨ç›®æ¨™ï¼Œè«‹ä¿æŒå®‰å…¨è·é›¢è·Ÿéš¨');
                return bestTarget;
            }

            return null;
        }

        // è¨ˆç®—ç›®æ¨™è·Ÿéš¨åˆ†æ•¸
        calculateTargetScore(person, frameWidth, frameHeight) {
            const [x, y, w, h] = person.bbox;
            const centerX = x + w / 2;
            const centerY = y + h / 2;
            
            let score = 0;
            
            // 1. ä½ç½®åˆ†æ•¸ï¼ˆåå¥½ç•«é¢ä¸­å¤®çš„è¡Œäººï¼‰
            const centerDistance = Math.abs(centerX - frameWidth / 2) / frameWidth;
            score += (1 - centerDistance) * 0.3;
            
            // 2. å¤§å°åˆ†æ•¸ï¼ˆåå¥½ä¸­ç­‰è·é›¢çš„è¡Œäººï¼‰
            const sizeScore = Math.min(w * h / (frameWidth * frameHeight * 0.1), 1);
            score += sizeScore * 0.3;
            
            // 3. ç©©å®šæ€§åˆ†æ•¸ï¼ˆå¦‚æœä¹‹å‰è·Ÿéš¨éï¼ŒåŠ åˆ†ï¼‰
            if (this.isSamePerson(person, this.targetPerson)) {
                score += 0.4;
            }
            
            // 4. é‹å‹•æ–¹å‘åˆ†æ•¸ï¼ˆæœç•«é¢ä¸‹æ–¹ç§»å‹•çš„è¡Œäººæ›´é©åˆè·Ÿéš¨ï¼‰
            const motionScore = this.calculateMotionScore(person);
            score += motionScore * 0.2;
            
            return score;
        }

        // åˆ¤æ–·æ˜¯å¦ç‚ºåŒä¸€äººï¼ˆç°¡å–®å¯¦ç¾ï¼‰
        isSamePerson(personA, personB) {
            if (!personB) return false;
            
            const [ax, ay, aw, ah] = personA.bbox;
            const [bx, by, bw, bh] = personB.bbox;
            
            const centerAX = ax + aw / 2;
            const centerAY = ay + ah / 2;
            const centerBX = bx + bw / 2;
            const centerBY = by + bh / 2;
            
            const distance = Math.sqrt(
                Math.pow(centerAX - centerBX, 2) + 
                Math.pow(centerAY - centerBY, 2)
            );
            
            return distance < 50; // 50åƒç´ å…§èªç‚ºæ˜¯åŒä¸€äºº
        }

        // è¨ˆç®—é‹å‹•æ–¹å‘åˆ†æ•¸
        calculateMotionScore(person) {
            if (this.trackingHistory.length < 2) return 0.5;
            
            const [x, y, w, h] = person.bbox;
            const currentCenterY = y + h / 2;
            
            // æŸ¥æ‰¾æ­·å²ä½ç½®
            const history = this.trackingHistory.filter(h => 
                this.isSamePerson(h.person, person)
            );
            
            if (history.length < 2) return 0.5;
            
            // è¨ˆç®—Yè»¸ç§»å‹•æ–¹å‘ï¼ˆå‘ä¸‹ç§»å‹•ç‚ºæ­£ï¼‰
            const lastY = history[history.length - 2].person.bbox[1] + 
                         history[history.length - 2].person.bbox[3] / 2;
            const yMovement = currentCenterY - lastY;
            
            return yMovement > 0 ? 1.0 : 0.3; // å‘ä¸‹ç§»å‹•å¾—åˆ†æ›´é«˜
        }

        // æä¾›è·Ÿéš¨æŒ‡å°
        provideFollowingGuidance(target, frameWidth, frameHeight) {
            if (!this.isActive || !target) return;
            
            const now = Date.now();
            if (now - this.lastGuidanceTime < this.guidanceCooldown) return;
            
            const [x, y, w, h] = target.bbox;
            const centerX = x + w / 2;
            const distance = estimateDistance(w, h, 'person');
            
            // å®‰å…¨è·é›¢æª¢æŸ¥
            if (distance < 2) {
                updateVoice('è·Ÿéš¨è·é›¢å¤ªè¿‘ï¼Œè«‹ä¿æŒå®‰å…¨è·é›¢');
                this.lastGuidanceTime = now;
                return;
            }
            
            if (distance > 8) {
                updateVoice('è·Ÿéš¨è·é›¢éé ï¼Œè«‹ç¨åŠ å¿«è…³æ­¥');
                this.lastGuidanceTime = now;
                return;
            }
            
            // æ–¹å‘æŒ‡å°ï¼ˆåªæœ‰åœ¨æ˜é¡¯åé›¢æ™‚æç¤ºï¼‰
            const screenCenter = frameWidth / 2;
            const offset = centerX - screenCenter;
            const offsetRatio = Math.abs(offset) / screenCenter;
            
            if (offsetRatio > 0.3) {
                const direction = offset > 0 ? 'å³' : 'å·¦';
                updateVoice(`ç›®æ¨™å${direction}ï¼Œè«‹ç¨å‘${direction}èª¿æ•´`);
                this.lastGuidanceTime = now;
            }
            
            // è¨˜éŒ„è¿½è¹¤æ­·å²
            this.trackingHistory.push({
                person: target,
                timestamp: now,
                position: { x: centerX, y: y + h / 2 }
            });
            
            // ä¿æŒæ­·å²è¨˜éŒ„é•·åº¦
            if (this.trackingHistory.length > this.maxHistoryLength) {
                this.trackingHistory.shift();
            }
        }

        // æ›´æ–°é¡¯ç¤º
        updateDisplay(target, ctx, frameWidth, frameHeight) {
            if (!this.isActive || !target) return;
            
            const [x, y, w, h] = target.bbox;
            
            // ç¹ªè£½è·Ÿéš¨ç›®æ¨™æ¡†
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 4;
            ctx.strokeRect(x, y, w, h);
            
            // ç¹ªè£½è·Ÿéš¨æŒ‡ç¤ºå™¨
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.fillRect(x, y, w, h);
            
            // ç¹ªè£½è·é›¢å’Œç‹€æ…‹
            const distance = estimateDistance(w, h, 'person');
            ctx.fillStyle = '#00ff00';
            ctx.font = '18px Arial';
            ctx.fillText(`è·Ÿéš¨ç›®æ¨™ ${distance.toFixed(1)}m`, x, y - 10);
            
            // ç¹ªè£½å®‰å…¨å€åŸŸ
            this.drawSafetyZone(ctx, frameWidth, frameHeight, target);
        }

        // ç¹ªè£½å®‰å…¨è·Ÿéš¨å€åŸŸ
        drawSafetyZone(ctx, frameWidth, frameHeight, target) {
            const [x, y, w, h] = target.bbox;
            const centerX = x + w / 2;
            
            // å®‰å…¨è·Ÿéš¨å€åŸŸï¼ˆç›®æ¨™å‘¨åœï¼‰
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            // æ°´å¹³å®‰å…¨å€åŸŸ
            const safeWidth = frameWidth * 0.4;
            ctx.strokeRect(centerX - safeWidth / 2, y - 50, safeWidth, h + 100);
            
            ctx.setLineDash([]);
        }
    }

    /**********************
     * 6) æ™ºèƒ½ç’°å¢ƒåˆ¤æ–·ç³»çµ± - æ”¹é€²ç‰ˆ
     **********************/
    class EnvironmentAnalyzer {
      constructor() {
        this.lastEnvironment = 'auto';
        this.confidenceThreshold = 3; // å¾2å‡å›3ï¼Œæ¸›å°‘èª¤åˆ¤
        this.environmentScores = {};
        this.keyItemsDetected = {};
        this.lastSwitchTime = 0;
        this.switchCooldown = 5000; // å¾3ç§’å‡å›5ç§’ï¼Œæ¸›å°‘ç’°å¢ƒè‡ªå‹•åˆ‡æ›çš„é »ç‡
        
        // åˆå§‹åŒ–ç’°å¢ƒåˆ†æ•¸
        Object.keys(environmentModules).forEach(env => {
          if (env !== 'auto') {
            this.environmentScores[env] = 0;
            this.keyItemsDetected[env] = new Set();
          }
        });
      }

      analyze(predictions) {
        const now = Date.now();
        
        // æª¢æŸ¥å†·å»æ™‚é–“
        if (now - this.lastSwitchTime < this.switchCooldown) {
          return this.lastEnvironment;
        }

        // é‡ç½®åˆ†æ•¸
        Object.keys(this.environmentScores).forEach(env => {
          this.environmentScores[env] = 0;
        });

        // å®šç¾©é—œéµä»£è¡¨æ€§ç‰©å“ï¼ˆé«˜æ¬Šé‡ï¼‰
        const keyItems = {
          'bedroom': ['bed', 'dresser', 'mirror', 'lamp', 'toilet'],
          'kitchen': ['oven', 'microwave', 'refrigerator', 'sink', 'knife'],
          'bathroom': ['toilet', 'sink', 'mirror', 'shower', 'bathtub', 'vase'],
          'hospital': ['bed', 'wheelchair', 'crutches', 'medical equipment'],
          'supermarket': ['shopping cart', 'shelf', 'refrigerator', 'cash register'],
          'office': ['desk', 'chair', 'laptop', 'printer', 'monitor', 'toilet', 'vase'],
          'outdoor': ['car', 'bus', 'traffic light', 'stop sign', 'tree'],
          'indoor': ['chair', 'couch', 'tv', 'table', 'lamp', 'toilet', 'vase']
        };

        // åˆ†ææª¢æ¸¬åˆ°çš„ç‰©å“
        predictions.forEach(pred => {
          if (pred.score < SCORE_THRESHOLD) return;
          
          // æª¢æŸ¥æ¯å€‹ç’°å¢ƒæ¨¡çµ„
          Object.keys(environmentModules).forEach(env => {
            if (env === 'auto') return;
            
            if (environmentModules[env].objects[pred.class]) {
              let score = pred.score * 4; // é€²ä¸€æ­¥æé«˜æ¬Šé‡ï¼Œå¾3å€æ”¹ç‚º4å€
              
              // å¦‚æœæ˜¯é—œéµä»£è¡¨æ€§ç‰©å“ï¼Œçµ¦äºˆæ›´é«˜æ¬Šé‡
              if (keyItems[env] && keyItems[env].includes(pred.class)) {
                score *= 2; // é—œéµç‰©å“æ¬Šé‡æ›´é«˜ï¼Œä¿æŒ2å€
                this.keyItemsDetected[env].add(pred.class);
              }
              
              this.environmentScores[env] += score;
            }
          });
        });

        // è¨˜éŒ„ç’°å¢ƒåˆ†æ•¸
        environmentHistory.push({ ...this.environmentScores });
        if (environmentHistory.length > 8) { // ç¸®çŸ­æ­·å²é•·åº¦ï¼Œå¾10é™åˆ°8
          environmentHistory.shift();
        }

        // è¨ˆç®—å¹³å‡åˆ†æ•¸
        const avgScores = {};
        Object.keys(this.environmentScores).forEach(env => {
          avgScores[env] = environmentHistory.reduce((sum, item) => sum + item[env], 0) / environmentHistory.length;
        });

        // æ‰¾å‡ºæœ€é«˜åˆ†çš„ç’°å¢ƒ
        let detectedEnvironment = 'auto';
        let maxScore = 0;
        
        Object.keys(avgScores).forEach(env => {
          if (avgScores[env] > maxScore) {
            maxScore = avgScores[env];
            detectedEnvironment = env;
          }
        });

        // æª¢æŸ¥é—œéµç‰©å“æ¢ä»¶ï¼ˆé™ä½æ¢ä»¶è¦æ±‚ï¼‰
        const hasKeyItems = Object.keys(this.keyItemsDetected).some(env => 
          this.keyItemsDetected[env].size >= 1 // åªéœ€è¦æª¢æ¸¬åˆ°1å€‹é—œéµç‰©å“å³å¯
        );

        // åªæœ‰ç•¶åˆ†æ•¸è¶³å¤ é«˜ä¸”æœ‰é—œéµç‰©å“æ™‚æ‰åˆ‡æ›
        if (maxScore > this.confidenceThreshold && hasKeyItems && 
            detectedEnvironment !== this.lastEnvironment) {
          this.lastEnvironment = detectedEnvironment;
          this.lastSwitchTime = now;
          updateEnvironmentDisplay(detectedEnvironment);
          
          // é‡ç½®é—œéµç‰©å“è¨˜éŒ„
          Object.keys(this.keyItemsDetected).forEach(env => {
            this.keyItemsDetected[env].clear();
          });
        }

        return this.lastEnvironment;
      }
    }

    const environmentAnalyzer = new EnvironmentAnalyzer();

    function updateEnvironmentDisplay(environment) {
      const moduleElement = document.getElementById('currentModule');
      const tagElement = document.getElementById('activeModuleTag');
      
      let displayName = 'è‡ªå‹•';
      let indicatorClass = 'auto-indicator';
      
      if (environment !== 'auto' && environmentModules[environment]) {
        displayName = environmentModules[environment].name;
        
        // æ ¹æ“šç’°å¢ƒé¡å‹è¨­ç½®æŒ‡ç¤ºå™¨é¡è‰²
        if (environment === 'outdoor') {
          indicatorClass = 'outdoor-indicator';
        } else if (['bedroom', 'kitchen', 'bathroom', 'office', 'indoor'].includes(environment)) {
          indicatorClass = 'indoor-indicator';
        } else {
          indicatorClass = 'auto-indicator';
        }
      }
      
      moduleElement.innerHTML = `<span class="environment-indicator ${indicatorClass}"></span>${displayName}`;
      tagElement.textContent = displayName;
      
      if (environment !== 'auto') {
        updateVoice(`æª¢æ¸¬åˆ°${displayName}ç’°å¢ƒï¼Œå·²è‡ªå‹•åˆ‡æ›æ¨¡å¼`);
      }
    }

    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnMode').addEventListener('click', toggleMode);
      document.getElementById('btnSetHome').addEventListener('click', () => gpsNavigator.setHomePosition());
      document.getElementById('btnReturnHome').addEventListener('click', toggleSafetyCorridor);
      document.getElementById('btnLoadModule').addEventListener('click', loadEnvironmentModule);
      document.getElementById('btnInfrared').addEventListener('click', toggleInfrared);
      document.getElementById('btnEmergency').addEventListener('click', emergencyAlert);
      document.getElementById('btnFollow').addEventListener('click', togglePedestrianFollowing);
      
      console.log('æ‰€æœ‰äº‹ä»¶ç›£è½å™¨å·²ç¶å®š');
    }

    function togglePedestrianFollowing() {
        const button = document.getElementById('btnFollow');
        
        if (pedestrianFollower.isActive) {
            pedestrianFollower.stop();
            button.textContent = 'è¡Œäººè·Ÿéš¨æ¨¡å¼';
            button.classList.remove('danger');
            button.classList.remove('follow-active');
        } else {
            // åœæ­¢å…¶ä»–å°èˆªæ¨¡å¼
            if (safetyNavigator.isActive) {
                safetyNavigator.stop();
                document.getElementById('btnReturnHome').textContent = 'å®‰å…¨é€šé“å°èˆª';
                document.getElementById('btnReturnHome').classList.remove('gps-active');
            }
            
            pedestrianFollower.start();
            button.textContent = 'åœæ­¢è·Ÿéš¨';
            button.classList.add('danger');
        }
    }

    function toggleSafetyCorridor() {
      const button = document.getElementById('btnReturnHome');
      
      if (safetyNavigator.isActive) {
        // åœæ­¢å®‰å…¨é€šé“å°èˆª
        safetyNavigator.stop();
        button.textContent = 'å®‰å…¨é€šé“å°èˆª';
        button.classList.remove('gps-active');
        updateVoice('å®‰å…¨é€šé“å°èˆªå·²é—œé–‰');
      } else {
        // å•Ÿå‹•å®‰å…¨é€šé“å°èˆª
        if (!gpsNavigator.homePosition) {
          updateVoice('è«‹å…ˆè¨­å®šå®¶çš„ä½ç½®');
          return;
        }
        
        safetyNavigator.start();
        button.textContent = 'åœæ­¢å°èˆª';
        button.classList.add('gps-active');
        
        // åŒæ™‚å•Ÿå‹•GPSè¿”èˆª
        gpsNavigator.startReturnHome();
      }
    }

    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment', 
            width: { ideal: 640 },
            height: { ideal: 480 } 
          }, 
          audio: false 
        });
        video.srcObject = stream; 
        await new Promise((resolve) => {
          video.onloadedmetadata = () => { resolve(video); };
        }); 
        await video.play();
        return video;
      } catch (e) { 
        console.error('ç›¸æ©ŸéŒ¯èª¤:', e); 
        updateVoice('ç„¡æ³•å­˜å–ç›¸æ©Ÿï¼Œè«‹ç¢ºèªæ¬Šé™'); 
        return null; 
      }
    }

    /**********************
     * 7) ä¸»æµç¨‹ï¼ˆä½¿ç”¨ COCO-SSD æª¢æ¸¬ï¼‰
     **********************/
    async function startDetection() {
      if (!model) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆï¼Œè«‹ç¨å€™');
        return;
      }
      
      const video = await setupCamera(); 
      if (!video) return;
      
      isDetecting = true; 
      updateStatus('æª¢æ¸¬ä¸­'); 
      updateVoice('é–‹å§‹éšœç¤™ç‰©æª¢æ¸¬ï¼Œæ™ºèƒ½ç’°å¢ƒè­˜åˆ¥å·²å•Ÿå‹•â€¦');
      
      requestAnimationFrame((ts) => loop(video, ts));
    }

    function stopDetection() {
      isDetecting = false; 
      updateStatus('å·²åœæ­¢');
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      updateVoice('æª¢æ¸¬å·²åœæ­¢');
      gpsNavigator.stopReturnHome();
      
      // åœæ­¢å®‰å…¨é€šé“å°èˆª
      if (safetyNavigator.isActive) {
        safetyNavigator.stop();
        const button = document.getElementById('btnReturnHome');
        button.textContent = 'å®‰å…¨é€šé“å°èˆª';
        button.classList.remove('gps-active');
      }
    }

    async function loop(video, ts = 0) {
      if (!isDetecting) return;
      
      if (ts - lastTick >= INTERVAL) {
        try {
          // ä½¿ç”¨ COCO-SSD é€²è¡Œæª¢æ¸¬
          const predictions = await model.detect(video);
          
          // è¡Œäººè·Ÿéš¨æ¨¡å¼è™•ç†
          if (pedestrianFollower.isActive) {
            const target = pedestrianFollower.findBestTarget(predictions, video.videoWidth, video.videoHeight);
            pedestrianFollower.provideFollowingGuidance(target, video.videoWidth, video.videoHeight);
          } else {
            // åŸæœ‰çš„ç’°å¢ƒåˆ¤æ–·é‚è¼¯
            const detectedEnvironment = environmentAnalyzer.analyze(predictions);
            
            // è™•ç†æª¢æ¸¬çµæœï¼ˆåŒ…å«åœ°é¢éšœç¤™ç‰©æª¢æ¸¬ï¼‰
            processPredictions(predictions, video.videoWidth, video.videoHeight, detectedEnvironment);
            
            // æ›´æ–°å®‰å…¨é€šé“å°èˆªç³»çµ±
            safetyNavigator.updateObstacles(predictions, video.videoWidth, video.videoHeight);
            
            // å¦‚æœå®‰å…¨é€šé“å°èˆªå•Ÿç”¨ï¼Œé¡å¤–æª¢æŸ¥åœ°é¢æ¨™åœ°ç‰©é™„è¿‘çš„éšœç¤™ç‰©
            if (safetyNavigator.isActive) {
              const obstaclesNearLandmarks = groundDetector.detectObstaclesNearLandmarks(
                predictions, video.videoWidth, video.videoHeight
              );
              
              // å°æ–¼é™„è¿‘çš„éšœç¤™ç‰©é€²è¡Œæç¤º
              if (obstaclesNearLandmarks.length > 0) {
                const now = Date.now();
                // ç‚ºæ¯å€‹åœ°æ¨™é¡å‹è¨­ç½®æœ€å¾Œæç¤ºæ™‚é–“
                if (!window.lastLandmarkAlerts) {
                  window.lastLandmarkAlerts = {};
                }
                
                obstaclesNearLandmarks.forEach(obstacle => {
                  const landmarkType = obstacle.landmark;
                  const lastAlertTime = window.lastLandmarkAlerts[landmarkType] || 0;
                  
                  // æ¯å€‹åœ°æ¨™é¡å‹æ¯5ç§’æœ€å¤šæç¤ºä¸€æ¬¡
                  if (now - lastAlertTime > 5000) {
                    const landmarkName = environmentModules.outdoor.objects[landmarkType]?.name || landmarkType;
                    const obstacleName = environmentModules.outdoor.objects[obstacle.class]?.name || obstacle.class;
                    updateVoice(`${landmarkName}é™„è¿‘æœ‰${obstacleName}éšœç¤™ç‰©ï¼Œè«‹å°å¿ƒ`);
                    window.lastLandmarkAlerts[landmarkType] = now;
                  }
                });
              }
            }
          }
          
          // ç¹ªè£½æª¢æ¸¬çµæœ
          draw(predictions, video.videoWidth, video.videoHeight);
          
          // ç¹ªè£½è¡Œäººè·Ÿéš¨ä¿¡æ¯
          if (pedestrianFollower.isActive) {
            const ctx = document.getElementById('canvas').getContext('2d');
            const target = pedestrianFollower.findBestTarget(predictions, video.videoWidth, video.videoHeight);
            pedestrianFollower.updateDisplay(target, ctx, video.videoWidth, video.videoHeight);
          }

          frames++; 
          if (!lastFpsTs) {
            lastFpsTs = ts;
          } else if (ts - lastFpsTs >= 1000) {
            document.getElementById('fps').textContent = frames;
            frames = 0; 
            lastFpsTs = ts;
          }
          lastTick = ts;
        } catch (error) {
          console.error('æª¢æ¸¬å¾ªç’°éŒ¯èª¤:', error);
        }
      }
      requestAnimationFrame((n) => loop(video, n));
    }

    /**********************
     * 8) é æ¸¬è™•ç†èˆ‡ç¹ªåœ– - æ•´åˆåœ°é¢éšœç¤™ç‰©æª¢æ¸¬ï¼Œæé«˜è¾¨è­˜æº–ç¢ºåº¦
     **********************/
    function processPredictions(predictions, frameW, frameH, detectedEnvironment) {
      // æ ¹æ“šæª¢æ¸¬åˆ°çš„ç’°å¢ƒé¸æ“‡å°æ‡‰çš„æ¨¡çµ„ï¼Œå¦‚æœç‚ºautoå‰‡ä½¿ç”¨æ‰€æœ‰æ¨¡çµ„
      let activeModules = [];
      if (detectedEnvironment === 'auto') {
        activeModules = Object.keys(environmentModules).filter(env => env !== 'auto');
      } else {
        activeModules = [detectedEnvironment];
      }
      
      // éæ¿¾ç›¸é—œç‰©é«”ï¼ˆé™ä½ç½®ä¿¡åº¦è¦æ±‚ï¼Œæé«˜è­˜åˆ¥èƒ½åŠ›ï¼‰
      let relevantPredictions = predictions.filter(p => {
        // å°è¡Œäººæª¢æ¸¬è¦æ±‚æ›´é«˜çš„ç½®ä¿¡åº¦
        if (p.class === 'person' && p.score < MIN_CONFIDENCE_FOR_PERSON) return false;
        
        // å°æ‰€æœ‰ç‰©é«”ä½¿ç”¨è¼ƒä½çš„ç½®ä¿¡åº¦é–¾å€¼ä»¥æé«˜è­˜åˆ¥èƒ½åŠ›
        if (p.score >= 0.2) return true;
        
        if (p.score < SCORE_THRESHOLD) return false;
        
        // æª¢æŸ¥æ˜¯å¦åœ¨ä»»ä½•æ´»èºæ¨¡çµ„ä¸­
        return activeModules.some(env => environmentModules[env].objects[p.class]);
      }).map(pred => {
        // è¨ˆç®—è·é›¢
        const distance = estimateDistance(pred.bbox[2], pred.bbox[3], pred.class);
        return {
          ...pred,
          distance: distance
        };
      });
      
      // å¦‚æœå®‰å…¨é€šé“å°èˆªå•Ÿç”¨ï¼Œéæ¿¾æ‰åœ°é¢æ¨™åœ°ç‰©ä»¥é¿å…é‡è¤‡æç¤º
      if (safetyNavigator.isActive) {
        const groundLandmarks = ['curb', 'crosswalk_line', 'pavement_edge', 'tactile_paving', 'guide_line'];
        relevantPredictions = relevantPredictions.filter(pred => !groundLandmarks.includes(pred.class));
      }
      
      // æª¢æ¸¬åœ°é¢éšœç¤™ç‰©
      const groundObstacles = groundDetector.detectGroundObstacles(predictions, frameW, frameH);
      const totalObstacles = relevantPredictions.length + groundObstacles.length;
      
      document.getElementById('obstacleCount').textContent = totalObstacles;
      
      let closestDistance = Infinity;
      let closestObject = null;
      
      // æª¢æŸ¥æ™®é€šç‰©é«”
      relevantPredictions.forEach(pred => {
        if (pred.distance < closestDistance) {
          closestDistance = pred.distance;
          closestObject = pred;
        }
      });
      
      // æª¢æŸ¥åœ°é¢éšœç¤™ç‰©
      groundObstacles.forEach(obstacle => {
        if (obstacle.distance < closestDistance) {
          closestDistance = obstacle.distance;
          closestObject = obstacle;
        }
      });
      
      const distanceElement = document.getElementById('closestDistance');
      if (closestObject) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' å…¬å°º';
        
        if (closestDistance < 2) {
          distanceElement.parentElement.classList.add('danger-warning');
        } else if (closestDistance < 5) {
          distanceElement.parentElement.classList.add('obstacle-warning');
        } else {
          distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
        }
        
        if (voiceEnabled) {
          const now = Date.now();
          
          // æ™ºèƒ½éæ¿¾é‡è¤‡æç¤º
          function shouldSpeak(message, distance, objectType) {
            // å®Œå…¨ç›¸åŒçš„æ¶ˆæ¯éæ¿¾
            if (message === lastVoiceMessage) {
                if (now - lastVoiceTime < SAME_MESSAGE_COOLDOWN) return false;
            }
            
            // æ–¹å‘æŒ‡ä»¤ç‰¹æ®Šè™•ç†
            if (message.includes('é å³') || message.includes('é å·¦') || 
                message.includes('èª¿æ•´') || message.includes('å›åˆ°')) {
                if (now - lastDirectionTime < DIRECTION_COOLDOWN) return false;
                lastDirectionTime = now;
            }
            
            // è·¯ç·£çŸ³ç‰¹æ®Šè™•ç†
            if (objectType === 'curb' || message.includes('è·¯ç·£çŸ³')) {
                if (now - lastCurbTime < CURB_COOLDOWN) return false;
                lastCurbTime = now;
            }
            
            // æ ¹æ“šè·é›¢èª¿æ•´é »ç‡
            if (distance > 5 && now - lastVoiceTime < 10000) return false;
            if (distance > 10 && now - lastVoiceTime < 15000) return false;
            
            return true;
          }
          
          if (now - lastSpeechAt > VOICE_COOLDOWN) {
            // æ‰¾åˆ°ç‰©é«”å°æ‡‰çš„æ¨¡çµ„å’Œé…ç½®
            let objConfig = null;
            for (const env of activeModules) {
              if (environmentModules[env].objects[closestObject.class]) {
                objConfig = environmentModules[env].objects[closestObject.class];
                break;
              }
            }
            
            if (objConfig) {
              let voiceMsg = objConfig.voice;
              
              if (closestObject.distance < 2) {
                voiceMsg = `ç·Šæ€¥ï¼${objConfig.name}éå¸¸æ¥è¿‘ï¼Œåƒ…${closestObject.distance.toFixed(1)}å…¬å°º`;
              } else if (closestObject.distance < 5) {
                voiceMsg = `æ³¨æ„ï¼${objConfig.name}æ¥è¿‘ï¼Œè·é›¢${closestObject.distance.toFixed(1)}å…¬å°º`;
              }
              
              // åœ¨å®‰å…¨é€šé“å°èˆªæ¨¡å¼ä¸‹ï¼Œé¿å…é‡è¤‡æç¤ºåœ°é¢æ¨™åœ°ç‰©
              if (!safetyNavigator.isActive || !['curb', 'crosswalk_line', 'pavement_edge', 'tactile_paving'].includes(closestObject.class)) {
                updateVoice(voiceMsg);
                lastSpeechAt = now;
              }
            }
          }
        }
      } else {
        distanceElement.textContent = 'â€” å…¬å°º';
        distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
      }
      
      updateDetectionList(relevantPredictions, activeModules);
    }

    function estimateDistance(width, height, className) {
      const pixelArea = width * height;
      
      // å¢åŠ æ›´å¤šç‰©é«”çš„åƒè€ƒå°ºå¯¸ä»¥æé«˜è·é›¢ä¼°è¨ˆæº–ç¢ºæ€§
      const referenceSizes = {
        'person': 8000,
        'car': 40000,
        'motorcycle': 15000,
        'bus': 60000,
        'truck': 80000,
        'bicycle': 12000,
        'chair': 6000,
        'couch': 20000,
        'bed': 15000,
        'dining table': 25000,
        'tv': 8000,
        'laptop': 3000,
        'mouse': 500,
        'keyboard': 1500,
        'cell phone': 1000,
        'book': 2000,
        'vase': 2000,
        'cup': 1000,
        'bottle': 1500,
        'toilet': 3000,
        'sink': 4000,
        'refrigerator': 12000,
        'oven': 8000,
        'microwave': 2000,
        'toothbrush': 300,
        'hair drier': 800,
        'toothpaste': 200,
        'remote': 600,
        'scissors': 400
      };
      
      const refSize = referenceSizes[className] || 8000;
      const distance = Math.sqrt(refSize / pixelArea) * 8;
      
      // ç‚ºä¸åŒçš„ç‰©é«”é¡å‹è¨­ç½®ä¸åŒçš„æœ€å¤§è·é›¢é™åˆ¶
      const maxDistances = {
        'person': 30,
        'car': 100,
        'chair': 20,
        'vase': 15,
        'toilet': 15,
        'cup': 10,
        'bottle': 12
      };
      
      const maxDistance = maxDistances[className] || 50;
      return Math.min(distance, maxDistance);
    }

    function updateDetectionList(predictions, activeModules) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="chip" style="text-align:center; color:var(--muted);">æœªåµæ¸¬åˆ°éšœç¤™ç‰©</div>';
        return;
      }
      
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        // æ‰¾åˆ°ç‰©é«”å°æ‡‰çš„æ¨¡çµ„å’Œé…ç½®
        let objConfig = null;
        for (const env of activeModules) {
          if (environmentModules[env].objects[pred.class]) {
            objConfig = environmentModules[env].objects[pred.class];
            break;
          }
        }
        
        const dangerLevel = objConfig ? objConfig.danger : 'low';
        const dangerColors = {
          'high': 'var(--bad)',
          'medium': 'var(--warn)', 
          'low': 'var(--good)'
        };
        
        const displayName = objConfig ? objConfig.name : pred.class;
        
        return `
          <div class="chip" style="border-left: 4px solid ${dangerColors[dangerLevel]}">
            <strong>${displayName}</strong><br>
            è·é›¢: ${pred.distance.toFixed(1)}å…¬å°º | ç½®ä¿¡åº¦: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    function draw(predictions, width, height) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      if (!width || !height) return;
      
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      predictions.forEach(pred => {
        if (pred.score < SCORE_THRESHOLD) return;
        
        const [x, y, w, h] = pred.bbox;
        
        // æ‰¾åˆ°ç‰©é«”å°æ‡‰çš„æ¨¡çµ„å’Œé…ç½®
        let objConfig = null;
        for (const env in environmentModules) {
          if (env !== 'auto' && environmentModules[env].objects[pred.class]) {
            objConfig = environmentModules[env].objects[pred.class];
            break;
          }
        }
        
        if (!objConfig) return;
        
        let color;
        switch(objConfig.danger) {
          case 'high': color = '#ef4444'; break;
          case 'medium': color = '#f59e0b'; break;
          default: color = '#22c55e';
        }
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        const label = `${objConfig.name} ${pred.distance.toFixed(1)}m`;
        ctx.font = '16px Arial';
        const textWidth = ctx.measureText(label).width;
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y - 25, textWidth + 10, 25);
        
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + 5, y - 7);
      });
    }

    /**********************
     * 9) å·¥å…·å‡½æ•¸
     **********************/
    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      if (voiceEnabled && window.speechSynthesis) {
        const now = Date.now();
        
        // é˜²æ­¢è¯­éŸ³è¿ç»­é‡å¤ - æ£€æŸ¥æ˜¯å¦ä¸ä¸Šæ¬¡è¯­éŸ³ç›¸åŒ
        if (message === lastVoiceMessage && now - lastVoiceTime < SAME_MESSAGE_COOLDOWN) {
          return; // 15ç§’å†…ç›¸åŒæ¶ˆæ¯ä¸é‡å¤æ’­æ”¾
        }
        
        // é˜²æ­¢è¯­éŸ³é‡å  - æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ’­æ”¾è¯­éŸ³
        if (window.speechSynthesis.speaking && now - lastVoiceTime < 3000) {
          return; // 3ç§’å†…ä¸æ‰“æ–­æ­£åœ¨æ’­æ”¾çš„è¯­éŸ³
        }
        
        window.speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.8; // æ›´æ…¢çš„è¯­é€Ÿè®©ç›²äººæ›´å®¹æ˜“ç†è§£
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        // è®°å½•è¯­éŸ³æ’­æ”¾æ—¶é—´å’Œå†…å®¹
        lastVoiceMessage = message;
        lastVoiceTime = now;
        
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateGPSStatus(status) {
      document.getElementById('gpsStatus').textContent = status;
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const status = document.getElementById('voiceStatus');
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        status.textContent = 'é–‹å•Ÿ';
        button.textContent = 'èªéŸ³é—œé–‰';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('èªéŸ³æç¤ºå·²é–‹å•Ÿ');
      } else {
        status.textContent = 'é—œé–‰';
        button.textContent = 'èªéŸ³é–‹å•Ÿ';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleMode() {
      const button = document.getElementById('btnMode');
      currentMode = currentMode === 'auto' ? 'manual' : 'auto';
      
      if (currentMode === 'auto') {
        button.textContent = 'æ‰‹å‹•æ¨¡å¼';
        updateVoice('åˆ‡æ›åˆ°æ™ºèƒ½æ¨¡å¼ï¼Œè‡ªå‹•åˆ¤æ–·ç’°å¢ƒ');
        environmentHistory = []; // é‡ç½®ç’°å¢ƒæ­·å²
      } else {
        button.textContent = 'æ™ºèƒ½æ¨¡å¼';
        updateVoice('åˆ‡æ›åˆ°æ‰‹å‹•æ¨¡å¼');
      }
    }

    function loadEnvironmentModule() {
      const environments = Object.keys(environmentModules).filter(env => env !== 'auto');
      
      // å¦‚æœç•¶å‰ç’°å¢ƒæ˜¯ autoï¼Œå¾ç¬¬ä¸€å€‹é–‹å§‹ï¼›å¦å‰‡å¾ªç’°åˆ°ä¸‹ä¸€å€‹
      let currentIndex = 0;
      if (currentEnvironment !== 'auto') {
        currentIndex = environments.indexOf(currentEnvironment);
        if (currentIndex === -1) currentIndex = 0;
      }
      
      const nextIndex = (currentIndex + 1) % environments.length;
      currentEnvironment = environments[nextIndex];
      
      const module = environmentModules[currentEnvironment];
      
      // æ›´æ–°é¡¯ç¤º
      const moduleElement = document.getElementById('currentModule');
      const tagElement = document.getElementById('activeModuleTag');
      
      let displayName = module.name;
      let indicatorClass = 'auto-indicator';
      
      // æ ¹æ“šç’°å¢ƒé¡å‹è¨­ç½®æŒ‡ç¤ºå™¨é¡è‰²
      if (currentEnvironment === 'outdoor') {
        indicatorClass = 'outdoor-indicator';
      } else if (['bedroom', 'kitchen', 'bathroom', 'office', 'indoor'].includes(currentEnvironment)) {
        indicatorClass = 'indoor-indicator';
      }
      
      moduleElement.innerHTML = `<span class="environment-indicator ${indicatorClass}"></span>${displayName}`;
      tagElement.textContent = displayName;
      
      updateVoice(`æ‰‹å‹•åˆ‡æ›åˆ°${displayName}ç’°å¢ƒæ¨¡å¼`);
      
      console.log(`åˆ‡æ›åˆ°ç’°å¢ƒ: ${currentEnvironment}, é¡¯ç¤ºåç¨±: ${displayName}`);
    }

    function toggleInfrared() {
      const button = document.getElementById('btnInfrared');
      
      if (infraredRangefinder.isActive) {
        infraredRangefinder.deactivate();
        button.textContent = 'ç´…å¤–ç·šæ¸¬è·';
        button.classList.remove('primary');
        button.classList.add('secondary');
      } else {
        infraredRangefinder.activate();
        button.textContent = 'é—œé–‰æ¸¬è·';
        button.classList.remove('secondary');
        button.classList.add('primary');
      }
    }

    function emergencyAlert() {
      const button = document.getElementById('btnEmergency');
      button.classList.add('emergency-alert');
      
      updateVoice('ç·Šæ€¥æ±‚åŠ©ï¼æ­£åœ¨ç™¼é€ä½ç½®è³‡è¨Šçµ¦ç·Šæ€¥è¯çµ¡äºº');
      
      if (gpsNavigator.currentPosition) {
        const { lat, lng } = gpsNavigator.currentPosition;
        console.log(`ç·Šæ€¥ä½ç½®ç™¼é€: ç·¯åº¦ ${lat.toFixed(6)}, ç¶“åº¦ ${lng.toFixed(6)}`);
      }
      
      setTimeout(() => {
        button.classList.remove('emergency-alert');
      }, 5000);
    }

    /**********************
     * 10) åˆå§‹åŒ–æ‡‰ç”¨
     **********************/
    window.addEventListener('DOMContentLoaded', async () => {
      updateStatus('åˆå§‹åŒ–ä¸­');
      updateVoice('ç›²äººè¼”åŠ©å°èˆªç³»çµ±å•Ÿå‹•ä¸­...');
      
      try {
        console.log('é–‹å§‹åˆå§‹åŒ–æµç¨‹...');
        
        // åˆå§‹åŒ–äº‹ä»¶ç›£è½å™¨ï¼ˆç¢ºä¿é€™è¡Œåœ¨æœ€é–‹å§‹åŸ·è¡Œï¼‰
        initEventListeners();
        console.log('äº‹ä»¶ç›£è½å™¨åˆå§‹åŒ–å®Œæˆ');
        
        // æª¢æŸ¥ TensorFlow.js æ˜¯å¦è¼‰å…¥
        if (typeof tf === 'undefined') {
          throw new Error('TensorFlow.js åº«æœªæ­£ç¢ºè¼‰å…¥ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡é€£æ¥');
        }
        console.log('TensorFlow.js åº«è¼‰å…¥æˆåŠŸ');
        
        // æª¢æŸ¥ COCO-SSD æ˜¯å¦å¯ç”¨
        if (typeof cocoSsd === 'undefined') {
          throw new Error('COCO-SSD æ¨¡å‹åº«æœªæ­£ç¢ºè¼‰å…¥');
        }
        console.log('COCO-SSD æ¨¡å‹åº«è¼‰å…¥æˆåŠŸ');
        
        // åˆå§‹åŒ– TensorFlow.js COCO-SSD æ¨¡å‹
        console.log('é–‹å§‹è¼‰å…¥ AI æ¨¡å‹...');
        await initModel();
        console.log('AI æ¨¡å‹è¼‰å…¥å®Œæˆ');
        
        // è¨­ç½®ç›¸æ©Ÿ
        console.log('é–‹å§‹è¨­ç½®ç›¸æ©Ÿ...');
        await setupCamera();
        console.log('ç›¸æ©Ÿè¨­ç½®å®Œæˆ');
        
        // åˆå§‹åŒ–å®Œæˆ
        updateVoice('ç³»çµ±åˆå§‹åŒ–å®Œæˆï¼Œè«‹é»æ“Šé–‹å§‹æª¢æ¸¬æŒ‰éˆ•');
        updateStatus('å°±ç·’');
        console.log('ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
        
      } catch (error) {
        console.error('åˆå§‹åŒ–å¤±æ•—:', error);
        console.error('è©³ç´°éŒ¯èª¤ä¿¡æ¯:', error.message);
        updateVoice('ç³»çµ±åˆå§‹åŒ–å¤±æ•—: ' + error.message + 'ï¼Œè«‹åˆ·æ–°é é¢é‡è©¦');
        updateStatus('åˆå§‹åŒ–å¤±æ•—');
      }
    });

    // é˜²æ­¢é é¢ä¼‘çœ 
    let wakeLock = null;
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
        }
      } catch (err) {
        console.log('Wake Lock å¤±æ•—:', err.message);
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && isDetecting) {
        await requestWakeLock();
      }
    });

    requestWakeLock();
  </script>
</body>
</html>
</html>