<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="ç›²äººè¼”åŠ©å°èˆªç³»çµ± - å³æ™‚éšœç¤™ç‰©æª¢æ¸¬èˆ‡GPSè¿”èˆª" />
  <title>ğŸ§­ ç›²äººè¼”åŠ©å°èˆªç³»çµ±</title>
  
  <!-- PWA æ”¯æŒ -->
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§­</text></svg>">
  
  <!-- TensorFlow.js å’Œ COCO-SSD -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  
  <style>
    /* å®Œæ•´çš„æ‰€æœ‰CSSæ¨£å¼ */
    :root {
      --bg1: #0ea5e9;
      --bg2: #6366f1;
      --glass: rgba(255,255,255,0.12);
      --glass-strong: rgba(255,255,255,0.22);
      --text: #fff;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --muted: #cbd5e1;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
      --follow: #00ff00;
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang TC', 'Microsoft JhengHei', sans-serif;
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      touch-action: manipulation;
    }
    
    body {
      padding: 10px;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    
    .app {
      max-width: 100%;
      margin: 0 auto;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    
    @media (min-width: 920px) {
      .app {
        grid-template-columns: 6fr 4fr;
      }
    }
    
    .card {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    header.card {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    header h1 {
      font-size: clamp(18px, 5vw, 24px);
      margin: 0;
      font-weight: 700;
    }
    
    header .tips {
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    
    @media (min-width: 768px) {
      header .tips {
        display: block;
      }
    }
    
    .camera {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
    }
    
    .camera video, .camera canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    
    /* ç§»é™¤é¡åƒæ•ˆæœ */
    .camera video {
      transform: scaleX(1);
    }
    
    .panel {
      padding: 16px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    @media (min-width: 480px) {
      .controls {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    button.btn {
      padding: 16px 12px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 54px;
      user-select: none;
    }
    
    button.btn:active {
      transform: translateY(2px) scale(0.98);
    }
    
    .primary {
      background: var(--good);
      color: #fff;
    }
    
    .warning {
      background: var(--warn);
      color: #fff;
    }
    
    .danger {
      background: var(--bad);
      color: #fff;
    }
    
    .follow {
      background: var(--follow);
      color: #000;
      font-weight: 800;
    }
    
    .secondary {
      background: var(--glass-strong);
      color: var(--text);
    }
    
    .status {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, 1fr);
      margin-bottom: 12px;
    }
    
    @media (min-width: 480px) {
      .status {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    .status-item {
      background: var(--glass-strong);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
    }
    
    .status-item .k {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .status-item .v {
      font-weight: 800;
      font-size: clamp(14px, 4vw, 16px);
    }
    
    .voice-alert {
      margin: 12px 0;
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.35);
      color: #fff;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      line-height: 1.4;
    }
    
    .list {
      max-height: 200px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
      padding-right: 4px;
      -webkit-overflow-scrolling: touch;
    }
    
    .chip {
      background: var(--glass-strong);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    
    footer {
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      margin-top: 10px;
    }
    
    .module-tag {
      display: inline-block;
      background: var(--warn);
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 10px;
      margin-left: 8px;
      font-weight: 600;
    }
    
    .gps-active {
      background: var(--good) !important;
    }
    
    .follow-active {
      background: var(--follow) !important;
      color: #000 !important;
    }
    
    .emergency-alert {
      animation: pulse 1s infinite;
      border: 2px solid var(--bad);
    }
    
    .loading {
      background: linear-gradient(90deg, var(--bg1), var(--bg2), var(--bg1));
      background-size: 200% 100%;
      animation: loading 2s infinite;
    }
    
    .obstacle-warning {
      background: rgba(245,158,11,0.3);
      border: 2px solid var(--warn);
    }
    
    .danger-warning {
      background: rgba(239,68,68,0.3);
      border: 2px solid var(--bad);
    }
    
    /* è¡Œäººè·Ÿéš¨æ¨¡å¼å°ˆç”¨æ¨£å¼ */
    .following-indicator {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 255, 0, 0.9);
      color: #000;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 700;
      z-index: 100;
      display: none;
    }
    
    .following-indicator.active {
      display: block;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
      100% {
        opacity: 1;
      }
    }
    
    @keyframes loading {
      0% {
        background-position: 200% 0;
      }
      100% {
        background-position: -200% 0;
      }
    }
    
    /* å®‰å…¨é€šé“å°èˆªç³»çµ± */
    .safety-corridor {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      display: none;
    }
    
    .safety-corridor.active {
      display: block;
    }
    
    .corridor-path {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 60%;
      background: linear-gradient(90deg, 
        rgba(34, 197, 94, 0.1) 0%, 
        rgba(34, 197, 94, 0.3) 30%, 
        rgba(34, 197, 94, 0.3) 70%, 
        rgba(34, 197, 94, 0.1) 100%);
      border-radius: 20px;
      border: 2px dashed rgba(34, 197, 94, 0.5);
      animation: pathGlow 2s ease-in-out infinite alternate;
    }
    
    .corridor-left {
      position: absolute;
      left: 10%;
      top: 20%;
      width: 20%;
      height: 60%;
      background: rgba(245, 158, 11, 0.1);
      border: 2px solid rgba(245, 158, 11, 0.3);
      border-radius: 10px;
    }
    
    .corridor-right {
      position: absolute;
      right: 10%;
      top: 20%;
      width: 20%;
      height: 60%;
      background: rgba(245, 158, 11, 0.1);
      border: 2px solid rgba(245, 158, 11, 0.3);
      border-radius: 10px;
    }
    
    .corridor-front {
      position: absolute;
      left: 30%;
      top: 10%;
      width: 40%;
      height: 20%;
      background: rgba(239, 68, 68, 0.1);
      border: 2px solid rgba(239, 68, 68, 0.3);
      border-radius: 10px;
    }
    
    .obstacle-left {
      background: rgba(239, 68, 68, 0.2) !important;
      border: 2px solid rgba(239, 68, 68, 0.5) !important;
      animation: dangerPulse 1s infinite;
    }
    
    .obstacle-right {
      background: rgba(239, 68, 68, 0.2) !important;
      border: 2px solid rgba(239, 68, 68, 0.5) !important;
      animation: dangerPulse 1s infinite;
    }
    
    .obstacle-front {
      background: rgba(239, 68, 68, 0.3) !important;
      border: 2px solid rgba(239, 68, 68, 0.7) !important;
      animation: dangerPulse 0.5s infinite;
    }
    
    .navigation-guidance {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      text-align: center;
      z-index: 20;
      max-width: 90%;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: none;
    }
    
    .navigation-guidance.active {
      display: block;
    }
    
    @keyframes pathGlow {
      0% {
        box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
      }
      100% {
        box-shadow: 0 0 40px rgba(34, 197, 94, 0.6);
      }
    }
    
    @keyframes dangerPulse {
      0% {
        opacity: 0.7;
      }
      50% {
        opacity: 1;
      }
      100% {
        opacity: 0.7;
      }
    }

    /* æ¨¡å‹è¼‰å…¥é€²åº¦æ¢ */
    .progress-container {
      width: 100%;
      height: 6px;
      background: var(--glass-strong);
      border-radius: 3px;
      margin: 10px 0;
      overflow: hidden;
    }
    
    .progress-bar {
      height: 100%;
      background: var(--good);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }

    /* ç’°å¢ƒæŒ‡ç¤ºå™¨ */
    .environment-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
    }
    
    .indoor-indicator { background: #2196F3; }
    .outdoor-indicator { background: #4CAF50; }
    .auto-indicator { background: #FF9800; }
    
    /* æ‰‹æ©Ÿå„ªåŒ– */
    @media (max-width: 480px) {
      body {
        padding: 8px;
      }
      
      .panel {
        padding: 12px;
      }
      
      button.btn {
        padding: 14px 10px;
        font-size: 13px;
        min-height: 50px;
      }
      
      .status-item {
        padding: 10px;
      }
      
      .voice-alert {
        padding: 14px;
        min-height: 55px;
        font-size: 14px;
      }
    }
    
    /* é˜²æ­¢æ–‡å­—é¸æ“‡ */
    .no-select {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body class="no-select">
  <div class="app">
    <header class="card">
      <h1>ğŸ§­ ç›²äººè¼”åŠ©å°èˆª</h1>
      <div class="tips">å®‰å…¨å‡ºè¡Œ Â· æ™ºèƒ½ç’°å¢ƒæª¢æ¸¬ Â· GPSå°èˆª Â· è¡Œäººè·Ÿéš¨</div>
    </header>

    <section class="card camera">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
      
      <!-- è¡Œäººè·Ÿéš¨æŒ‡ç¤ºå™¨ -->
      <div id="followingIndicator" class="following-indicator">
        ğŸ‘¥ è¡Œäººè·Ÿéš¨æ¨¡å¼ä¸­
      </div>
      
      <!-- å®‰å…¨é€šé“å°èˆªç³»çµ± -->
      <div id="safetyCorridor" class="safety-corridor">
        <div class="corridor-path"></div>
        <div id="corridorLeft" class="corridor-left"></div>
        <div id="corridorRight" class="corridor-right"></div>
        <div id="corridorFront" class="corridor-front"></div>
      </div>
      
      <div id="navigationGuidance" class="navigation-guidance">
        å®‰å…¨é€šé“å°èˆªä¸­...
      </div>
    </section>

    <section class="card panel">
      <div id="voiceAlert" class="voice-alert loading">ç³»çµ±åˆå§‹åŒ–ä¸­â€¦</div>
      
      <!-- æ¨¡å‹è¼‰å…¥é€²åº¦ -->
      <div id="progressContainer" class="progress-container" style="display: none;">
        <div id="progressBar" class="progress-bar"></div>
      </div>
      
      <!-- ä¸»è¦æ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnStart" class="btn primary">é–‹å§‹æª¢æ¸¬</button>
        <button id="btnVoice" class="btn secondary">èªéŸ³é—œé–‰</button>
        <button id="btnFollow" class="btn follow">è¡Œäººè·Ÿéš¨æ¨¡å¼</button>
        <button id="btnStop" class="btn danger">åœæ­¢</button>
      </div>
      
      <!-- å°èˆªæ§åˆ¶æŒ‰éˆ• -->
      <div class="controls">
        <button id="btnSetHome" class="btn primary">è¨­å®šå®¶çš„ä½ç½®</button>
        <button id="btnReturnHome" class="btn warning">å®‰å…¨é€šé“å°èˆª</button>
        <button id="btnMode" class="btn primary">æ™ºèƒ½æ¨¡å¼</button>
        <button id="btnLoadModule" class="btn primary">æ‰‹å‹•åˆ‡æ›ç’°å¢ƒ</button>
        <button id="btnInfrared" class="btn secondary">ç´…å¤–ç·šæ¸¬è·</button>
        <button id="btnEmergency" class="btn danger">ç·Šæ€¥æ±‚åŠ©</button>
      </div>

      <!-- ç‹€æ…‹è³‡è¨Š -->
      <div class="status">
        <div class="status-item">
          <div class="k">ç³»çµ±ç‹€æ…‹</div>
          <div class="v" id="status">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="k">åµæ¸¬é€Ÿåº¦</div>
          <div class="v" id="fps">â€”</div>
        </div>
        <div class="status-item">
          <div class="k">éšœç¤™ç‰©æ•¸</div>
          <div class="v" id="obstacleCount">0</div>
        </div>
        <div class="status-item">
          <div class="k">æœ€è¿‘è·é›¢</div>
          <div class="v" id="closestDistance">â€” å…¬å°º</div>
        </div>
      </div>
      
      <div class="status">
        <div class="status-item">
          <div class="k">GPSç‹€æ…‹</div>
          <div class="v" id="gpsStatus">æœªé€£æ¥</div>
        </div>
        <div class="status-item">
          <div class="k">è·å®¶è·é›¢</div>
          <div class="v" id="homeDistance">--</div>
        </div>
        <div class="status-item">
          <div class="k">è·Ÿéš¨ç‹€æ…‹</div>
          <div class="v" id="followStatus">æœªå•Ÿå‹•</div>
        </div>
        <div class="status-item">
          <div class="k">èªéŸ³ç‹€æ…‹</div>
          <div class="v" id="voiceStatus">é–‹å•Ÿ</div>
        </div>
      </div>
      
      <!-- ç´…å¤–ç·šæ¸¬è·é¡¯ç¤º -->
      <div id="infraredDisplay" class="status-item" style="display: none;">
        <div class="k">ç´…å¤–ç·šæ¸¬è·</div>
        <div class="v">-- å…¬å°º</div>
      </div>
    </section>

    <aside class="card panel">
      <h3 style="margin:0 0 12px 0; font-size:16px;">
        å³æ™‚åµæ¸¬ <span id="activeModuleTag" class="module-tag">æ™ºèƒ½æ¨¡å¼</span>
      </h3>
      <div id="detectionList" class="list">
        <div class="chip" style="text-align:center; color:var(--muted);">
          ç­‰å¾…é–‹å§‹åµæ¸¬â€¦
        </div>
      </div>
      <footer>
        å°ˆç‚ºè¦–éšœæœ‹å‹è¨­è¨ˆ Â· æ™ºèƒ½è¡Œäººè·Ÿéš¨ç³»çµ±<br>
        è‡ªå‹•è·Ÿéš¨å‰æ–¹è¡Œäººï¼Œå®‰å…¨åˆæ–¹ä¾¿
      </footer>
    </aside>
  </div>

  <script>
    /**********************
     * 1) åƒæ•¸è¨­å®š
     **********************/
    const TARGET_FPS = 15;
    const INTERVAL = 1000 / TARGET_FPS;
    const SCORE_THRESHOLD = 0.2;
    const MIN_CONFIDENCE_FOR_PERSON = 0.4;

    /**********************
     * 2) å®Œæ•´çš„è¡Œäººè·Ÿéš¨å°èˆªç³»çµ±
     **********************/
    class PedestrianFollowingSystem {
        constructor() {
            this.isActive = false;
            this.targetPerson = null;
            this.lastPersonPosition = null;
            this.trackingHistory = [];
            this.maxHistoryLength = 10;
            this.lastGuidanceTime = 0;
            this.guidanceCooldown = 8000;
            this.lostTargetTime = 0;
            this.maxLostTime = 15000;
            this.lastDistanceAlert = 0;
            this.distanceAlertCooldown = 6000;
        }

        start() {
            this.isActive = true;
            this.targetPerson = null;
            this.trackingHistory = [];
            this.showIndicator();
            updateVoice('è¡Œäººè·Ÿéš¨æ¨¡å¼å·²å•Ÿå‹•ï¼Œæ­£åœ¨å°‹æ‰¾å¯è·Ÿéš¨çš„è¡Œäºº');
            updateFollowStatus('å°‹æ‰¾ç›®æ¨™ä¸­');
            
            // åœæ­¢å…¶ä»–å°èˆªæ¨¡å¼
            if (safetyNavigator.isActive) {
                safetyNavigator.stop();
                document.getElementById('btnReturnHome').textContent = 'å®‰å…¨é€šé“å°èˆª';
                document.getElementById('btnReturnHome').classList.remove('gps-active');
            }
        }

        stop() {
            this.isActive = false;
            this.targetPerson = null;
            this.hideIndicator();
            updateVoice('è¡Œäººè·Ÿéš¨æ¨¡å¼å·²é—œé–‰');
            updateFollowStatus('æœªå•Ÿå‹•');
        }

        findBestTarget(predictions, frameWidth, frameHeight) {
            if (!this.isActive) return null;

            const persons = predictions.filter(pred => 
                pred.class === 'person' && pred.score > 0.5
            );

            if (persons.length === 0) {
                if (this.targetPerson && Date.now() - this.lostTargetTime > this.maxLostTime) {
                    updateVoice('è·Ÿéš¨ç›®æ¨™å·²ä¸Ÿå¤±ï¼Œè«‹å°å¿ƒå‰é€²');
                    updateFollowStatus('ç›®æ¨™ä¸Ÿå¤±');
                    this.targetPerson = null;
                } else if (this.targetPerson) {
                    updateFollowStatus('è·Ÿéš¨ä¸­');
                } else {
                    updateFollowStatus('å°‹æ‰¾ç›®æ¨™ä¸­');
                }
                return null;
            }

            if (this.targetPerson) {
                const currentTarget = persons.find(p => this.isSamePerson(p, this.targetPerson));
                if (currentTarget) {
                    this.lostTargetTime = Date.now();
                    updateFollowStatus('è·Ÿéš¨ä¸­');
                    return currentTarget;
                }
            }

            let bestTarget = null;
            let bestScore = -1;

            persons.forEach(person => {
                const score = this.calculateTargetScore(person, frameWidth, frameHeight);
                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = person;
                }
            });

            if (bestTarget && bestScore > 0.4) {
                this.targetPerson = bestTarget;
                this.lostTargetTime = Date.now();
                updateVoice('å·²é–å®šè·Ÿéš¨ç›®æ¨™ï¼Œè«‹ä¿æŒå®‰å…¨è·é›¢è·Ÿéš¨');
                updateFollowStatus('è·Ÿéš¨ä¸­');
                return bestTarget;
            }

            updateFollowStatus('å°‹æ‰¾ç›®æ¨™ä¸­');
            return null;
        }

        calculateTargetScore(person, frameWidth, frameHeight) {
            const [x, y, w, h] = person.bbox;
            const centerX = x + w / 2;
            const centerY = y + h / 2;
            
            let score = 0;
            
            const centerDistance = Math.abs(centerX - frameWidth / 2) / frameWidth;
            score += (1 - centerDistance) * 0.3;
            
            const sizeScore = Math.min(w * h / (frameWidth * frameHeight * 0.1), 1);
            score += sizeScore * 0.3;
            
            if (this.isSamePerson(person, this.targetPerson)) {
                score += 0.4;
            }
            
            return score;
        }

        isSamePerson(personA, personB) {
            if (!personB) return false;
            
            const [ax, ay, aw, ah] = personA.bbox;
            const [bx, by, bw, bh] = personB.bbox;
            
            const centerAX = ax + aw / 2;
            const centerAY = ay + ah / 2;
            const centerBX = bx + bw / 2;
            const centerBY = by + bh / 2;
            
            const distance = Math.sqrt(
                Math.pow(centerAX - centerBX, 2) + 
                Math.pow(centerAY - centerBY, 2)
            );
            
            return distance < 100;
        }

        provideFollowingGuidance(target, frameWidth, frameHeight) {
            if (!this.isActive || !target) return;
            
            const now = Date.now();
            const [x, y, w, h] = target.bbox;
            const centerX = x + w / 2;
            const distance = estimateDistance(w, h, 'person');
            
            if (distance < 2 && now - this.lastDistanceAlert > this.distanceAlertCooldown) {
                updateVoice('è·Ÿéš¨è·é›¢å¤ªè¿‘ï¼Œè«‹ä¿æŒå®‰å…¨è·é›¢');
                this.lastDistanceAlert = now;
                this.lastGuidanceTime = now;
                return;
            }
            
            if (distance > 10 && now - this.lastDistanceAlert > this.distanceAlertCooldown) {
                updateVoice('è·Ÿéš¨è·é›¢éé ï¼Œè«‹ç¨åŠ å¿«è…³æ­¥');
                this.lastDistanceAlert = now;
                this.lastGuidanceTime = now;
                return;
            }
            
            if (now - this.lastGuidanceTime < this.guidanceCooldown) return;
            
            const screenCenter = frameWidth / 2;
            const offset = centerX - screenCenter;
            const offsetRatio = Math.abs(offset) / screenCenter;
            
            if (offsetRatio > 0.4) {
                const direction = offset > 0 ? 'å³' : 'å·¦';
                updateVoice(`ç›®æ¨™å${direction}ï¼Œè«‹ç¨å‘${direction}èª¿æ•´`);
                this.lastGuidanceTime = now;
            }
            
            this.trackingHistory.push({
                person: target,
                timestamp: now,
                position: { x: centerX, y: y + h / 2 }
            });
            
            if (this.trackingHistory.length > this.maxHistoryLength) {
                this.trackingHistory.shift();
            }
        }

        updateDisplay(target, ctx, frameWidth, frameHeight) {
            if (!this.isActive || !target) return;
            
            const [x, y, w, h] = target.bbox;
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 4;
            ctx.strokeRect(x, y, w, h);
            
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            ctx.fillRect(x, y, w, h);
            
            const distance = estimateDistance(w, h, 'person');
            ctx.fillStyle = '#00ff00';
            ctx.font = '18px Arial';
            ctx.fillText(`ğŸ‘¥ è·Ÿéš¨ç›®æ¨™ ${distance.toFixed(1)}m`, x, y - 10);
            
            this.drawSafetyZone(ctx, frameWidth, frameHeight, target);
        }

        drawSafetyZone(ctx, frameWidth, frameHeight, target) {
            const [x, y, w, h] = target.bbox;
            const centerX = x + w / 2;
            
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            const safeWidth = frameWidth * 0.6;
            ctx.strokeRect(centerX - safeWidth / 2, y - 30, safeWidth, h + 60);
            
            ctx.setLineDash([]);
        }

        showIndicator() {
            const indicator = document.getElementById('followingIndicator');
            if (indicator) indicator.classList.add('active');
        }

        hideIndicator() {
            const indicator = document.getElementById('followingIndicator');
            if (indicator) indicator.classList.remove('active');
        }
    }

    /**********************
     * 3) å®Œæ•´çš„ç’°å¢ƒæ¨¡çµ„ç³»çµ±
     **********************/
    const environmentModules = {
      outdoor: {
        name: 'æˆ¶å¤–å°èˆª',
        objects: {
          'car': { name: 'æ±½è»Š', danger: 'high', voice: 'å‰æ–¹æœ‰æ±½è»Šï¼Œè«‹ä¿æŒå®‰å…¨è·é›¢' },
          'motorcycle': { name: 'æ‘©æ‰˜è»Š', danger: 'high', voice: 'æ³¨æ„ï¼å‰æ–¹æœ‰æ‘©æ‰˜è»Š' },
          'bus': { name: 'å…¬è»Š', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å…¬è»Š' },
          'truck': { name: 'å¡è»Š', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å¡è»Š' },
          'bicycle': { name: 'è…³è¸è»Š', danger: 'medium', voice: 'å‰æ–¹æœ‰è…³è¸è»Š' },
          'traffic light': { name: 'ç´…ç¶ ç‡ˆ', danger: 'medium', voice: 'å‰æ–¹æœ‰ç´…ç¶ ç‡ˆï¼Œè«‹æ³¨æ„äº¤é€šè™ŸèªŒ' },
          'stop sign': { name: 'åœæ­¢æ¨™èªŒ', danger: 'medium', voice: 'åœæ­¢æ¨™èªŒï¼Œè«‹åœè»Šè§€å¯Ÿ' },
          'person': { name: 'è¡Œäºº', danger: 'medium', voice: 'å‰æ–¹æœ‰è¡Œäºº' },
          'bench': { name: 'é•·æ¤…', danger: 'low', voice: 'å‰æ–¹æœ‰é•·æ¤…' },
          'fire hydrant': { name: 'æ¶ˆé˜²æ “', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¶ˆé˜²æ “' },
          'parking meter': { name: 'åœè»Šè¨ˆæ™‚å™¨', danger: 'low', voice: 'å‰æ–¹æœ‰åœè»Šè¨ˆæ™‚å™¨' },
          'traffic cone': { name: 'äº¤é€šéŒ', danger: 'medium', voice: 'å‰æ–¹æœ‰äº¤é€šéŒï¼Œæ–½å·¥å€åŸŸ' },
          'pothole': { name: 'å‘æ´', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å‘æ´ï¼Œè«‹ç¹è¡Œ' },
          'crack': { name: 'è·¯é¢è£‚ç¸«', danger: 'medium', voice: 'å‰æ–¹æœ‰è·¯é¢è£‚ç¸«ï¼Œè«‹å°å¿ƒ' },
          'manhole': { name: 'äººå­”è“‹', danger: 'medium', voice: 'å‰æ–¹æœ‰äººå­”è“‹ï¼Œè«‹æ³¨æ„' },
          'curb': { name: 'è·¯ç·£çŸ³', danger: 'medium', voice: 'å‰æ–¹æœ‰è·¯ç·£çŸ³ï¼Œè«‹æŠ¬è…³' },
          'grate': { name: 'æ’æ°´æ ¼æŸµ', danger: 'medium', voice: 'å‰æ–¹æœ‰æ’æ°´æ ¼æŸµï¼Œè«‹å°å¿ƒ' },
          'train': { name: 'ç«è»Š', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰ç«è»Šï¼Œè«‹é é›¢è»Œé“' },
          'airplane': { name: 'é£›æ©Ÿ', danger: 'high', voice: 'å‰æ–¹æœ‰é£›æ©Ÿ' },
          'boat': { name: 'èˆ¹', danger: 'high', voice: 'å‰æ–¹æœ‰èˆ¹ï¼Œè«‹é é›¢æ°´åŸŸ' },
          'bird': { name: 'é³¥', danger: 'low', voice: 'å‰æ–¹æœ‰é³¥' },
          'cat': { name: 'è²“', danger: 'low', voice: 'å‰æ–¹æœ‰è²“' },
          'dog': { name: 'ç‹—', danger: 'medium', voice: 'å‰æ–¹æœ‰ç‹—ï¼Œè«‹å°å¿ƒ' },
          'horse': { name: 'é¦¬', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰é¦¬ï¼Œè«‹ä¿æŒè·é›¢' },
          'sheep': { name: 'ç¾Š', danger: 'medium', voice: 'å‰æ–¹æœ‰ç¾Š' },
          'cow': { name: 'ç‰›', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰ç‰›ï¼Œè«‹ä¿æŒè·é›¢' },
          'tree': { name: 'æ¨¹', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¨¹' },
          'flower': { name: 'èŠ±', danger: 'low', voice: 'å‰æ–¹æœ‰èŠ±' },
          'grass': { name: 'è‰åœ°', danger: 'low', voice: 'å‰æ–¹æœ‰è‰åœ°' },
          'building': { name: 'å»ºç¯‰ç‰©', danger: 'medium', voice: 'å‰æ–¹æœ‰å»ºç¯‰ç‰©' },
          'house': { name: 'æˆ¿å±‹', danger: 'medium', voice: 'å‰æ–¹æœ‰æˆ¿å±‹' },
          'skyscraper': { name: 'æ‘©å¤©å¤§æ¨“', danger: 'medium', voice: 'å‰æ–¹æœ‰æ‘©å¤©å¤§æ¨“' },
          'bridge': { name: 'æ©‹æ¨‘', danger: 'medium', voice: 'å‰æ–¹æœ‰æ©‹æ¨‘' },
          'fountain': { name: 'å™´æ³‰', danger: 'medium', voice: 'å‰æ–¹æœ‰å™´æ³‰' },
          'statue': { name: 'é›•åƒ', danger: 'medium', voice: 'å‰æ–¹æœ‰é›•åƒ' },
          'crosswalk': { name: 'æ–‘é¦¬ç·š', danger: 'medium', voice: 'å‰æ–¹æœ‰æ–‘é¦¬ç·šï¼Œè«‹æ³¨æ„ä¾†è»Š' },
          'sidewalk': { name: 'äººè¡Œé“', danger: 'low', voice: 'å‰æ–¹æœ‰äººè¡Œé“' },
          'street lamp': { name: 'è·¯ç‡ˆ', danger: 'medium', voice: 'å‰æ–¹æœ‰è·¯ç‡ˆ' },
          'billboard': { name: 'å»£å‘Šçœ‹æ¿', danger: 'low', voice: 'å‰æ–¹æœ‰å»£å‘Šçœ‹æ¿' },
          'bus stop': { name: 'å…¬è»Šç«™', danger: 'medium', voice: 'å‰æ–¹æœ‰å…¬è»Šç«™' },
          'train station': { name: 'ç«è»Šç«™', danger: 'medium', voice: 'å‰æ–¹æœ‰ç«è»Šç«™' },
          'airport': { name: 'æ©Ÿå ´', danger: 'medium', voice: 'å‰æ–¹æœ‰æ©Ÿå ´' },
          'park': { name: 'å…¬åœ’', danger: 'low', voice: 'å‰æ–¹æœ‰å…¬åœ’' },
          'playground': { name: 'éŠæ¨‚å ´', danger: 'medium', voice: 'å‰æ–¹æœ‰éŠæ¨‚å ´' },
          'beach': { name: 'æµ·ç˜', danger: 'medium', voice: 'å‰æ–¹æœ‰æµ·ç˜' },
          'mountain': { name: 'å±±', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å±±ï¼Œè«‹å°å¿ƒåœ°å½¢' },
          'river': { name: 'æ²³æµ', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰æ²³æµï¼Œè«‹é é›¢æ°´åŸŸ' },
          'lake': { name: 'æ¹–æ³Š', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰æ¹–æ³Šï¼Œè«‹é é›¢æ°´åŸŸ' },
          'ocean': { name: 'æµ·æ´‹', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰æµ·æ´‹ï¼Œè«‹é é›¢æ°´åŸŸ' }
        },
        triggers: ['car', 'motorcycle', 'bus', 'traffic light', 'stop sign', 'person', 'pothole', 'curb', 'train', 'dog', 'cow', 'mountain', 'river']
      },
      indoor: {
        name: 'å®¤å…§ç’°å¢ƒ',
        objects: {
          'chair': { name: 'æ¤…å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¤…å­ï¼Œè«‹ç¹è¡Œ' },
          'couch': { name: 'æ²™ç™¼', danger: 'medium', voice: 'å‰æ–¹æœ‰æ²™ç™¼' },
          'bed': { name: 'åºŠ', danger: 'medium', voice: 'å‰æ–¹æœ‰åºŠ' },
          'dining table': { name: 'é¤æ¡Œ', danger: 'medium', voice: 'å‰æ–¹æœ‰é¤æ¡Œ' },
          'potted plant': { name: 'ç›†æ ½', danger: 'low', voice: 'å‰æ–¹æœ‰ç›†æ ½' },
          'tv': { name: 'é›»è¦–', danger: 'medium', voice: 'å‰æ–¹æœ‰é›»è¦–' },
          'laptop': { name: 'ç­†è¨˜å‹é›»è…¦', danger: 'medium', voice: 'å‰æ–¹æœ‰é›»è…¦' },
          'mouse': { name: 'æ»‘é¼ ', danger: 'low', voice: 'å‰æ–¹æœ‰æ»‘é¼ ' },
          'remote': { name: 'é™æ§å™¨', danger: 'low', voice: 'å‰æ–¹æœ‰é™æ§å™¨' },
          'keyboard': { name: 'éµç›¤', danger: 'low', voice: 'å‰æ–¹æœ‰éµç›¤' },
          'cell phone': { name: 'æ‰‹æ©Ÿ', danger: 'low', voice: 'å‰æ–¹æœ‰æ‰‹æ©Ÿ' },
          'book': { name: 'æ›¸æœ¬', danger: 'low', voice: 'å‰æ–¹æœ‰æ›¸æœ¬' },
          'vase': { name: 'èŠ±ç“¶', danger: 'medium', voice: 'å‰æ–¹æœ‰èŠ±ç“¶ï¼Œæ˜“ç¢ç‰©å“è«‹å°å¿ƒ' },
          'clock': { name: 'æ™‚é˜', danger: 'low', voice: 'å‰æ–¹æœ‰æ™‚é˜' },
          'scissors': { name: 'å‰ªåˆ€', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å‰ªåˆ€ï¼Œé‹’åˆ©ç‰©å“è«‹å°å¿ƒ' },
          'bottle': { name: 'ç“¶å­', danger: 'medium', voice: 'å‰æ–¹æœ‰ç“¶å­' },
          'cup': { name: 'æ¯å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¯å­' },
          'bowl': { name: 'ç¢—', danger: 'medium', voice: 'å‰æ–¹æœ‰ç¢—' },
          'fork': { name: 'å‰å­', danger: 'medium', voice: 'å‰æ–¹æœ‰å‰å­' },
          'knife': { name: 'åˆ€å­', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰åˆ€å­ï¼Œé‹’åˆ©ç‰©å“è«‹å°å¿ƒ' },
          'spoon': { name: 'æ¹¯åŒ™', danger: 'low', voice: 'å‰æ–¹æœ‰æ¹¯åŒ™' },
          'teddy bear': { name: 'ç©å…·ç†Š', danger: 'low', voice: 'å‰æ–¹æœ‰ç©å…·ç†Š' },
          'umbrella': { name: 'é›¨å‚˜', danger: 'medium', voice: 'å‰æ–¹æœ‰é›¨å‚˜' },
          'handbag': { name: 'æ‰‹æåŒ…', danger: 'low', voice: 'å‰æ–¹æœ‰æ‰‹æåŒ…' },
          'backpack': { name: 'èƒŒåŒ…', danger: 'low', voice: 'å‰æ–¹æœ‰èƒŒåŒ…' },
          'rug': { name: 'åœ°æ¯¯', danger: 'low', voice: 'å‰æ–¹æœ‰åœ°æ¯¯ï¼Œè«‹æ³¨æ„é‚Šç·£' },
          'threshold': { name: 'é–€æª»', danger: 'medium', voice: 'å‰æ–¹æœ‰é–€æª»ï¼Œè«‹æŠ¬è…³' },
          'step': { name: 'å°éš', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰å°éšï¼Œè«‹å°å¿ƒä¸Šä¸‹' },
          'stair': { name: 'æ¨“æ¢¯', danger: 'high', voice: 'è­¦å‘Šï¼å‰æ–¹æœ‰æ¨“æ¢¯ï¼Œè«‹å°å¿ƒä¸Šä¸‹' },
          'cable': { name: 'é›»ç·š', danger: 'medium', voice: 'å‰æ–¹æœ‰é›»ç·šï¼Œè«‹å°å¿ƒçµ†å€’' },
          'toy': { name: 'ç©å…·', danger: 'medium', voice: 'å‰æ–¹æœ‰ç©å…·ï¼Œè«‹å°å¿ƒ' },
          'table': { name: 'æ¡Œå­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¡Œå­' },
          'desk': { name: 'æ›¸æ¡Œ', danger: 'medium', voice: 'å‰æ–¹æœ‰æ›¸æ¡Œ' },
          'cabinet': { name: 'æ«ƒå­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ«ƒå­' },
          'shelf': { name: 'æ¶å­', danger: 'medium', voice: 'å‰æ–¹æœ‰æ¶å­' },
          'drawer': { name: 'æŠ½å±œ', danger: 'low', voice: 'å‰æ–¹æœ‰æŠ½å±œ' },
          'mirror': { name: 'é¡å­', danger: 'medium', voice: 'å‰æ–¹æœ‰é¡å­ï¼Œè«‹å°å¿ƒç¢°æ’' },
          'picture': { name: 'ç•«', danger: 'low', voice: 'å‰æ–¹æœ‰ç•«' },
          'frame': { name: 'ç›¸æ¡†', danger: 'low', voice: 'å‰æ–¹æœ‰ç›¸æ¡†' },
          'lamp': { name: 'ç‡ˆ', danger: 'low', voice: 'å‰æ–¹æœ‰ç‡ˆ' },
          'light': { name: 'ç‡ˆå…‰', danger: 'low', voice: 'å‰æ–¹æœ‰ç‡ˆå…‰' },
          'fan': { name: 'é¢¨æ‰‡', danger: 'medium', voice: 'å‰æ–¹æœ‰é¢¨æ‰‡' },
          'air conditioner': { name: 'å†·æ°£æ©Ÿ', danger: 'medium', voice: 'å‰æ–¹æœ‰å†·æ°£æ©Ÿ' },
          'heater': { name: 'æš–æ°£æ©Ÿ', danger: 'medium', voice: 'å‰æ–¹æœ‰æš–æ°£æ©Ÿ' },
          'window': { name: 'çª—æˆ¶', danger: 'medium', voice: 'å‰æ–¹æœ‰çª—æˆ¶' },
          'door': { name: 'é–€', danger: 'medium', voice: 'å‰æ–¹æœ‰é–€' },
          'curtain': { name: 'çª—ç°¾', danger: 'low', voice: 'å‰æ–¹æœ‰çª—ç°¾' },
          'blinds': { name: 'ç™¾è‘‰çª—', danger: 'low', voice: 'å‰æ–¹æœ‰ç™¾è‘‰çª—' },
          'wall': { name: 'ç‰†å£', danger: 'medium', voice: 'å‰æ–¹æœ‰ç‰†å£' },
          'floor': { name: 'åœ°æ¿', danger: 'low', voice: 'å‰æ–¹æœ‰åœ°æ¿' },
          'ceiling': { name: 'å¤©èŠ±æ¿', danger: 'low', voice: 'å‰æ–¹æœ‰å¤©èŠ±æ¿' },
          'pillow': { name: 'æ•é ­', danger: 'low', voice: 'å‰æ–¹æœ‰æ•é ­' },
          'blanket': { name: 'æ¯¯å­', danger: 'low', voice: 'å‰æ–¹æœ‰æ¯¯å­' },
          'sheet': { name: 'åºŠå–®', danger: 'low', voice: 'å‰æ–¹æœ‰åºŠå–®' },
          'clothes': { name: 'è¡£æœ', danger: 'low', voice: 'å‰æ–¹æœ‰è¡£æœ' },
          'shoes': { name: 'é‹å­', danger: 'low', voice: 'å‰æ–¹æœ‰é‹å­' },
          'hat': { name: 'å¸½å­', danger: 'low', voice: 'å‰æ–¹æœ‰å¸½å­' },
          'glasses': { name: 'çœ¼é¡', danger: 'low', voice: 'å‰æ–¹æœ‰çœ¼é¡' },
          'watch': { name: 'æ‰‹éŒ¶', danger: 'low', voice: 'å‰æ–¹æœ‰æ‰‹éŒ¶' },
          'jewelry': { name: 'ç å¯¶', danger: 'low', voice: 'å‰æ–¹æœ‰ç å¯¶' },
          'wallet': { name: 'éŒ¢åŒ…', danger: 'low', voice: 'å‰æ–¹æœ‰éŒ¢åŒ…' },
          'keys': { name: 'é‘°åŒ™', danger: 'low', voice: 'å‰æ–¹æœ‰é‘°åŒ™' },
          'phone': { name: 'é›»è©±', danger: 'low', voice: 'å‰æ–¹æœ‰é›»è©±' },
          'computer': { name: 'é›»è…¦', danger: 'medium', voice: 'å‰æ–¹æœ‰é›»è…¦' },
          'printer': { name: 'å°è¡¨æ©Ÿ', danger: 'medium', voice: 'å‰æ–¹æœ‰å°è¡¨æ©Ÿ' },
          'scanner': { name: 'æƒæå™¨', danger: 'low', voice: 'å‰æ–¹æœ‰æƒæå™¨' },
          'camera': { name: 'ç›¸æ©Ÿ', danger: 'low', voice: 'å‰æ–¹æœ‰ç›¸æ©Ÿ' },
          'speaker': { name: 'å–‡å­', danger: 'low', voice: 'å‰æ–¹æœ‰å–‡å­' },
          'headphones': { name: 'è€³æ©Ÿ', danger: 'low', voice: 'å‰æ–¹æœ‰è€³æ©Ÿ' },
          'microphone': { name: 'éº¥å…‹é¢¨', danger: 'low', voice: 'å‰æ–¹æœ‰éº¥å…‹é¢¨' },
          'game console': { name: 'éŠæˆ²æ©Ÿ', danger: 'low', voice: 'å‰æ–¹æœ‰éŠæˆ²æ©Ÿ' },
          'television': { name: 'é›»è¦–æ©Ÿ', danger: 'medium', voice: 'å‰æ–¹æœ‰é›»è¦–æ©Ÿ' },
          'radio': { name: 'æ”¶éŸ³æ©Ÿ', danger: 'low', voice: 'å‰æ–¹æœ‰æ”¶éŸ³æ©Ÿ' },
          'cd player': { name: 'CDæ’­æ”¾å™¨', danger: 'low', voice: 'å‰æ–¹æœ‰CDæ’­æ”¾å™¨' },
          'dvd player': { name: 'DVDæ’­æ”¾å™¨', danger: 'low', voice: 'å‰æ–¹æœ‰DVDæ’­æ”¾å™¨' },
          'blu-ray player': { name: 'è—å…‰æ’­æ”¾å™¨', danger: 'low', voice: 'å‰æ–¹æœ‰è—å…‰æ’­æ”¾å™¨' },
          'projector': { name: 'æŠ•å½±æ©Ÿ', danger: 'medium', voice: 'å‰æ–¹æœ‰æŠ•å½±æ©Ÿ' },
          'screen': { name: 'è¢å¹•', danger: 'medium', voice: 'å‰æ–¹æœ‰è¢å¹•' },
          'whiteboard': { name: 'ç™½æ¿', danger: 'low', voice: 'å‰æ–¹æœ‰ç™½æ¿' },
          'blackboard': { name: 'é»‘æ¿', danger: 'low', voice: 'å‰æ–¹æœ‰é»‘æ¿' },
          'calendar': { name: 'æ—¥æ›†', danger: 'low', voice: 'å‰æ–¹æœ‰æ—¥æ›†' },
          'clock': { name: 'æ™‚é˜', danger: 'low', voice: 'å‰æ–¹æœ‰æ™‚é˜' },
          'thermometer': { name: 'æº«åº¦è¨ˆ', danger: 'low', voice: 'å‰æ–¹æœ‰æº«åº¦è¨ˆ' },
          'barometer': { name: 'æ°£å£“è¨ˆ', danger: 'low', voice: 'å‰æ–¹æœ‰æ°£å£“è¨ˆ' },
          'hygrometer': { name: 'æ¿•åº¦è¨ˆ', danger: 'low', voice: 'å‰æ–¹æœ‰æ¿•åº¦è¨ˆ' },
          'toilet': { name: 'é¦¬æ¡¶', danger: 'medium', voice: 'å‰æ–¹æœ‰é¦¬æ¡¶ï¼Œè«‹å°å¿ƒ' }
        },
        triggers: ['chair', 'bed', 'dining table', 'tv', 'laptop', 'vase', 'knife', 'scissors', 'step', 'stair', 'threshold', 'door', 'window', 'toilet']
      }
      // å…¶ä»–ç’°å¢ƒæ¨¡çµ„ä¿æŒå®Œæ•´...
    };

    /**********************
     * 4) å®Œæ•´çš„GPSå°èˆªç³»çµ±
     **********************/
    class GPSNavigator {
      constructor() {
        this.homePosition = null;
        this.currentPosition = null;
        this.isTracking = false;
        this.watchId = null;
        this.returnHomeInterval = null;
        this.lastNavigationAlert = 0;
        this.lastReportedDistance = 0;
        this.loadHomePosition();
      }

      loadHomePosition() {
        const saved = localStorage.getItem('homePosition');
        if (saved) {
          this.homePosition = JSON.parse(saved);
          updateGPSStatus('å°±ç·’');
          document.getElementById('btnSetHome').classList.add('gps-active');
        }
      }

      setHomePosition() {
        if (!navigator.geolocation) {
          updateVoice('æ‚¨çš„è£ç½®ä¸æ”¯æ´GPSå®šä½');
          return;
        }

        updateVoice('æ­£åœ¨ç²å–ç•¶å‰ä½ç½®...');
        navigator.geolocation.getCurrentPosition(
          (position) => {
            this.homePosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              timestamp: new Date().toISOString()
            };
            localStorage.setItem('homePosition', JSON.stringify(this.homePosition));
            updateVoice(`å®¶çš„ä½ç½®å·²è¨˜éŒ„ï¼`);
            updateGPSStatus('å·²è¨­å®šå®¶');
            document.getElementById('btnSetHome').classList.add('gps-active');
          },
          (error) => {
            let errorMsg = 'ç„¡æ³•ç²å–ä½ç½®ï¼š';
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMsg += 'è«‹å…è¨±ä½ç½®æ¬Šé™';
                break;
              case error.POSITION_UNAVAILABLE:
                errorMsg += 'ä½ç½®è³‡è¨Šä¸å¯ç”¨';
                break;
              case error.TIMEOUT:
                errorMsg += 'å®šä½è«‹æ±‚è¶…æ™‚';
                break;
              default:
                errorMsg += 'æœªçŸ¥éŒ¯èª¤';
            }
            updateVoice(errorMsg);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          }
        );
      }

      startReturnHome() {
        if (!this.homePosition) {
          updateVoice('è«‹å…ˆè¨­å®šå®¶çš„ä½ç½®');
          return;
        }

        if (this.isTracking) {
          this.stopReturnHome();
          updateVoice('è¿”èˆªå°èˆªå·²å–æ¶ˆ');
          return;
        }

        this.isTracking = true;
        updateVoice('é–‹å§‹å®‰å…¨é€šé“è¿”èˆªå°èˆªï¼Œç³»çµ±å°‡å¼•å°æ‚¨èµ°å®‰å…¨è·¯ç·š');
        updateGPSStatus('å®‰å…¨è¿”èˆªä¸­');
        document.getElementById('btnReturnHome').classList.add('gps-active');
        document.getElementById('btnReturnHome').textContent = 'å–æ¶ˆè¿”èˆª';

        this.watchId = navigator.geolocation.watchPosition(
          (position) => {
            this.currentPosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              accuracy: position.coords.accuracy
            };
            this.updateNavigation();
          },
          (error) => {
            updateVoice('GPSä¿¡è™Ÿä¸ç©©å®š');
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 3000
          }
        );

        this.returnHomeInterval = setInterval(() => {
          if (this.currentPosition) {
            this.updateNavigation();
          }
        }, 10000);
      }

      updateNavigation() {
        const navInfo = this.calculateNavigation();
        if (!navInfo) return;

        const { distance, direction } = navInfo;
        document.getElementById('homeDistance').textContent = `${distance}m`;

        const now = Date.now();
        if (now - this.lastNavigationAlert < 10000) return;
        
        this.lastNavigationAlert = now;

        if (distance < 20) {
          updateVoice(`å·²æ¥è¿‘ç›®çš„åœ°ï¼Œè·é›¢${Math.round(distance)}å…¬å°º`);
        } else if (distance < 50 && distance !== this.lastReportedDistance) {
          updateVoice(`è·å®¶${Math.round(distance)}å…¬å°ºï¼Œè«‹ç¹¼çºŒå‰é€²`);
        } else if (distance < 200 && (distance - this.lastReportedDistance) > 10) {
          updateVoice(`å®‰å…¨è·¯ç·šå°èˆªä¸­ï¼Œè·å®¶${Math.round(distance)}å…¬å°º`);
        } else if ((distance - this.lastReportedDistance) > 30) {
          updateVoice(`æ³¨æ„ï¼æ‚¨æ­£åœ¨é é›¢ç›®çš„åœ°ï¼Œè«‹è¿´è½‰æˆ–å°‹æ‰¾æ­£ç¢ºè·¯ç·š`);
        }
        
        this.lastReportedDistance = distance;
      }

      calculateNavigation() {
        if (!this.currentPosition || !this.homePosition) return null;

        const R = 6371000;
        const Ï†1 = this.currentPosition.lat * Math.PI/180;
        const Ï†2 = this.homePosition.lat * Math.PI/180;
        const Î”Ï† = (this.homePosition.lat - this.currentPosition.lat) * Math.PI/180;
        const Î”Î» = (this.homePosition.lng - this.currentPosition.lng) * Math.PI/180;

        const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                  Math.cos(Ï†1) * Math.cos(Ï†2) *
                  Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = Math.round(R * c);

        const y = Math.sin(Î”Î») * Math.cos(Ï†2);
        const x = Math.cos(Ï†1) * Math.sin(Ï†2) -
                  Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î”Î»);
        const Î¸ = Math.atan2(y, x);
        const bearing = (Î¸ * 180/Math.PI + 360) % 360;

        const direction = this.getDirectionFromBearing(bearing);
        return { distance, direction };
      }

      getDirectionFromBearing(bearing) {
        const directions = ['æ­£å‰æ–¹', 'å³å‰æ–¹', 'å³å´', 'å³å¾Œæ–¹', 'æ­£å¾Œæ–¹', 'å·¦å¾Œæ–¹', 'å·¦å´', 'å·¦å‰æ–¹'];
        const index = Math.round(bearing / 45) % 8;
        return directions[index];
      }

      stopReturnHome() {
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
          this.watchId = null;
        }
        if (this.returnHomeInterval) {
          clearInterval(this.returnHomeInterval);
          this.returnHomeInterval = null;
        }
        this.isTracking = false;
        updateGPSStatus('å°±ç·’');
        document.getElementById('btnReturnHome').classList.remove('gps-active');
        document.getElementById('btnReturnHome').textContent = 'ä¸€éµè¿”èˆª';
      }
    }

    /**********************
     * 5) å®Œæ•´çš„å®‰å…¨é€šé“å°èˆªç³»çµ±
     **********************/
    class EnhancedSafetyCorridorNavigator {
      constructor() {
        this.isActive = false;
        this.laneLines = [];
        this.sideBoundaries = [];
        this.safePath = null;
        this.lastGuidanceTime = 0;
        this.guidanceCooldown = 5000;
        
        this.detectionParams = {
          minLineLength: 50,
          maxLineGap: 20,
          houghThreshold: 30,
          roiHeight: 0.6,
          laneWidthRatio: 0.6,
          confidenceThreshold: 0.7
        };
      }

      start() {
        this.isActive = true;
        this.showCorridor();
        this.updateGuidance('æ™ºèƒ½å®‰å…¨é€šé“å°èˆªå·²å•Ÿå‹•ï¼Œæ­£åœ¨åˆ†æç’°å¢ƒ...');
      }

      stop() {
        this.isActive = false;
        this.hideCorridor();
        this.updateGuidance('å®‰å…¨é€šé“å°èˆªå·²é—œé–‰');
      }

      updateSafetyCorridor(predictions, frameWidth, frameHeight) {
        if (!this.isActive) return;

        this.laneLines = [];
        this.sideBoundaries = [];
        this.safePath = null;

        this.detectLaneMarkings(predictions, frameWidth, frameHeight);
        this.detectSideBoundaries(predictions, frameWidth, frameHeight);
        this.analyzeSafePath(frameWidth, frameHeight);
        this.provideEnhancedGuidance();
        this.updateCorridorDisplay();
      }

      detectLaneMarkings(predictions, frameWidth, frameHeight) {
        const laneMarkers = predictions.filter(pred => 
          ['line', 'road_line', 'sidewalk_line', 'curb', 'pavement_edge'].includes(pred.class) &&
          pred.score > 0.3
        );

        laneMarkers.forEach(marker => {
          const [x, y, w, h] = marker.bbox;
          const centerX = x + w / 2;
          
          if (centerX < frameWidth * 0.4) {
            this.laneLines.push({
              type: 'left_boundary',
              position: centerX,
              confidence: marker.score,
              object: marker.class
            });
          } else if (centerX > frameWidth * 0.6) {
            this.laneLines.push({
              type: 'right_boundary',
              position: centerX,
              confidence: marker.score,
              object: marker.class
            });
          }
        });

        if (this.laneLines.length === 0) {
          this.detectVirtualLanes(predictions, frameWidth, frameHeight);
        }
      }

      detectVirtualLanes(predictions, frameWidth, frameHeight) {
        const leftObjects = [];
        const rightObjects = [];
        
        predictions.forEach(pred => {
          if (pred.score < 0.3) return;
          
          const [x, y, w, h] = pred.bbox;
          const centerX = x + w / 2;
          const centerY = y + h / 2;
          
          if (centerY > frameHeight * 0.5) {
            if (centerX < frameWidth * 0.4) {
              leftObjects.push(centerX);
            } else if (centerX > frameWidth * 0.6) {
              rightObjects.push(centerX);
            }
          }
        });

        if (leftObjects.length > 0) {
          const avgLeft = leftObjects.reduce((a, b) => a + b, 0) / leftObjects.length;
          this.laneLines.push({
            type: 'left_boundary',
            position: avgLeft,
            confidence: 0.6,
            object: 'virtual_boundary'
          });
        }

        if (rightObjects.length > 0) {
          const avgRight = rightObjects.reduce((a, b) => a + b, 0) / rightObjects.length;
          this.laneLines.push({
            type: 'right_boundary',
            position: avgRight,
            confidence: 0.6,
            object: 'virtual_boundary'
          });
        }

        if (this.laneLines.length === 0) {
          this.laneLines.push(
            { type: 'left_boundary', position: frameWidth * 0.2, confidence: 0.5, object: 'default' },
            { type: 'right_boundary', position: frameWidth * 0.8, confidence: 0.5, object: 'default' }
          );
        }
      }

      detectSideBoundaries(predictions, frameWidth, frameHeight) {
        const leftBoundaries = [];
        const rightBoundaries = [];
        
        predictions.forEach(pred => {
          if (pred.score < 0.4) return;
          
          const [x, y, w, h] = pred.bbox;
          const centerX = x + w / 2;
          const bottomY = y + h;
          
          const distance = estimateDistance(w, h, pred.class);
          if (distance > 5) return;
          
          if (centerX < frameWidth * 0.3 && bottomY > frameHeight * 0.6) {
            leftBoundaries.push({
              position: centerX + w,
              distance: distance,
              type: pred.class
            });
          } else if (centerX > frameWidth * 0.7 && bottomY > frameHeight * 0.6) {
            rightBoundaries.push({
              position: centerX,
              distance: distance,
              type: pred.class
            });
          }
        });

        if (leftBoundaries.length > 0) {
          const closestLeft = leftBoundaries.reduce((a, b) => 
            a.distance < b.distance ? a : b
          );
          this.sideBoundaries.push({
            type: 'left_obstacle',
            position: closestLeft.position,
            distance: closestLeft.distance,
            confidence: 0.8
          });
        }

        if (rightBoundaries.length > 0) {
          const closestRight = rightBoundaries.reduce((a, b) => 
            a.distance < b.distance ? a : b
          );
          this.sideBoundaries.push({
            type: 'right_obstacle',
            position: closestRight.position,
            distance: closestRight.distance,
            confidence: 0.8
          });
        }
      }

      analyzeSafePath(frameWidth, frameHeight) {
        const allBoundaries = [...this.laneLines, ...this.sideBoundaries];
        
        let leftBoundary = frameWidth * 0.1;
        let rightBoundary = frameWidth * 0.9;
        
        allBoundaries.forEach(boundary => {
          if (boundary.type === 'left_boundary' || boundary.type === 'left_obstacle') {
            leftBoundary = Math.max(leftBoundary, boundary.position);
          } else if (boundary.type === 'right_boundary' || boundary.type === 'right_obstacle') {
            rightBoundary = Math.min(rightBoundary, boundary.position);
          }
        });

        const minPathWidth = frameWidth * 0.3;
        if (rightBoundary - leftBoundary < minPathWidth) {
          const center = (leftBoundary + rightBoundary) / 2;
          leftBoundary = center - minPathWidth / 2;
          rightBoundary = center + minPathWidth / 2;
        }

        const pathCenter = (leftBoundary + rightBoundary) / 2;
        const pathWidth = rightBoundary - leftBoundary;
        
        this.safePath = {
          center: pathCenter,
          left: leftBoundary,
          right: rightBoundary,
          width: pathWidth,
          confidence: this.calculatePathConfidence(allBoundaries)
        };
      }

      calculatePathConfidence(boundaries) {
        if (boundaries.length === 0) return 0.3;
        
        const leftConfidence = boundaries.filter(b => 
          b.type.includes('left')).reduce((max, b) => Math.max(max, b.confidence), 0);
        const rightConfidence = boundaries.filter(b => 
          b.type.includes('right')).reduce((max, b) => Math.max(max, b.confidence), 0);
        
        return (leftConfidence + rightConfidence) / 2;
      }

      provideEnhancedGuidance() {
        const now = Date.now();
        if (now - this.lastGuidanceTime < this.guidanceCooldown) return;
        
        if (!this.safePath) {
          this.updateGuidance('ç„¡æ³•ç¢ºå®šå®‰å…¨é€šé“ï¼Œè«‹å°å¿ƒå‰é€²');
          return;
        }

        const screenCenter = window.innerWidth / 2;
        const pathCenter = this.safePath.center;
        const offset = pathCenter - screenCenter;
        const offsetRatio = Math.abs(offset) / (window.innerWidth / 2);

        let guidanceMessage = '';
        
        if (offsetRatio < 0.1) {
          guidanceMessage = 'æ‚¨æ­£åœ¨å®‰å…¨é€šé“ä¸­å¤®ï¼Œè«‹ä¿æŒç›´è¡Œ';
        } else if (offset > 0) {
          if (offsetRatio > 0.3) {
            guidanceMessage = 'è«‹å‘å³èª¿æ•´è¡Œèµ°æ–¹å‘ï¼Œæ‚¨å¤ªé å·¦å´';
          } else {
            guidanceMessage = 'è«‹ç¨å‘å³èª¿æ•´ï¼Œå›åˆ°é€šé“ä¸­å¤®';
          }
        } else {
          if (offsetRatio > 0.3) {
            guidanceMessage = 'è«‹å‘å·¦èª¿æ•´è¡Œèµ°æ–¹å‘ï¼Œæ‚¨å¤ªé å³å´';
          } else {
            guidanceMessage = 'è«‹ç¨å‘å·¦èª¿æ•´ï¼Œå›åˆ°é€šé“ä¸­å¤®';
          }
        }

        if (this.safePath.width < window.innerWidth * 0.4) {
          guidanceMessage += 'ï¼Œé€šé“è¼ƒçª„è«‹å°å¿ƒ';
        }

        this.updateGuidance(guidanceMessage);
        this.lastGuidanceTime = now;
      }

      updateCorridorDisplay() {
        const corridor = document.getElementById('safetyCorridor');
        const pathElement = document.querySelector('.corridor-path');
        
        if (!this.safePath || !pathElement) return;

        const leftPercent = (this.safePath.left / window.innerWidth) * 100;
        const rightPercent = 100 - (this.safePath.right / window.innerWidth) * 100;
        const widthPercent = 100 - leftPercent - rightPercent;

        pathElement.style.left = `${leftPercent}%`;
        pathElement.style.right = `${rightPercent}%`;
        pathElement.style.width = `${widthPercent}%`;

        const opacity = 0.3 + (this.safePath.confidence * 0.5);
        pathElement.style.opacity = opacity;

        this.updateSideAreas(leftPercent, rightPercent);
      }

      updateSideAreas(leftPercent, rightPercent) {
        const leftArea = document.getElementById('corridorLeft');
        const rightArea = document.getElementById('corridorRight');
        
        if (leftArea) {
          leftArea.style.width = `${leftPercent}%`;
          const hasLeftObstacle = this.sideBoundaries.some(b => b.type === 'left_obstacle');
          if (hasLeftObstacle) {
            leftArea.classList.add('obstacle-left');
          } else {
            leftArea.classList.remove('obstacle-left');
          }
        }
        
        if (rightArea) {
          rightArea.style.width = `${rightPercent}%`;
          const hasRightObstacle = this.sideBoundaries.some(b => b.type === 'right_obstacle');
          if (hasRightObstacle) {
            rightArea.classList.add('obstacle-right');
          } else {
            rightArea.classList.remove('obstacle-right');
          }
        }
      }

      showCorridor() {
        const corridor = document.getElementById('safetyCorridor');
        const guidance = document.getElementById('navigationGuidance');
        if (corridor) corridor.classList.add('active');
        if (guidance) guidance.classList.add('active');
      }

      hideCorridor() {
        const corridor = document.getElementById('safetyCorridor');
        const guidance = document.getElementById('navigationGuidance');
        if (corridor) corridor.classList.remove('active');
        if (guidance) guidance.classList.remove('active');
      }

      updateGuidance(message) {
        const guidance = document.getElementById('navigationGuidance');
        if (guidance) {
          guidance.textContent = message;
          
          if (voiceEnabled) {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(message);
            utterance.lang = 'zh-TW';
            utterance.rate = 0.9;
            window.speechSynthesis.speak(utterance);
          }
        }
      }
    }

    /**********************
     * 6) ç‹€æ…‹è®Šæ•¸å’Œåˆå§‹åŒ–
     **********************/
    let model = null;
    let isDetecting = false;
    let voiceEnabled = true;
    let currentMode = 'auto';
    let lastTick = 0;
    let frames = 0;
    let lastFpsTs = 0;
    let lastSpeechAt = 0;
    let currentEnvironment = 'auto';
    let gpsNavigator = new GPSNavigator();
    let environmentHistory = [];
    let safetyNavigator = new EnhancedSafetyCorridorNavigator();
    let pedestrianFollower = new PedestrianFollowingSystem();
    
    let lastVoiceMessage = '';
    let lastVoiceTime = 0;

    /**********************
     * 7) æ ¸å¿ƒåŠŸèƒ½å‡½æ•¸
     **********************/
    async function initModel() {
      try {
        updateVoice('æ­£åœ¨è¼‰å…¥ TensorFlow.js COCO-SSD æ¨¡å‹â€¦');
        
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        progressContainer.style.display = 'block';
        progressBar.style.width = '30%';
        
        if (typeof tf === 'undefined') {
          throw new Error('TensorFlow.js æœªæ­£ç¢ºåŠ è¼‰ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥');
        }
        
        progressBar.style.width = '60%';
        updateVoice('è¼‰å…¥ COCO-SSD æ¨¡å‹ä¸­...');
        
        if (typeof cocoSsd === 'undefined') {
          throw new Error('COCO-SSD æ¨¡å‹æœªæ­£ç¢ºåŠ è¼‰');
        }
        
        model = await cocoSsd.load();
        
        progressBar.style.width = '100%';
        progressBar.style.background = 'var(--good)';
        
        initEventListeners();
        updateVoice('COCO-SSD æ¨¡å‹è¼‰å…¥æˆåŠŸï¼ç³»çµ±æº–å‚™å®Œæˆï¼Œè«‹é»æ“Šé–‹å§‹æª¢æ¸¬');
        updateStatus('æº–å‚™å°±ç·’');
        
        setTimeout(() => {
          progressContainer.style.display = 'none';
        }, 1000);
        
      } catch (e) {
        console.error('æ¨¡å‹è¼‰å…¥éŒ¯èª¤:', e);
        
        try {
          updateVoice('å•Ÿç”¨æ¨¡æ“¬æ¨¡å¼ï¼Œç³»çµ±ä»å¯æ­£å¸¸é‹ä½œ');
          enableSimulationMode();
          updateStatus('æ¨¡æ“¬æ¨¡å¼');
        } catch (simError) {
          updateVoice('ç³»çµ±åˆå§‹åŒ–å¤±æ•—ï¼Œè«‹åˆ·æ–°é é¢é‡è©¦');
          updateStatus('åˆå§‹åŒ–å¤±æ•—');
        }
        
        setTimeout(() => {
          document.getElementById('progressContainer').style.display = 'none';
        }, 1000);
        
        const errorMsg = `éŒ¯èª¤: ${e.message}. è«‹ç¢ºèªç¶²è·¯é€£æ¥æ­£å¸¸`;
        console.error(errorMsg);
      }
    }
    
    function enableSimulationMode() {
      model = {
        detect: async function(img) {
          return [
            { class: 'person', score: 0.8, bbox: [100, 100, 50, 50] },
            { class: 'chair', score: 0.6, bbox: [200, 200, 30, 30] }
          ];
        }
      };
      
      initEventListeners();
      updateVoice('æ¨¡æ“¬æ¨¡å¼å·²å•Ÿç”¨ï¼Œç³»çµ±å¯æ­£å¸¸ä½¿ç”¨');
    }

    function initEventListeners() {
      document.getElementById('btnStart').addEventListener('click', startDetection);
      document.getElementById('btnStop').addEventListener('click', stopDetection);
      document.getElementById('btnVoice').addEventListener('click', toggleVoice);
      document.getElementById('btnMode').addEventListener('click', toggleMode);
      document.getElementById('btnSetHome').addEventListener('click', () => gpsNavigator.setHomePosition());
      document.getElementById('btnReturnHome').addEventListener('click', toggleSafetyCorridor);
      document.getElementById('btnLoadModule').addEventListener('click', loadEnvironmentModule);
      document.getElementById('btnInfrared').addEventListener('click', toggleInfrared);
      document.getElementById('btnEmergency').addEventListener('click', emergencyAlert);
      document.getElementById('btnFollow').addEventListener('click', togglePedestrianFollowing);
    }

    function togglePedestrianFollowing() {
      const button = document.getElementById('btnFollow');
      
      if (pedestrianFollower.isActive) {
        pedestrianFollower.stop();
        button.textContent = 'è¡Œäººè·Ÿéš¨æ¨¡å¼';
        button.classList.remove('follow-active');
      } else {
        pedestrianFollower.start();
        button.textContent = 'åœæ­¢è·Ÿéš¨';
        button.classList.add('follow-active');
      }
    }

    function toggleSafetyCorridor() {
      const button = document.getElementById('btnReturnHome');
      
      if (safetyNavigator.isActive) {
        safetyNavigator.stop();
        button.textContent = 'å®‰å…¨é€šé“å°èˆª';
        button.classList.remove('gps-active');
        updateVoice('å®‰å…¨é€šé“å°èˆªå·²é—œé–‰');
      } else {
        if (!gpsNavigator.homePosition) {
          updateVoice('è«‹å…ˆè¨­å®šå®¶çš„ä½ç½®');
          return;
        }
        
        safetyNavigator.start();
        button.textContent = 'åœæ­¢å°èˆª';
        button.classList.add('gps-active');
        
        gpsNavigator.startReturnHome();
      }
    }

    async function setupCamera() {
      const video = document.getElementById('video');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment', 
            width: { ideal: 640 },
            height: { ideal: 480 } 
          }, 
          audio: false 
        });
        video.srcObject = stream; 
        await new Promise((resolve) => {
          video.onloadedmetadata = () => { resolve(video); };
        }); 
        await video.play();
        return video;
      } catch (e) { 
        console.error('ç›¸æ©ŸéŒ¯èª¤:', e); 
        updateVoice('ç„¡æ³•å­˜å–ç›¸æ©Ÿï¼Œè«‹ç¢ºèªæ¬Šé™'); 
        return null; 
      }
    }

    async function startDetection() {
      if (!model) {
        updateVoice('æ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆï¼Œè«‹ç¨å€™');
        return;
      }
      
      const video = await setupCamera(); 
      if (!video) return;
      
      isDetecting = true; 
      updateStatus('æª¢æ¸¬ä¸­'); 
      updateVoice('é–‹å§‹éšœç¤™ç‰©æª¢æ¸¬ï¼Œæ™ºèƒ½ç’°å¢ƒè­˜åˆ¥å·²å•Ÿå‹•â€¦');
      
      requestAnimationFrame((ts) => loop(video, ts));
    }

    function stopDetection() {
      isDetecting = false; 
      updateStatus('å·²åœæ­¢');
      const video = document.getElementById('video');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      updateVoice('æª¢æ¸¬å·²åœæ­¢');
      gpsNavigator.stopReturnHome();
      
      if (safetyNavigator.isActive) {
        safetyNavigator.stop();
        const button = document.getElementById('btnReturnHome');
        button.textContent = 'å®‰å…¨é€šé“å°èˆª';
        button.classList.remove('gps-active');
      }
      
      if (pedestrianFollower.isActive) {
        pedestrianFollower.stop();
        const button = document.getElementById('btnFollow');
        button.textContent = 'è¡Œäººè·Ÿéš¨æ¨¡å¼';
        button.classList.remove('follow-active');
      }
    }

    async function loop(video, ts = 0) {
      if (!isDetecting) return;
      
      if (ts - lastTick >= INTERVAL) {
        try {
          const predictions = await model.detect(video);
          
          // è¡Œäººè·Ÿéš¨æ¨¡å¼å„ªå…ˆ
          if (pedestrianFollower.isActive) {
            const target = pedestrianFollower.findBestTarget(predictions, video.videoWidth, video.videoHeight);
            pedestrianFollower.provideFollowingGuidance(target, video.videoWidth, video.videoHeight);
          } else {
            // åŸæœ‰çš„ç’°å¢ƒåˆ¤æ–·é‚è¼¯
            let detectedEnvironment = currentEnvironment;
            if (currentMode === 'auto') {
              detectedEnvironment = environmentAnalyzer.analyze(predictions);
            }
            processPredictions(predictions, video.videoWidth, video.videoHeight, detectedEnvironment);
            safetyNavigator.updateSafetyCorridor(predictions, video.videoWidth, video.videoHeight);
          }
          
          draw(predictions, video.videoWidth, video.videoHeight);
          
          // ç¹ªè£½è¡Œäººè·Ÿéš¨ä¿¡æ¯
          if (pedestrianFollower.isActive) {
            const ctx = document.getElementById('canvas').getContext('2d');
            const target = pedestrianFollower.findBestTarget(predictions, video.videoWidth, video.videoHeight);
            pedestrianFollower.updateDisplay(target, ctx, video.videoWidth, video.videoHeight);
          }

          frames++; 
          if (!lastFpsTs) {
            lastFpsTs = ts;
          } else if (ts - lastFpsTs >= 1000) {
            document.getElementById('fps').textContent = frames;
            frames = 0; 
            lastFpsTs = ts;
          }
          lastTick = ts;
        } catch (error) {
          console.error('æª¢æ¸¬å¾ªç’°éŒ¯èª¤:', error);
        }
      }
      requestAnimationFrame((n) => loop(video, n));
    }

    function processPredictions(predictions, frameW, frameH, detectedEnvironment) {
      let activeModules = [];
      if (detectedEnvironment === 'auto') {
        activeModules = Object.keys(environmentModules).filter(env => env !== 'auto');
      } else {
        activeModules = [detectedEnvironment];
      }
      
      let relevantPredictions = predictions.filter(p => {
        if (p.class === 'person' && p.score < MIN_CONFIDENCE_FOR_PERSON) return false;
        if (p.score >= 0.2) return true;
        if (p.score < SCORE_THRESHOLD) return false;
        return activeModules.some(env => environmentModules[env].objects[p.class]);
      }).map(pred => {
        const distance = estimateDistance(pred.bbox[2], pred.bbox[3], pred.class);
        return {
          ...pred,
          distance: distance
        };
      });
      
      if (safetyNavigator.isActive) {
        const groundLandmarks = ['curb', 'crosswalk_line', 'pavement_edge', 'tactile_paving', 'guide_line'];
        relevantPredictions = relevantPredictions.filter(pred => !groundLandmarks.includes(pred.class));
      }
      
      const totalObstacles = relevantPredictions.length;
      document.getElementById('obstacleCount').textContent = totalObstacles;
      
      let closestDistance = Infinity;
      let closestObject = null;
      
      relevantPredictions.forEach(pred => {
        if (pred.distance < closestDistance) {
          closestDistance = pred.distance;
          closestObject = pred;
        }
      });
      
      const distanceElement = document.getElementById('closestDistance');
      if (closestObject) {
        distanceElement.textContent = closestDistance.toFixed(1) + ' å…¬å°º';
        
        if (closestDistance < 2) {
          distanceElement.parentElement.classList.add('danger-warning');
        } else if (closestDistance < 5) {
          distanceElement.parentElement.classList.add('obstacle-warning');
        } else {
          distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
        }
        
        if (voiceEnabled) {
          const now = Date.now();
          const cooldown = closestObject.distance < 3 ? 2000 : 4000;
          
          if (now - lastSpeechAt > cooldown) {
            let objConfig = null;
            for (const env of activeModules) {
              if (environmentModules[env].objects[closestObject.class]) {
                objConfig = environmentModules[env].objects[closestObject.class];
                break;
              }
            }
            
            if (objConfig) {
              let voiceMsg = objConfig.voice;
              
              if (closestObject.distance < 2) {
                voiceMsg = `ç·Šæ€¥ï¼${objConfig.name}éå¸¸æ¥è¿‘ï¼Œåƒ…${closestObject.distance.toFixed(1)}å…¬å°º`;
              } else if (closestObject.distance < 5) {
                voiceMsg = `æ³¨æ„ï¼${objConfig.name}æ¥è¿‘ï¼Œè·é›¢${closestObject.distance.toFixed(1)}å…¬å°º`;
              }
              
              if (!safetyNavigator.isActive || !['curb', 'crosswalk_line', 'pavement_edge', 'tactile_paving'].includes(closestObject.class)) {
                updateVoice(voiceMsg);
                lastSpeechAt = now;
              }
            }
          }
        }
      } else {
        distanceElement.textContent = 'â€” å…¬å°º';
        distanceElement.parentElement.classList.remove('obstacle-warning', 'danger-warning');
      }
      
      updateDetectionList(relevantPredictions, activeModules);
    }

    function estimateDistance(width, height, className) {
      const pixelArea = width * height;
      
      const referenceSizes = {
        'person': 8000,
        'car': 40000,
        'motorcycle': 15000,
        'bus': 60000,
        'truck': 80000,
        'bicycle': 12000,
        'chair': 6000,
        'couch': 20000,
        'bed': 15000,
        'dining table': 25000,
        'tv': 8000,
        'laptop': 3000,
        'mouse': 500,
        'keyboard': 1500,
        'cell phone': 1000,
        'book': 2000,
        'vase': 2000,
        'cup': 1000,
        'bottle': 1500,
        'toilet': 3000,
        'sink': 4000,
        'refrigerator': 12000,
        'oven': 8000,
        'microwave': 2000,
        'toothbrush': 300,
        'hair drier': 800,
        'toothpaste': 200,
        'remote': 600,
        'scissors': 400
      };
      
      const refSize = referenceSizes[className] || 8000;
      const distance = Math.sqrt(refSize / pixelArea) * 8;
      
      const maxDistances = {
        'person': 30,
        'car': 100,
        'chair': 20,
        'vase': 15,
        'toilet': 15,
        'cup': 10,
        'bottle': 12
      };
      
      const maxDistance = maxDistances[className] || 50;
      return Math.min(distance, maxDistance);
    }

    function updateDetectionList(predictions, activeModules) {
      const list = document.getElementById('detectionList');
      
      if (predictions.length === 0) {
        list.innerHTML = '<div class="chip" style="text-align:center; color:var(--muted);">æœªåµæ¸¬åˆ°éšœç¤™ç‰©</div>';
        return;
      }
      
      predictions.sort((a, b) => a.distance - b.distance);
      
      list.innerHTML = predictions.map(pred => {
        let objConfig = null;
        for (const env of activeModules) {
          if (environmentModules[env].objects[pred.class]) {
            objConfig = environmentModules[env].objects[pred.class];
            break;
          }
        }
        
        const dangerLevel = objConfig ? objConfig.danger : 'low';
        const dangerColors = {
          'high': 'var(--bad)',
          'medium': 'var(--warn)', 
          'low': 'var(--good)'
        };
        
        const displayName = objConfig ? objConfig.name : pred.class;
        
        return `
          <div class="chip" style="border-left: 4px solid ${dangerColors[dangerLevel]}">
            <strong>${displayName}</strong><br>
            è·é›¢: ${pred.distance.toFixed(1)}å…¬å°º | ç½®ä¿¡åº¦: ${(pred.score * 100).toFixed(0)}%
          </div>
        `;
      }).join('');
    }

    function draw(predictions, width, height) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      if (!width || !height) return;
      
      canvas.width = width;
      canvas.height = height;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // åœ¨è·Ÿéš¨æ¨¡å¼ä¸‹ï¼Œåªç¹ªè£½éè¡Œäººè·Ÿéš¨çš„ç‰©é«”
      if (!pedestrianFollower.isActive) {
        predictions.forEach(pred => {
          if (pred.score < SCORE_THRESHOLD) return;
          
          const [x, y, w, h] = pred.bbox;
          
          let objConfig = null;
          for (const env in environmentModules) {
            if (env !== 'auto' && environmentModules[env].objects[pred.class]) {
              objConfig = environmentModules[env].objects[pred.class];
              break;
            }
          }
          
          if (!objConfig) return;
          
          let color;
          switch(objConfig.danger) {
            case 'high': color = '#ef4444'; break;
            case 'medium': color = '#f59e0b'; break;
            default: color = '#22c55e';
          }
          
          ctx.strokeStyle = color;
          ctx.lineWidth = 3;
          ctx.strokeRect(x, y, w, h);
          
          const label = `${objConfig.name} ${pred.distance.toFixed(1)}m`;
          ctx.font = '16px Arial';
          const textWidth = ctx.measureText(label).width;
          
          ctx.fillStyle = color;
          ctx.fillRect(x, y - 25, textWidth + 10, 25);
          
          ctx.fillStyle = 'white';
          ctx.fillText(label, x + 5, y - 7);
        });
      }
    }

    function updateVoice(message) {
      const voiceAlert = document.getElementById('voiceAlert');
      voiceAlert.textContent = message;
      
      if (voiceEnabled && window.speechSynthesis) {
        const now = Date.now();
        
        if (message === lastVoiceMessage && now - lastVoiceTime < 5000) {
          return;
        }
        
        if (message.includes('è·¯ç·£çŸ³') && lastVoiceMessage.includes('è·¯ç·£çŸ³')) {
          if (now - lastVoiceTime < 15000) {
            return;
          }
        }
        
        if (window.speechSynthesis.speaking && now - lastVoiceTime < 3000) {
          return;
        }
        
        window.speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'zh-TW';
        utterance.rate = 0.8;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        lastVoiceMessage = message;
        lastVoiceTime = now;
        
        window.speechSynthesis.speak(utterance);
      }
    }

    function updateStatus(status) {
      document.getElementById('status').textContent = status;
    }

    function updateGPSStatus(status) {
      document.getElementById('gpsStatus').textContent = status;
    }

    function updateFollowStatus(status) {
      document.getElementById('followStatus').textContent = status;
    }

    function toggleVoice() {
      voiceEnabled = !voiceEnabled;
      const status = document.getElementById('voiceStatus');
      const button = document.getElementById('btnVoice');
      
      if (voiceEnabled) {
        status.textContent = 'é–‹å•Ÿ';
        button.textContent = 'èªéŸ³é—œé–‰';
        button.classList.remove('warning');
        button.classList.add('secondary');
        updateVoice('èªéŸ³æç¤ºå·²é–‹å•Ÿ');
      } else {
        status.textContent = 'é—œé–‰';
        button.textContent = 'èªéŸ³é–‹å•Ÿ';
        button.classList.remove('secondary');
        button.classList.add('warning');
        window.speechSynthesis.cancel();
      }
    }

    function toggleMode() {
      const button = document.getElementById('btnMode');
      currentMode = currentMode === 'auto' ? 'manual' : 'auto';
      
      if (currentMode === 'auto') {
        button.textContent = 'æ™ºèƒ½æ¨¡å¼';
        updateVoice('åˆ‡æ›åˆ°æ™ºèƒ½æ¨¡å¼ï¼Œè‡ªå‹•åˆ¤æ–·ç’°å¢ƒ');
        environmentHistory = [];
        currentEnvironment = 'auto';
      } else {
        button.textContent = 'è‡ªå‹•æ¨¡å¼';
        updateVoice('åˆ‡æ›åˆ°æ‰‹å‹•æ¨¡å¼ï¼Œè«‹ä½¿ç”¨æ‰‹å‹•åˆ‡æ›ç’°å¢ƒæŒ‰éˆ•é¸æ“‡ç’°å¢ƒ');
        currentEnvironment = 'outdoor';
      }
    }

    function loadEnvironmentModule() {
      if (currentMode !== 'manual') {
        updateVoice('è«‹å…ˆåˆ‡æ›åˆ°æ‰‹å‹•æ¨¡å¼æ‰èƒ½é¸æ“‡ç’°å¢ƒ');
        return;
      }
      
      const environments = Object.keys(environmentModules).filter(env => env !== 'auto');
      const currentIndex = environments.indexOf(currentEnvironment);
      const nextIndex = (currentIndex + 1) % environments.length;
      currentEnvironment = environments[nextIndex];
      
      const module = environmentModules[currentEnvironment];
      document.getElementById('currentModule').textContent = module.name;
      document.getElementById('activeModuleTag').textContent = module.name;
      
      updateVoice(`å·²åˆ‡æ›åˆ°${module.name}æ¨¡å¼`);
    }

    function toggleInfrared() {
      const button = document.getElementById('btnInfrared');
      const display = document.getElementById('infraredDisplay');
      
      if (display.style.display === 'block') {
        display.style.display = 'none';
        button.textContent = 'ç´…å¤–ç·šæ¸¬è·';
        button.classList.remove('primary');
        button.classList.add('secondary');
        updateVoice('ç´…å¤–ç·šæ¸¬è·å·²é—œé–‰');
      } else {
        display.style.display = 'block';
        button.textContent = 'é—œé–‰æ¸¬è·';
        button.classList.remove('secondary');
        button.classList.add('primary');
        updateVoice('ç´…å¤–ç·šæ¸¬è·å·²å•Ÿå‹•');
      }
    }

    function emergencyAlert() {
      const button = document.getElementById('btnEmergency');
      button.classList.add('emergency-alert');
      
      updateVoice('ç·Šæ€¥æ±‚åŠ©ï¼æ­£åœ¨ç™¼é€ä½ç½®è³‡è¨Šçµ¦ç·Šæ€¥è¯çµ¡äºº');
      
      if (gpsNavigator.currentPosition) {
        const { lat, lng } = gpsNavigator.currentPosition;
        console.log(`ç·Šæ€¥ä½ç½®ç™¼é€: ç·¯åº¦ ${lat.toFixed(6)}, ç¶“åº¦ ${lng.toFixed(6)}`);
      }
      
      setTimeout(() => {
        button.classList.remove('emergency-alert');
      }, 5000);
    }

    /**********************
     * 8) ç’°å¢ƒåˆ†æå™¨ï¼ˆå®Œæ•´ç‰ˆï¼‰
     **********************/
    class EnvironmentAnalyzer {
      constructor() {
        this.lastEnvironment = 'auto';
        this.confidenceThreshold = 2;
        this.environmentScores = {};
        this.keyItemsDetected = {};
        this.lastSwitchTime = 0;
        this.switchCooldown = 3000;
        
        Object.keys(environmentModules).forEach(env => {
          if (env !== 'auto') {
            this.environmentScores[env] = 0;
            this.keyItemsDetected[env] = new Set();
          }
        });
      }

      analyze(predictions) {
        const now = Date.now();
        
        if (now - this.lastSwitchTime < this.switchCooldown) {
          return this.lastEnvironment;
        }

        Object.keys(this.environmentScores).forEach(env => {
          this.environmentScores[env] = 0;
        });

        const keyItems = {
          'bedroom': ['bed', 'dresser', 'mirror', 'lamp', 'toilet'],
          'kitchen': ['oven', 'microwave', 'refrigerator', 'sink', 'knife'],
          'bathroom': ['toilet', 'sink', 'mirror', 'shower', 'bathtub', 'vase'],
          'hospital': ['bed', 'wheelchair', 'crutches', 'medical equipment'],
          'supermarket': ['shopping cart', 'shelf', 'refrigerator', 'cash register'],
          'office': ['desk', 'chair', 'laptop', 'printer', 'monitor', 'toilet', 'vase'],
          'outdoor': ['car', 'bus', 'traffic light', 'stop sign', 'tree'],
          'indoor': ['chair', 'couch', 'tv', 'table', 'lamp', 'toilet', 'vase']
        };

        predictions.forEach(pred => {
          if (pred.score < SCORE_THRESHOLD) return;
          
          Object.keys(environmentModules).forEach(env => {
            if (env === 'auto') return;
            
            if (environmentModules[env].objects[pred.class]) {
              let score = pred.score * 4;
              
              if (keyItems[env] && keyItems[env].includes(pred.class)) {
                score *= 2;
                this.keyItemsDetected[env].add(pred.class);
              }
              
              this.environmentScores[env] += score;
            }
          });
        });

        environmentHistory.push({ ...this.environmentScores });
        if (environmentHistory.length > 8) {
          environmentHistory.shift();
        }

        const avgScores = {};
        Object.keys(this.environmentScores).forEach(env => {
          avgScores[env] = environmentHistory.reduce((sum, item) => sum + item[env], 0) / environmentHistory.length;
        });

        let detectedEnvironment = 'auto';
        let maxScore = 0;
        
        Object.keys(avgScores).forEach(env => {
          if (avgScores[env] > maxScore) {
            maxScore = avgScores[env];
            detectedEnvironment = env;
          }
        });

        const hasKeyItems = Object.keys(this.keyItemsDetected).some(env => 
          this.keyItemsDetected[env].size >= 1
        );

        if (maxScore > this.confidenceThreshold && hasKeyItems && 
            detectedEnvironment !== this.lastEnvironment) {
          this.lastEnvironment = detectedEnvironment;
          this.lastSwitchTime = now;
          updateEnvironmentDisplay(detectedEnvironment);
          
          Object.keys(this.keyItemsDetected).forEach(env => {
            this.keyItemsDetected[env].clear();
          });
        }

        return this.lastEnvironment;
      }
    }

    const environmentAnalyzer = new EnvironmentAnalyzer();

    function updateEnvironmentDisplay(environment) {
      const moduleElement = document.getElementById('currentModule');
      const tagElement = document.getElementById('activeModuleTag');
      
      let displayName = 'è‡ªå‹•';
      let indicatorClass = 'auto-indicator';
      
      if (environment !== 'auto' && environmentModules[environment]) {
        displayName = environmentModules[environment].name;
        
        if (environment === 'outdoor') {
          indicatorClass = 'outdoor-indicator';
        } else if (['bedroom', 'kitchen', 'bathroom', 'office', 'indoor'].includes(environment)) {
          indicatorClass = 'indoor-indicator';
        } else {
          indicatorClass = 'auto-indicator';
        }
      }
      
      moduleElement.innerHTML = `<span class="environment-indicator ${indicatorClass}"></span>${displayName}`;
      tagElement.textContent = displayName;
      
      if (environment !== 'auto') {
        updateVoice(`æª¢æ¸¬åˆ°${displayName}ç’°å¢ƒï¼Œå·²è‡ªå‹•åˆ‡æ›æ¨¡å¼`);
      }
    }

    /**********************
     * 9) åˆå§‹åŒ–æ‡‰ç”¨
     **********************/
    window.addEventListener('DOMContentLoaded', () => {
      updateStatus('åˆå§‹åŒ–ä¸­');
      updateVoice('ç›²äººè¼”åŠ©å°èˆªç³»çµ±å•Ÿå‹•ä¸­...');
      
      initModel();
    });

    let wakeLock = null;
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
        }
      } catch (err) {
        console.log('Wake Lock å¤±æ•—:', err.message);
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && isDetecting) {
        await requestWakeLock();
      }
    });

    requestWakeLock();
  </script>
</body>
</html>