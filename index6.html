<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>ç¾…ä¹™ç¨‹å¯¶è²å°ˆç”¨ - ç¥å¥‡å¯¶è²è‹±æ–‡å­¸ç¿’</title>
  <style>
    /* CSS æ¨£å¼è«‹ä¿ç•™æ‚¨ index6.html çš„å…§å®¹ */
    :root {
      --pokemon-yellow: #ffcc00;
      --pokemon-blue: #3b4cca;
      --pokemon-red: #ff0000;
      --pokemon-light-blue: #6aa9ff;
    }
    
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Microsoft JhengHei', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
      text-align: center;
      background: linear-gradient(135deg, var(--pokemon-yellow), #ff9900);
      margin: 0;
      padding: 0;
      color: #333;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    .container {
      width: 100%;
      margin: 0 auto;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-bottom: 8px solid var(--pokemon-blue);
      position: relative;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 10px;
      background: var(--pokemon-red);
      z-index: 1;
    }
    
    h1 {
      color: var(--pokemon-blue);
      font-size: 1.8rem;
      margin: 10px 0 5px;
      text-shadow: 1px 1px 0 #fff, 2px 2px 0 rgba(0,0,0,0.1);
      position: relative;
      display: inline-block;
      padding: 0 15px;
    }
    
    h1::after {
      content: "";
      position: absolute;
      bottom: -5px;
      left: 10%;
      width: 80%;
      height: 3px;
      background: var(--pokemon-red);
      border-radius: 2px;
    }
    
    .subtitle {
      font-size: 0.9rem;
      color: #555;
      margin-bottom: 15px;
    }
    
    .video-container {
      position: relative;
      width: 100%;
      margin: 0 auto 15px;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    
    #video {
      width: 100%;
      height: 50vh;
      max-height: 400px;
      background: #000;
      object-fit: cover;
      transform: scaleX(1);
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .word-display {
      margin: 10px 0;
      padding: 15px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      min-height: 80px;
      font-size: 1.8rem;
      color: var(--pokemon-blue);
      border: 3px solid var(--pokemon-yellow);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    
    .word-display .zh {
      font-size: 1.2rem;
      color: #666;
      margin-top: 5px;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
      margin: 10px 0;
    }
    
    button {
      padding: 12px 15px;
      font-size: 1rem;
      background: var(--pokemon-blue);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: bold;
      box-shadow: 0 3px 0 rgba(0,0,0,0.2);
      flex: 1;
      min-width: 120px;
      max-width: 160px;
    }
    
    button:active {
      transform: translateY(2px);
      box-shadow: 0 1px 0 rgba(0,0,0,0.2);
    }
    
    button.active {
      background: var(--pokemon-red);
    }
    
    .mode-selector {
      display: flex;
      justify-content: center;
      margin: 10px 0;
      gap: 10px;
    }
    
    .mode-btn {
      background: var(--pokemon-light-blue);
      flex: 1;
      max-width: 160px;
    }
    
    .mode-btn.active {
      background: var(--pokemon-red);
    }
    
    .game-mode {
      background: #fff8e1;
      padding: 12px;
      border-radius: 12px;
      margin: 10px 0;
      font-size: 1rem;
      color: #e65100;
      border: 2px dashed var(--pokemon-red);
      display: none;
    }
    
    .vocab-section {
      margin-top: 15px;
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    
    .vocab-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .vocab-header h2 {
      color: var(--pokemon-blue);
      background: var(--pokemon-yellow);
      padding: 6px 15px;
      border-radius: 20px;
      margin: 0;
      border: 2px solid var(--pokemon-blue);
      font-size: 1.2rem;
    }
    
    .vocab-list {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      padding: 10px;
      flex: 1;
      overflow-y: auto;
      text-align: left;
      border: 2px solid var(--pokemon-light-blue);
      max-height: 30vh;
    }
    
    .vocab-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      font-size: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .vocab-item strong {
      color: var(--pokemon-red);
    }
    
    .remove-btn {
      background: transparent;
      color: #ff4444;
      box-shadow: none;
      padding: 5px;
      min-width: auto;
      max-width: 40px;
      font-size: 0.9rem;
    }
    
    .clear-btn {
      background: #ff6b6b;
      padding: 6px 12px;
      font-size: 0.9rem;
      min-width: auto;
    }
    
    .pikachu-corner {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 60px;
      height: 60px;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M50,10 C70,10 85,25 85,45 C85,65 70,80 50,80 C30,80 15,65 15,45 C15,25 30,10 50,10 Z" fill="%23FFCC00" stroke="%233B4CCA" stroke-width="2"/><circle cx="40" cy="35" r="5" fill="%23333"/><circle cx="60" cy="35" r="5" fill="%23333"/><path d="M45,55 Q50,60 55,55" stroke="%23333" stroke-width="2" fill="none"/><path d="M30,20 L25,15 M70,20 L75,15" stroke="%23333" stroke-width="2"/></svg>');
      background-repeat: no-repeat;
      opacity: 0.7;
      z-index: 10;
    }
    
    .pokeball {
      display: inline-block;
      width: 20px;
      height: 20px;
      background: linear-gradient(to bottom, var(--pokemon-red) 0%, var(--pokemon-red) 45%, #000 45%, #000 50%, white 50%, white 55%, #000 55%, #000 100%);
      border-radius: 50%;
      border: 1px solid #000;
      margin: 0 3px;
      vertical-align: middle;
    }
    
    .empty-vocab {
      text-align: center;
      color: #888;
      padding: 20px;
      font-style: italic;
    }
    
    .status-info {
      font-size: 0.8rem;
      color: #666;
      margin: 5px 0;
    }
    
    /* ç§»é™¤ ocr-focus-area çš„æ¨£å¼ï¼Œå› ç‚ºæˆ‘å€‘æ”¹ç”¨ Canvas ç¹ªè£½ */
    /*
    .ocr-focus-area {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 250px; 
      height: 100px;
      border: 3px solid #00ff00;
      background: rgba(0, 255, 0, 0.1);
      pointer-events: none;
      display: none;
    }
    */
    
    @media (max-height: 700px) {
      #video {
        height: 40vh;
      }
      
      .vocab-list {
        max-height: 25vh;
      }
    }
    
    @media (max-height: 600px) {
      #video {
        height: 35vh;
      }
      
      .vocab-list {
        max-height: 20vh;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1><span class="pokeball"></span> ç¾…ä¹™ç¨‹å¯¶è²è‹±æ–‡å­¸ç¿’ <span class="pokeball"></span></h1>
    <div class="subtitle">å°æº–ç‰©å“æˆ–å­—æ¯é–‹å§‹å­¸ç¿’</div>
    
    <div class="mode-selector">
      <button id="objectModeBtn" class="mode-btn active">ğŸ” ç‰©å“è¾¨è­˜</button>
      <button id="ocrModeBtn" class="mode-btn">ğŸ”¤ å­—æ¯è¾¨è­˜</button>
    </div>

    <div id="gameMode" class="game-mode">
      æ‰¾åˆ° â†’ <strong id="targetWord"></strong>
    </div>

    <div class="video-container">
      <video id="video" autoplay muted playsinline></video>
      <canvas id="canvas"></canvas>
      </div>

    <div class="word-display" id="wordDisplay">
      è¼‰å…¥ AI æ¨¡å‹ä¸­...
    </div>
    
    <div class="status-info" id="statusInfo">
      è«‹é»æ“Šç•«é¢é–‹å§‹è¼‰å…¥æ¨¡å‹
    </div>

    <div class="controls">
      <button id="langBtnEn" class="active">ğŸ”Š è‹±æ–‡</button>
      <button id="langBtnZh">ğŸ”Š ä¸­æ–‡</button>
      <button id="gameBtn">ğŸ® éŠæˆ²æ¨¡å¼</button>
    </div>

    <div class="vocab-section">
      <div class="vocab-header">
        <h2>ğŸ“š æˆ‘çš„å–®å­—æœ¬</h2>
        <button id="clearVocab" class="clear-btn">æ¸…é™¤</button>
      </div>
      <div class="vocab-list" id="vocabList">
        <div class="empty-vocab">é‚„æ²’æœ‰æ”¶è—å–®å­—</div>
      </div>
    </div>
    
    <div class="pikachu-corner"></div>
  </div>

  <script src="itemDatabase.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <script src="https://unpkg.com/tesseract.js@v2.1.0/dist/tesseract.min.js"></script>

  <script>
    // --- YOLOv8 å°ˆç”¨è¨­å®š ---
    const MODEL_INPUT_SIZE = 640;
    // **å„ªåŒ–é» 1: æé«˜ä¿¡å¿ƒåº¦é–€æª» (å¾ 0.6 æé«˜åˆ° 0.75ï¼Œéæ¿¾ä½å“è³ªè¾¨è­˜)**
    const CONF_THRESHOLD = 0.75; 
    const IOU_THRESHOLD = 0.45; // NMS IOU é–€æª»
    // æ¨™æº– COCO 80 é¡åˆ¥
    const CLASS_NAMES = [
        'person', 'bicycle', 'car', 'motorbike', 'aeroplane', 'bus', 'train', 'truck', 'boat', 
        'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 
        'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 
        'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 
        'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 
        'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 
        'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 
        'sofa', 'pottedplant', 'bed', 'diningtable', 'toilet', 'tvmonitor', 'laptop', 'mouse', 
        'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 
        'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    // åˆå§‹åŒ–è®Šæ•¸
    let yoloDetector; 
    let isEnglish = true;
    let isInGameMode = false;
    let isOCRMode = false;
    let currentTarget = '';
    let collectedWords = JSON.parse(localStorage.getItem('collectedWords')) || [];
    let lastSpokenWord = '';
    let isSpeaking = false;
    let detectionFrameCount = 0;
    let lastSpokenTime = 0;
    let ocrWorker = null;

    // DOM å…ƒç´ 
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const wordDisplay = document.getElementById('wordDisplay');
    const vocabList = document.getElementById('vocabList');
    const gameMode = document.getElementById('gameMode');
    const targetWord = document.getElementById('targetWord');
    const langBtnEn = document.getElementById('langBtnEn');
    const langBtnZh = document.getElementById('langBtnZh');
    const gameBtn = document.getElementById('gameBtn');
    const clearVocab = document.getElementById('clearVocab');
    const objectModeBtn = document.getElementById('objectModeBtn');
    const ocrModeBtn = document.getElementById('ocrModeBtn');
    const statusInfo = document.getElementById('statusInfo');
    // const ocrFocusArea = document.getElementById('ocrFocusArea'); // ç§»é™¤æ­¤ DOM å¼•ç”¨

    
    // æ“´å±•çš„ COCO-SSD èˆ‡è³‡æ–™åº« key å°æ‡‰è¡¨
    const cocoToYourKey = {
        'cell phone': 'smartphone',
        'hair drier': 'hair dryer',
        'tvmonitor': 'television', 
        'remote': 'remote control',
        'mouse': 'computer mouse',
        'keyboard': 'computer keyboard',
        'laptop': 'notebook computer',
        'sports ball': 'ball',
        'baseball bat': 'bat',
        'baseball glove': 'glove',
        'tennis racket': 'racket',
        'wine glass': 'glass',
        'hot dog': 'hotdog',
        'pottedplant': 'plant', 
        'diningtable': 'table', 
        'parking meter': 'meter',
        'stop sign': 'sign',
        'fire hydrant': 'hydrant',
        'traffic light': 'trafficlight'
    };


    // --- Class: YOLOv8Detector ---
    class YOLOv8Detector {
      constructor(modelPath = 'yolov8n.onnx') {
        this.modelPath = modelPath;
        this.session = null;
        this.isReady = false;
      }

      async loadModel() {
        statusInfo.textContent = 'è¼‰å…¥ AI æ¨¡å‹ä¸­...';
        wordDisplay.textContent = `æ­£åœ¨å¾ ${this.modelPath} è¼‰å…¥æ¨¡å‹...`;

        try {
          if (typeof ort === 'undefined' || !ort.InferenceSession) {
            throw new Error("ONNX Runtime Web å‡½å¼åº«æœªè¼‰å…¥ã€‚");
          }

          this.session = await ort.InferenceSession.create(this.modelPath, {
            executionProviders: ['webgl', 'wasm'], 
            graphOptimizationLevel: 'all',
            logLevel: 'error' 
          });

          this.isReady = true;
          statusInfo.textContent = 'AI è¦–è¦ºæº–å‚™å°±ç·’';
          wordDisplay.textContent = 'æ¨¡å‹è¼‰å…¥å®Œæˆï¼å°æº–ç‰©å“é–‹å§‹å­¸ç¿’';
          return true;
        } catch (error) {
          console.error('YOLOv8 æ¨¡å‹è¼‰å…¥å¤±æ•— (è©³ç´°):', error);
          const errorMessage = `æ¨¡å‹è¼‰å…¥å¤±æ•—ã€‚è«‹æª¢æŸ¥: 1. è·¯å¾‘ ${this.modelPath} 2. WebGL/WASM éŒ¯èª¤ã€‚éŒ¯èª¤: ${error.message.substring(0, 80)}...`;
          statusInfo.textContent = 'è¼‰å…¥å¤±æ•—';
          wordDisplay.textContent = errorMessage; 
          return false;
        }
      }

      async detect(video) {
        if (!this.isReady) return [];

        const width = video.videoWidth;
        const height = video.videoHeight;
        
        // --- 1. å½±åƒé è™•ç†ï¼šTF.js Tensor è½‰æ› (HWC -> NCHW, æ­¸ä¸€åŒ–) ---
        const inputTensor = tf.tidy(() => {
          let tensor = tf.browser.fromPixels(video); 
          tensor = tf.image.resizeBilinear(tensor, [MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
          tensor = tensor.div(255.0); 
          tensor = tensor.transpose([2, 0, 1]); // HWC -> CHW
          tensor = tensor.expandDims(0); // CHW -> NCHW
          return tensor;
        });

        const input = new ort.Tensor('float32', inputTensor.dataSync(), [1, 3, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
        inputTensor.dispose(); // é‡‹æ”¾ tfjs å…§å­˜

        // --- 2. åŸ·è¡Œ ONNX æ¨ç† ---
        const feeds = { 'images': input }; // 'images' æ˜¯ YOLOv8 ONNX æ¨¡å‹çš„æ¨™æº–è¼¸å…¥åç¨±
        const output = await this.session.run(feeds);
        
        // YOLOv8n çš„è¼¸å‡ºå¼µé‡åç¨±é€šå¸¸æ˜¯ 'output0'
        const predictions = this._processOutput(
            output['output0'], width, height, CONF_THRESHOLD, IOU_THRESHOLD
        );
        
        return predictions;
      }
      
      // --- 3. YOLOv8 NMS å¾Œè™•ç† ---
      _processOutput(outputTensor, originalWidth, originalHeight, confThreshold, iouThreshold) {
        const output = outputTensor.data;
        const numClasses = CLASS_NAMES.length; // 80
        const rows = outputTensor.dims[2]; // 8400
        const valuesPerRow = outputTensor.dims[1]; // 84 (4+80)

        let boxes = []; // å„²å­˜ [x1, y1, x2, y2, score, classId]

        for (let i = 0; i < rows; i++) {
          const rowStart = i * valuesPerRow;
          const scoreStart = rowStart + 4; // é¡åˆ¥åˆ†æ•¸å¾ç¬¬ 5 å€‹å€¼é–‹å§‹ (0-based: index 4)

          // æ‰¾å‡ºæœ€é«˜åˆ†æ•¸çš„é¡åˆ¥
          let maxScore = 0;
          let classId = -1;
          for (let c = 0; c < numClasses; c++) {
            const score = output[scoreStart + c];
            if (score > maxScore) {
              maxScore = score;
              classId = c;
            }
          }

          if (maxScore > confThreshold) {
            // è§£æ Bounding Box (cx, cy, w, h)
            const cx = output[rowStart + 0];
            const cy = output[rowStart + 1];
            const w = output[rowStart + 2];
            const h = output[rowStart + 3];

            // è½‰æ›åˆ° (x1, y1, x2, y2)
            const x1 = cx - w / 2;
            const y1 = cy - h / 2;
            const x2 = cx + w / 2;
            const y2 = cy + h / 2;

            boxes.push([x1, y1, x2, y2, maxScore, classId]);
          }
        }
        
        // åŸ·è¡Œ NMS (éæœ€å¤§æŠ‘åˆ¶)
        const NMS_IDX = 4; // score index
        if (boxes.length === 0) return [];

        const boxesTensor = tf.tensor2d(boxes, [boxes.length, 6]);
        const scores = boxesTensor.slice([0, NMS_IDX], [-1, 1]).squeeze();
        const boxCoords = boxesTensor.slice([0, 0], [-1, 4]);

        const indices = tf.image.nonMaxSuppression(
          boxCoords, 
          scores, 
          100, // max detections
          iouThreshold,
          confThreshold
        );

        const selectedBoxesData = boxesTensor.gather(indices).arraySync();
        boxesTensor.dispose();
        scores.dispose();
        boxCoords.dispose();
        indices.dispose();
        
        const finalDetections = selectedBoxesData.map(box => {
            // è½‰æ›å›åŸå§‹å½±ç‰‡è§£æåº¦
            const xRatio = originalWidth / MODEL_INPUT_SIZE;
            const yRatio = originalHeight / MODEL_INPUT_SIZE;
            
            const x1 = Math.max(0, box[0] * xRatio);
            const y1 = Math.max(0, box[1] * yRatio);
            const x2 = Math.min(originalWidth, box[2] * xRatio);
            const y2 = Math.min(originalHeight, box[3] * yRatio);
            
            return {
                class: CLASS_NAMES[box[5]],
                score: box[4],
                bbox: [x1, y1, x2 - x1, y2 - y1] // è½‰æ›ç‚º [x, y, w, h] æ ¼å¼
            };
        });

        return finalDetections;
      }
    }


    // å¾ itemDatabase æŸ¥è©¢å–®å­—è³‡è¨Š
    function getWordInfo(label) {
      const key = cocoToYourKey[label] || label;
      const zh = itemNames[key] || label;
      const en = key.charAt(0).toUpperCase() + key.slice(1);
      return { en, zh, key };
    }

    // iOS å…¼å®¹çš„èªéŸ³æœ—è®€åŠŸèƒ½
    function speak(text, lang = 'en-US') {
      if (isSpeaking) return;
      
      const now = Date.now();
      if (now - lastSpokenTime < (text === lastSpokenWord ? 3000 : 1000)) {
        return;
      }
      
      lastSpokenWord = text;
      lastSpokenTime = now;
      isSpeaking = true;
      
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = lang;
      utter.rate = 0.8;
      utter.pitch = 1.1;
      utter.volume = 1.0;
      
      if (speechSynthesis.speaking) {
        speechSynthesis.cancel();
      }
      
      utter.onend = () => {
        isSpeaking = false;
      };
      
      utter.onerror = () => {
        isSpeaking = false;
      };
      
      setTimeout(() => {
        speechSynthesis.speak(utter);
      }, 100);
    }

    // èªè¨€åˆ‡æ›
    langBtnEn.addEventListener('click', () => {
      isEnglish = true;
      langBtnEn.classList.add('active');
      langBtnZh.classList.remove('active');
      speak('English mode', 'en-US');
    });
    
    langBtnZh.addEventListener('click', () => {
      isEnglish = false;
      langBtnZh.classList.add('active');
      langBtnEn.classList.remove('active');
      speak('ä¸­æ–‡æ¨¡å¼', 'zh-TW');
    });

    // æ¨¡å¼åˆ‡æ›
    objectModeBtn.addEventListener('click', () => {
      isOCRMode = false;
      objectModeBtn.classList.add('active');
      ocrModeBtn.classList.remove('active');
      wordDisplay.textContent = 'ç‰©å“è¾¨è­˜æ¨¡å¼ - å°æº–ç‰©å“é–‹å§‹å­¸ç¿’';
      ctx.clearRect(0, 0, canvas.width, canvas.height); // æ¸…é™¤ OCR æ¨¡å¼ç•™ä¸‹çš„æ¡†
      speak('ç‰©å“è¾¨è­˜æ¨¡å¼', 'zh-TW');
    });
    
    ocrModeBtn.addEventListener('click', () => {
      isOCRMode = true;
      ocrModeBtn.classList.add('active');
      objectModeBtn.classList.remove('active');
      wordDisplay.textContent = 'å­—æ¯è¾¨è­˜æ¨¡å¼ - å°æº–è‹±æ–‡å­—æ¯é–‹å§‹å­¸ç¿’';
      // ocrFocusArea.style.display = 'block'; // ç§»é™¤éœæ…‹æ¡†é¡¯ç¤º
      speak('å­—æ¯è¾¨è­˜æ¨¡å¼', 'zh-TW');
    });

    // éŠæˆ²æ¨¡å¼
    gameBtn.addEventListener('click', () => {
      if (isOCRMode) {
        alert('éŠæˆ²æ¨¡å¼ç›®å‰åƒ…æ”¯æ´ç‰©å“è¾¨è­˜æ¨¡å¼');
        return;
      }
      
      isInGameMode = !isInGameMode;
      if (isInGameMode) {
        gameBtn.textContent = 'é€€å‡ºéŠæˆ²';
        gameMode.style.display = 'block';
        startNewGame();
      } else {
        gameBtn.textContent = 'ğŸ® éŠæˆ²æ¨¡å¼';
        gameMode.style.display = 'none';
      }
    });

    function startNewGame() {
      const allKeys = Object.keys(itemNames);
      const candidates = allKeys.filter(k => itemNames[k] && k !== 'background');
      const randomKey = candidates[Math.floor(Math.random() * candidates.length)];
      const zh = itemNames[randomKey];
      currentTarget = randomKey;

      targetWord.textContent = zh;
      speak(`è«‹æ‰¾åˆ° ${zh}`, 'zh-TW');
    }

    // å–®å­—æœ¬åŠŸèƒ½
    function addToVocab(en, zh, key) {
      if (!collectedWords.some(w => w.key === key)) {
        collectedWords.push({ en, zh, key });
        localStorage.setItem('collectedWords', JSON.stringify(collectedWords));
        renderVocabList();
      }
    }

    function renderVocabList() {
      if (collectedWords.length === 0) {
        vocabList.innerHTML = '<div class="empty-vocab">é‚„æ²’æœ‰æ”¶è—å–®å­—</div>';
        return;
      }
      
      vocabList.innerHTML = collectedWords.map(w => 
        `<div class="vocab-item">
          <div><strong>${w.en}</strong> - ${w.zh}</div>
          <button class="remove-btn" onclick="removeWord('${w.key}')">âŒ</button>
        </div>`
      ).join('');
    }

    function removeWord(key) {
      collectedWords = collectedWords.filter(w => w.key === key);
      localStorage.setItem('collectedWords', JSON.stringify(collectedWords));
      renderVocabList();
    }

    window.removeWord = removeWord;

    clearVocab.addEventListener('click', () => {
      if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰å–®å­—å—ï¼Ÿ')) {
        collectedWords = [];
        localStorage.removeItem('collectedWords');
        renderVocabList();
      }
    });

    // --- OCR åŠŸèƒ½ - å„ªåŒ–ç‰ˆ ---
    let lastOCRText = '';
    let ocrCooldown = 0;
    const OCR_FOCUS_WIDTH = 250;
    const OCR_FOCUS_HEIGHT = 100;

    async function performOCR() {
      if (ocrCooldown > 0) {
        ocrCooldown--;
        return;
      }

      // æ¸…é™¤ä¸Šä¸€å¹€çš„ç¹ªåœ–
      ctx.clearRect(0, 0, canvas.width, canvas.height); 

      const centerX = (canvas.width - OCR_FOCUS_WIDTH) / 2;
      const centerY = (canvas.height - OCR_FOCUS_HEIGHT) / 2;

      // **å„ªåŒ–é» 2: ç¹ªè£½å”¯ä¸€çš„é–å®šæ¡† (Canvas æ¡†)**
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 3;
      ctx.strokeRect(centerX, centerY, OCR_FOCUS_WIDTH, OCR_FOCUS_HEIGHT);
      ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
      ctx.fillRect(centerX, centerY, OCR_FOCUS_WIDTH, OCR_FOCUS_HEIGHT);


      try {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = OCR_FOCUS_WIDTH;
        tempCanvas.height = OCR_FOCUS_HEIGHT;
        
        tempCtx.drawImage(
          video, 
          centerX, centerY, OCR_FOCUS_WIDTH, OCR_FOCUS_HEIGHT,
          0, 0, OCR_FOCUS_WIDTH, OCR_FOCUS_HEIGHT
        );

        if (!ocrWorker) {
          ocrWorker = Tesseract.createWorker();
          await ocrWorker.load();
          await ocrWorker.loadLanguage('eng');
          await ocrWorker.initialize('eng');
          await ocrWorker.setParameters({
            tessedit_pageseg_mode: '6' 
          });
        }

        const { data: { text } } = await ocrWorker.recognize(tempCanvas);
        
        // æ¸…ç†æ–‡å­—ï¼šåªä¿ç•™å¤§å¯«è‹±æ–‡å­—æ¯ï¼Œä¸¦ç§»é™¤ç©ºæ ¼
        const words = text.toUpperCase().match(/[A-Z]+/g); 
        
        if (words && words.length > 0) {
          const recognizedWord = words[0]; 
          
          if (recognizedWord !== lastOCRText) {
            lastOCRText = recognizedWord;
            wordDisplay.innerHTML = `<strong>${recognizedWord}</strong>`;
            
            if (isEnglish) {
              speak(recognizedWord, 'en-US');
            }
            
            // åœ¨é–å®šæ¡†ä¸Šæ–¹é¡¯ç¤ºè¾¨è­˜çµæœ
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px Arial';
            ctx.fillText(`è¾¨è­˜: ${recognizedWord}`, centerX + 10, centerY - 10);
            
            ocrCooldown = 15;
          }
        } else if (lastOCRText !== '') {
          // æœªè­˜åˆ¥åˆ°æ–‡å­—æ™‚ï¼Œä¿æŒé–å®šæ¡†ï¼Œä½†æ¸…é™¤è¾¨è­˜æ–‡å­—
          lastOCRText = '';
          wordDisplay.innerHTML = 'å°æº–è‹±æ–‡å­—æ¯æˆ–å–®å­—é–‹å§‹å­¸ç¿’';
        }
        
        statusInfo.textContent = `OCR: ${words ? words.join(' ') : 'æœªè­˜åˆ¥åˆ°å–®å­—'}`;
      } catch (error) {
        console.error('OCR éŒ¯èª¤:', error);
        statusInfo.textContent = 'OCRéŒ¯èª¤';
      }
    }


    // æ”å½±æ©Ÿèˆ‡åµæ¸¬åŠŸèƒ½
    async function setupCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 640 }, 
            height: { ideal: 480 } 
          } 
        });
        video.srcObject = stream;
        
        video.onloadedmetadata = () => {
          video.play();
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          detectFrame();
        };
      } catch (error) {
        console.error('ç„¡æ³•å­˜å–æ”å½±æ©Ÿ:', error);
        wordDisplay.textContent = 'ç„¡æ³•å­˜å–æ”å½±æ©Ÿï¼Œè«‹ç¢ºèªæ¬Šé™è¨­å®š';
      }
    }

    let lastLabel = '';
    let lastDetectionTime = 0;
    const DETECTION_INTERVAL = 500; // æª¢æ¸¬é–“éš” 500ms
    let objectCooldown = 0;

    // --- æ ¸å¿ƒåµæ¸¬è¿´åœˆï¼šæ”¹ç”¨ YOLOv8Detector ---
    async function detectFrame() {
      const now = Date.now();
      
      // OCR æ¨¡å¼
      if (isOCRMode) {
        if (now - lastDetectionTime > 1000) { 
          lastDetectionTime = now;
          await performOCR();
        }
        requestAnimationFrame(detectFrame);
        return;
      }
      
      // ç‰©å“è¾¨è­˜æ¨¡å¼ (YOLOv8)
      if (objectCooldown > 0) {
        objectCooldown--;
        requestAnimationFrame(detectFrame);
        return;
      }
      
      if (now - lastDetectionTime < DETECTION_INTERVAL) {
        requestAnimationFrame(detectFrame);
        return;
      }
      
      lastDetectionTime = now;
      
      try {
        const predictions = await yoloDetector.detect(video); 
        ctx.clearRect(0, 0, canvas.width, canvas.height); // æ¸…é™¤ Canvas ä¸Šçš„æ¡†

        if (predictions.length > 0) {
          // ç”±æ–¼ CONF_THRESHOLD å·²ç¶“æé«˜åˆ° 0.75ï¼Œé€™è£¡çš„ predictions æ•¸é‡æ‡‰å·²å¤§å¹…æ¸›å°‘
          const validPredictions = predictions.filter(pred => pred.score > CONF_THRESHOLD);

          if (validPredictions.length > 0) {
            // æ‰¾å‡ºåˆ†æ•¸æœ€é«˜çš„ç‰©é«”
            const bestPred = validPredictions.reduce((prev, current) => (prev.score > current.score) ? prev : current);
            
            const { class: label, score, bbox } = bestPred;
            const { en, zh, key } = getWordInfo(label);

            // åªæœ‰åœ¨ç‰©å“è®ŠåŒ–æ™‚æ‰æ›´æ–°é¡¯ç¤º
            if (label !== lastLabel) {
              lastLabel = label;
              wordDisplay.innerHTML = `<strong>${en}</strong><br><span class="zh">${zh}</span>`;
              
              if (!isInGameMode) {
                addToVocab(en, zh, key);
                if (isEnglish) speak(en, 'en-US');
                else speak(zh, 'zh-TW');
              } else if (label === currentTarget || key === currentTarget) {
                speak(`ç­”å°äº†ï¼é€™æ˜¯ ${zh}`, 'zh-TW');
                setTimeout(startNewGame, 2000);
              }
              
              objectCooldown = 32; // è¨­ç½®å†·å»æ™‚é–“ï¼Œé¿å…é »ç¹æœ—è®€
            }

            statusInfo.textContent = `YOLOv8 åµæ¸¬åˆ°: ${zh} (${Math.round(score * 100)}%)`;

            // ç•«å‡ºæ‰€æœ‰æª¢æ¸¬æ¡† (ç¾åœ¨ç”±æ–¼ CONF_THRESHOLD æé«˜ï¼Œæ•¸é‡æœƒæ¸›å°‘)
            validPredictions.forEach(pred => {
              const [x, y, w, h] = pred.bbox;
              const isBest = pred === bestPred;
              
              // ä½¿ç”¨æ›´æ¸…æ™°çš„é¡è‰²å€åˆ†æœ€ä½³å’Œæ¬¡ä½³
              ctx.strokeStyle = isBest ? 'var(--pokemon-red)' : 'var(--pokemon-blue)';
              ctx.lineWidth = isBest ? 4 : 2;
              ctx.strokeRect(x, y, w, h);
              ctx.fillStyle = isBest ? 'rgba(255, 99, 71, 0.6)' : 'rgba(60, 76, 202, 0.4)';
              ctx.fillRect(x, y, w, 20);
              ctx.fillStyle = 'white';
              ctx.font = '12px Arial';
              const displayText = `${getWordInfo(pred.class).zh} (${pred.score.toFixed(2)})`; // é¡¯ç¤ºä¸­æ–‡åç¨±
              ctx.fillText(displayText, x + 5, y + 15);
            });
          } else {
            // é›–ç„¶åµæ¸¬åˆ°æ±è¥¿ï¼Œä½†åˆ†æ•¸éƒ½å¤ªä½
            wordDisplay.textContent = 'å°æº–ç‰©å“é–‹å§‹å­¸ç¿’';
            statusInfo.textContent = 'æœªåµæ¸¬åˆ°é«˜ä¿¡å¿ƒåº¦çš„ç‰©å“';
            lastLabel = '';
          }
        } else {
          wordDisplay.textContent = 'å°æº–ç‰©å“é–‹å§‹å­¸ç¿’';
          statusInfo.textContent = 'æœªåµæ¸¬åˆ°ç‰©å“';
          lastLabel = '';
        }
      } catch (error) {
        console.error('YOLOv8 åµæ¸¬éŒ¯èª¤:', error);
        statusInfo.textContent = 'YOLOv8 åµæ¸¬éŒ¯èª¤';
      }

      requestAnimationFrame(detectFrame);
    }

    // å•Ÿå‹•æ‡‰ç”¨
    async function loadModel() {
      try {
        yoloDetector = new YOLOv8Detector('yolov8n.onnx'); 
        
        const success = await yoloDetector.loadModel();
        
        if (success) {
            speak('æ­¡è¿ä½¿ç”¨è‹±æ–‡å­¸ç¿’ç³»çµ±', 'zh-TW');
            setupCamera();
        } 
      } catch (error) {
        console.error('å•Ÿå‹•å¤±æ•—:', error);
        wordDisplay.textContent = 'ç³»çµ±å•Ÿå‹•å¤±æ•—ï¼Œè«‹æª¢æŸ¥ä¸»æ§å°';
        statusInfo.textContent = 'å•Ÿå‹•å¤±æ•—';
      }
    }

    // é é¢å¯è¦‹æ€§è®ŠåŒ–è™•ç†
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        if (speechSynthesis.speaking) {
          speechSynthesis.cancel();
        }
      }
    });

    // æ¸…ç†è³‡æº
    window.addEventListener('beforeunload', function() {
      if (ocrWorker) {
        ocrWorker.terminate();
      }
      if (speechSynthesis.speaking) {
        speechSynthesis.cancel();
      }
    });

    // åˆå§‹åŒ–
    renderVocabList();
    
    // ç¬¬ä¸€æ¬¡é»æ“Šç•«é¢æ™‚è¼‰å…¥æ¨¡å‹ (ç¢ºä¿èªéŸ³å’Œç›¸æ©Ÿæ¬Šé™)
    document.addEventListener('click', function init() {
      loadModel();
      document.removeEventListener('click', init);
    }, { once: true });
  </script>
</body>
</html>