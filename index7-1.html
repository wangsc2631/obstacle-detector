<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ç›²äººå°èˆªåŠ©æ‰‹ - çœŸå¯¦éšœç¤™ç‰©æª¢æ¸¬</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #1e293b;
      color: white;
      height: 100vh;
      overflow: hidden;
      padding: 10px;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 10px;
    }
    
    .header {
      text-align: center;
      padding: 15px;
      background: #334155;
      border-radius: 12px;
    }
    
    .header h1 {
      font-size: 20px;
      margin-bottom: 5px;
    }
    
    .camera-container {
      flex: 1;
      background: #000;
      border-radius: 12px;
      position: relative;
      overflow: hidden;
    }
    
    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* é¡åƒ */
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .status-panel {
      background: #334155;
      border-radius: 12px;
      padding: 15px;
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .status-item {
      text-align: center;
      padding: 10px;
      background: #475569;
      border-radius: 8px;
    }
    
    .status-label {
      font-size: 12px;
      opacity: 0.8;
      margin-bottom: 5px;
    }
    
    .status-value {
      font-size: 16px;
      font-weight: bold;
    }
    
    .detection-list {
      max-height: 100px;
      overflow-y: auto;
      background: #475569;
      border-radius: 8px;
      padding: 10px;
      margin-top: 10px;
    }
    
    .detection-item {
      font-size: 12px;
      margin-bottom: 5px;
      padding: 5px;
      background: #64748b;
      border-radius: 4px;
    }
    
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .btn {
      padding: 15px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .btn:active {
      transform: scale(0.98);
    }
    
    .btn-primary {
      background: #22c55e;
    }
    
    .btn-danger {
      background: #ef4444;
    }
    
    .btn-warning {
      background: #f59e0b;
    }
    
    .btn-secondary {
      background: #475569;
    }
    
    .emergency-btn {
      width: 100%;
      padding: 18px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
    }
    
    .voice-feedback {
      background: #334155;
      border-radius: 12px;
      padding: 15px;
      margin-top: 10px;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 14px;
    }
    
    .warning-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(239, 68, 68, 0.3);
      display: none;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      font-weight: bold;
    }
    
    .warning-overlay.active {
      display: flex;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 0.3; }
      50% { opacity: 0.7; }
      100% { opacity: 0.3; }
    }
    
    .distance-indicator {
      height: 8px;
      background: #475569;
      border-radius: 4px;
      margin: 10px 0;
      overflow: hidden;
    }
    
    .distance-fill {
      height: 100%;
      background: #22c55e;
      border-radius: 4px;
      transition: width 0.3s, background 0.3s;
    }
    
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ§­ ç›²äººå°èˆªåŠ©æ‰‹</h1>
      <div>çœŸå¯¦éšœç¤™ç‰©æª¢æ¸¬ Â· èªéŸ³å°èˆª</div>
    </div>
    
    <div class="camera-container">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
      <div class="warning-overlay" id="warningOverlay">
        âš ï¸ å‰æ–¹æœ‰éšœç¤™ç‰©ï¼
      </div>
      <div class="loading" id="loading">
        æ­£åœ¨åŠ è¼‰AIæ¨¡å‹...<br>
        <small>è«‹ç¨å€™</small>
      </div>
    </div>
    
    <div class="status-panel">
      <div class="status-grid">
        <div class="status-item">
          <div class="status-label">æª¢æ¸¬ç‹€æ…‹</div>
          <div class="status-value" id="detectionStatus">æº–å‚™ä¸­</div>
        </div>
        <div class="status-item">
          <div class="status-label">æœ€è¿‘éšœç¤™ç‰©</div>
          <div class="status-value" id="closestObject">--</div>
        </div>
        <div class="status-item">
          <div class="status-label">è·é›¢ä¼°è¨ˆ</div>
          <div class="status-value" id="distanceEstimate">-- å…¬å°º</div>
        </div>
        <div class="status-item">
          <div class="status-label">æª¢æ¸¬æ•¸é‡</div>
          <div class="status-value" id="detectionCount">0</div>
        </div>
      </div>
      
      <div class="distance-indicator">
        <div class="distance-fill" id="distanceFill" style="width: 0%"></div>
      </div>
      
      <div class="detection-list" id="detectionList">
        <!-- æª¢æ¸¬åˆ°çš„ç‰©é«”åˆ—è¡¨ -->
      </div>
    </div>
    
    <div class="controls">
      <button class="btn btn-primary" id="btnStart">é–‹å§‹æª¢æ¸¬</button>
      <button class="btn btn-danger" id="btnStop">åœæ­¢æª¢æ¸¬</button>
      <button class="btn btn-secondary" id="btnToggleVoice">ğŸ”Š èªéŸ³é–‹é—œ</button>
      <button class="btn btn-warning" id="btnRepeat">é‡è¤‡æç¤º</button>
    </div>
    
    <button class="emergency-btn" id="btnEmergency">
      ğŸ†˜ ç·Šæ€¥æ±‚åŠ©
    </button>
    
    <div class="voice-feedback" id="voiceFeedback">
      ç³»çµ±æº–å‚™ä¸­ï¼Œè«‹é»æ“Š"é–‹å§‹æª¢æ¸¬"
    </div>
  </div>

  <script>
    // çœŸå¯¦çš„ç›²äººå°èˆªåŠ©æ‰‹
    class RealBlindNavigation {
      constructor() {
        this.isDetecting = false;
        this.model = null;
        this.video = null;
        this.canvas = null;
        this.ctx = null;
        this.voiceEnabled = true;
        this.lastDetectionTime = 0;
        this.detectionInterval = 1000; // 1ç§’æª¢æ¸¬ä¸€æ¬¡
        this.lastWarning = '';
        this.warningCooldown = 3000; // 3ç§’è­¦å‘Šå†·å»
        
        this.initialize();
      }
      
      async initialize() {
        this.video = document.getElementById('video');
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        
        try {
          // åŠ è¼‰COCO-SSDæ¨¡å‹ï¼ˆå¯ä»¥æª¢æ¸¬80ç¨®å¸¸è¦‹ç‰©é«”ï¼‰
          this.showLoading('æ­£åœ¨åŠ è¼‰AIæ¨¡å‹...');
          this.model = await cocoSsd.load();
          this.hideLoading();
          
          this.speak('AIæ¨¡å‹åŠ è¼‰å®Œæˆï¼Œæº–å‚™é–‹å§‹éšœç¤™ç‰©æª¢æ¸¬');
          this.updateDetectionStatus('æ¨¡å‹å°±ç·’');
          
        } catch (error) {
          this.hideLoading();
          this.speak('æ¨¡å‹åŠ è¼‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡é€£æ¥');
          console.error('æ¨¡å‹åŠ è¼‰éŒ¯èª¤:', error);
        }
      }
      
      async startDetection() {
        if (!this.model) {
          this.speak('AIæ¨¡å‹å°šæœªåŠ è¼‰å®Œæˆï¼Œè«‹ç¨å€™');
          return;
        }
        
        try {
          // é–‹å•Ÿæ”åƒé ­
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { 
              facingMode: 'environment', // ä½¿ç”¨å¾Œç½®æ”åƒé ­
              width: { ideal: 640 },
              height: { ideal: 480 }
            }
          });
          
          this.video.srcObject = stream;
          this.isDetecting = true;
          this.updateDetectionStatus('æª¢æ¸¬ä¸­');
          this.speak('é–‹å§‹å¯¦æ™‚éšœç¤™ç‰©æª¢æ¸¬ï¼Œæ­£åœ¨æƒæå‘¨åœç’°å¢ƒ');
          
          // é–‹å§‹æª¢æ¸¬å¾ªç’°
          this.detectFrame();
          
        } catch (error) {
          this.speak('ç„¡æ³•è¨ªå•æ”åƒé ­ï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­ç½®');
          console.error('æ”åƒé ­éŒ¯èª¤:', error);
        }
      }
      
      stopDetection() {
        this.isDetecting = false;
        
        if (this.video.srcObject) {
          this.video.srcObject.getTracks().forEach(track => track.stop());
          this.video.srcObject = null;
        }
        
        // æ¸…ç©ºç•«å¸ƒ
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.updateDetectionStatus('å·²åœæ­¢');
        this.speak('éšœç¤™ç‰©æª¢æ¸¬å·²åœæ­¢');
        this.updateUI();
      }
      
      async detectFrame() {
        if (!this.isDetecting) return;
        
        const now = Date.now();
        if (now - this.lastDetectionTime < this.detectionInterval) {
          requestAnimationFrame(() => this.detectFrame());
          return;
        }
        
        this.lastDetectionTime = now;
        
        try {
          // è¨­ç½®ç•«å¸ƒå°ºå¯¸åŒ¹é…è¦–é »
          if (this.canvas.width !== this.video.videoWidth || 
              this.canvas.height !== this.video.videoHeight) {
            this.canvas.width = this.video.videoWidth;
            this.canvas.height = this.video.videoHeight;
          }
          
          // æ¸…ç©ºä¸Šä¸€å¹€çš„ç¹ªè£½
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          
          // é€²è¡Œç‰©é«”æª¢æ¸¬
          const predictions = await this.model.detect(this.video);
          
          // è™•ç†æª¢æ¸¬çµæœ
          this.processDetections(predictions);
          
        } catch (error) {
          console.error('æª¢æ¸¬éŒ¯èª¤:', error);
        }
        
        // ç¹¼çºŒä¸‹ä¸€å¹€æª¢æ¸¬
        requestAnimationFrame(() => this.detectFrame());
      }
      
      processDetections(predictions) {
        // éæ¿¾å‡ºå¯èƒ½æˆç‚ºéšœç¤™ç‰©çš„ç‰©é«”
        const obstacles = predictions.filter(pred => 
          this.isPotentialObstacle(pred.class) && pred.score > 0.5
        );
        
        // æ›´æ–°é¡¯ç¤º
        this.updateDetectionDisplay(obstacles);
        
        // æ‰¾å‡ºæœ€è¿‘çš„éšœç¤™ç‰©
        const closest = this.findClosestObstacle(obstacles);
        
        if (closest) {
          this.handleObstacleWarning(closest);
          this.drawDetectionBox(closest);
        } else {
          this.clearWarnings();
        }
        
        // æ›´æ–°ç‰©é«”åˆ—è¡¨
        this.updateObjectList(obstacles);
      }
      
      isPotentialObstacle(className) {
        // å®šç¾©å¯èƒ½æˆç‚ºéšœç¤™ç‰©çš„ç‰©é«”é¡å‹
        const obstacleClasses = [
          'person', 'bicycle', 'car', 'motorcycle', 'bus', 'truck',
          'chair', 'couch', 'potted plant', 'bed', 'dining table',
          'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone',
          'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier',
          'toothbrush', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase',
          'frisbee', 'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat',
          'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
          'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl',
          'banana', 'apple', 'sandwich', 'orange', 'broccoli', 'carrot',
          'hot dog', 'pizza', 'donut', 'cake'
        ];
        
        return obstacleClasses.includes(className);
      }
      
      findClosestObstacle(obstacles) {
        if (obstacles.length === 0) return null;
        
        // åŸºæ–¼é‚Šç•Œæ¡†å¤§å°ä¼°ç®—è·é›¢ï¼ˆæ¡†è¶Šå¤§è¡¨ç¤ºè¶Šè¿‘ï¼‰
        return obstacles.reduce((closest, current) => {
          const currentSize = current.bbox[2] * current.bbox[3]; // å¯¬ * é«˜
          const closestSize = closest.bbox[2] * closest.bbox[3];
          return currentSize > closestSize ? current : closest;
        });
      }
      
      handleObstacleWarning(obstacle) {
        const bbox = obstacle.bbox;
        const boxArea = bbox[2] * bbox[3]; // å¯¬ * é«˜
        const videoArea = this.video.videoWidth * this.video.videoHeight;
        const coverage = boxArea / videoArea;
        
        // æ ¹æ“šè¦†è“‹ç‡ä¼°ç®—è·é›¢
        let distanceLevel = 'far';
        let distanceMeters = '5+';
        let warningLevel = 0;
        
        if (coverage > 0.3) { // å¾ˆè¿‘
          distanceLevel = 'very close';
          distanceMeters = '0.5-1';
          warningLevel = 3;
        } else if (coverage > 0.15) { // è¿‘
          distanceLevel = 'close';
          distanceMeters = '1-2';
          warningLevel = 2;
        } else if (coverage > 0.05) { // ä¸­ç­‰
          distanceLevel = 'medium';
          distanceMeters = '2-4';
          warningLevel = 1;
        }
        
        // æ›´æ–°é¡¯ç¤º
        document.getElementById('closestObject').textContent = obstacle.class;
        document.getElementById('distanceEstimate').textContent = distanceMeters + ' å…¬å°º';
        
        // æ›´æ–°è·é›¢æŒ‡ç¤ºæ¢
        const fillPercentage = Math.min(100, coverage * 300);
        const distanceFill = document.getElementById('distanceFill');
        distanceFill.style.width = fillPercentage + '%';
        
        // è¨­ç½®é¡è‰²è­¦å‘Š
        if (warningLevel === 3) {
          distanceFill.style.background = '#ef4444';
          this.triggerUrgentWarning(obstacle, distanceLevel);
        } else if (warningLevel === 2) {
          distanceFill.style.background = '#f59e0b';
          this.triggerWarning(obstacle, distanceLevel);
        } else {
          distanceFill.style.background = '#22c55e';
        }
      }
      
      triggerUrgentWarning(obstacle, distance) {
        const warning = `ç·Šæ€¥ï¼å‰æ–¹${distance}è™•æœ‰${obstacle.class}ï¼Œè«‹ç«‹å³åœæ­¢ç§»å‹•`;
        
        if (this.lastWarning !== warning) {
          this.speak(warning);
          this.lastWarning = warning;
          
          // é¡¯ç¤ºè¦–è¦ºè­¦å‘Š
          document.getElementById('warningOverlay').classList.add('active');
          
          // è§¸ç™¼æŒ¯å‹•ï¼ˆå¦‚æœæ”¯æŒï¼‰
          if ('vibrate' in navigator) {
            navigator.vibrate([500, 200, 500, 200, 500]);
          }
        }
      }
      
      triggerWarning(obstacle, distance) {
        const warning = `æ³¨æ„ï¼Œå‰æ–¹${distance}è™•æœ‰${obstacle.class}`;
        
        if (this.lastWarning !== warning) {
          this.speak(warning);
          this.lastWarning = warning;
          document.getElementById('warningOverlay').classList.remove('active');
        }
      }
      
      clearWarnings() {
        document.getElementById('closestObject').textContent = '--';
        document.getElementById('distanceEstimate').textContent = '-- å…¬å°º';
        document.getElementById('distanceFill').style.width = '0%';
        document.getElementById('distanceFill').style.background = '#22c55e';
        document.getElementById('warningOverlay').classList.remove('active');
        this.lastWarning = '';
      }
      
      drawDetectionBox(prediction) {
        const [x, y, width, height] = prediction.bbox;
        
        // ç¹ªè£½é‚Šç•Œæ¡†
        this.ctx.strokeStyle = prediction.score > 0.7 ? '#ef4444' : '#f59e0b';
        this.ctx.lineWidth = 3;
        this.ctx.strokeRect(x, y, width, height);
        
        // ç¹ªè£½æ¨™ç±¤èƒŒæ™¯
        this.ctx.fillStyle = prediction.score > 0.7 ? '#ef4444' : '#f59e0b';
        const text = `${prediction.class} ${Math.round(prediction.score * 100)}%`;
        const textWidth = this.ctx.measureText(text).width;
        this.ctx.fillRect(x, y - 20, textWidth + 10, 20);
        
        // ç¹ªè£½æ¨™ç±¤æ–‡å­—
        this.ctx.fillStyle = 'white';
        this.ctx.font = '16px Arial';
        this.ctx.fillText(text, x + 5, y - 5);
      }
      
      updateDetectionDisplay(obstacles) {
        document.getElementById('detectionCount').textContent = obstacles.length;
      }
      
      updateObjectList(obstacles) {
        const list = document.getElementById('detectionList');
        list.innerHTML = '';
        
        obstacles.slice(0, 5).forEach(obs => {
          const item = document.createElement('div');
          item.className = 'detection-item';
          item.textContent = `${obs.class} (${Math.round(obs.score * 100)}%)`;
          list.appendChild(item);
        });
      }
      
      updateDetectionStatus(status) {
        document.getElementById('detectionStatus').textContent = status;
      }
      
      toggleVoice() {
        this.voiceEnabled = !this.voiceEnabled;
        this.speak(this.voiceEnabled ? 'èªéŸ³æç¤ºå·²é–‹å•Ÿ' : 'èªéŸ³æç¤ºå·²é—œé–‰');
      }
      
      repeatWarning() {
        if (this.lastWarning) {
          this.speak(this.lastWarning);
        } else {
          this.speak('ç›®å‰æ²’æœ‰æª¢æ¸¬åˆ°éšœç¤™ç‰©');
        }
      }
      
      emergencyAlert() {
        this.speak('ç·Šæ€¥æ±‚åŠ©å·²å•Ÿå‹•ï¼æ‚¨çš„ä½ç½®å’Œå‘¨åœç’°å¢ƒä¿¡æ¯å·²ç™¼é€çµ¦ç·Šæ€¥è¯çµ¡äºº');
        
        // å¯¦éš›æ‡‰ç”¨ä¸­é€™è£¡æ‡‰è©²ç™¼é€çœŸå¯¦çš„æ±‚åŠ©ä¿¡æ¯
        if ('geolocation' in navigator) {
          navigator.geolocation.getCurrentPosition(
            position => {
              this.speak(`æ‚¨çš„ä½ç½®å·²è¨˜éŒ„ï¼Œç¶“åº¦${position.coords.longitude.toFixed(4)}ï¼Œç·¯åº¦${position.coords.latitude.toFixed(4)}`);
            },
            error => {
              this.speak('ç„¡æ³•ç²å–ç²¾ç¢ºä½ç½®ï¼Œä½†æ±‚åŠ©ä¿¡æ¯å·²ç™¼é€');
            }
          );
        }
      }
      
      speak(message) {
        if (this.voiceEnabled && window.speechSynthesis) {
          window.speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(message);
          utterance.lang = 'zh-TW';
          utterance.rate = 0.9;
          window.speechSynthesis.speak(utterance);
        }
        document.getElementById('voiceFeedback').textContent = message;
      }
      
      showLoading(message) {
        const loading = document.getElementById('loading');
        loading.innerHTML = message + '<br><small>è«‹ç¨å€™</small>';
        loading.style.display = 'block';
      }
      
      hideLoading() {
        document.getElementById('loading').style.display = 'none';
      }
      
      updateUI() {
        const startBtn = document.getElementById('btnStart');
        if (this.isDetecting) {
          startBtn.textContent = 'æª¢æ¸¬ä¸­...';
          startBtn.disabled = true;
        } else {
          startBtn.textContent = 'é–‹å§‹æª¢æ¸¬';
          startBtn.disabled = false;
        }
      }
    }

    // åˆå§‹åŒ–ç³»çµ±
    const navigation = new RealBlindNavigation();

    // äº‹ä»¶ç›£è½
    document.getElementById('btnStart').addEventListener('click', () => {
      navigation.startDetection();
    });
    
    document.getElementById('btnStop').addEventListener('click', () => {
      navigation.stopDetection();
    });
    
    document.getElementById('btnToggleVoice').addEventListener('click', () => {
      navigation.toggleVoice();
    });
    
    document.getElementById('btnRepeat').addEventListener('click', () => {
      navigation.repeatWarning();
    });
    
    document.getElementById('btnEmergency').addEventListener('click', () => {
      navigation.emergencyAlert();
    });

    // éµç›¤å¿«æ·éµ
    document.addEventListener('keydown', (e) => {
      switch(e.key) {
        case ' ': // ç©ºæ ¼éµ
          if (navigation.isDetecting) {
            navigation.stopDetection();
          } else {
            navigation.startDetection();
          }
          break;
        case 'r': // Réµé‡è¤‡
          navigation.repeatWarning();
          break;
        case 'v': // VéµèªéŸ³é–‹é—œ
          navigation.toggleVoice();
          break;
      }
    });
  </script>
</body>
</html>