<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <title>🧭 盲人導航助手 - AI 避障</title>
  
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Microsoft JhengHei', sans-serif;
      background: linear-gradient(135deg, #0ea5e9, #6366f1);
      color: white;
      height: 100vh;
      padding: 0;
      overflow: hidden;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 0;
    }
    
    .header {
      text-align: center;
      padding: 12px 10px;
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      flex-shrink: 0;
    }
    
    .header h1 {
      font-size: 16px;
      margin-bottom: 2px;
    }
    
    .header .subtitle {
      font-size: 11px;
      opacity: 0.8;
    }
    
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 5px;
      padding: 5px;
      min-height: 0;
      overflow-y: auto;
    }
    
    .camera-view {
      flex: 0 0 35vh;
      background: #000;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }
    
    .camera-view video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .obstacle-marker {
      position: absolute;
      background: rgba(255, 255, 0, 0.8);
      border-radius: 4px;
      border: 2px solid #ff0000;
      color: #000;
      font-size: 10px;
      padding: 2px 4px;
      text-align: center;
      box-sizing: border-box;
      white-space: nowrap;
      transform: translate(-50%, -50%);
      animation: markerPulse 1.5s infinite;
      z-index: 10;
    }
    
    @keyframes markerPulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
      70% { box-shadow: 0 0 0 8px rgba(255, 0, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
    }
    
    .status-panel {
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 8px;
      backdrop-filter: blur(10px);
      flex-shrink: 0;
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 6px;
    }
    
    .status-item {
      text-align: center;
      padding: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
    }
    
    .status-label {
      font-size: 9px;
      opacity: 0.8;
      margin-bottom: 2px;
    }
    
    .status-value {
      font-size: 12px;
      font-weight: bold;
    }
    
    .voice-alert {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.5);
      border-radius: 6px;
      padding: 8px;
      text-align: center;
      min-height: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      flex-shrink: 0;
      overflow-wrap: break-word;
    }
    
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      flex-shrink: 0;
      margin-bottom: 6px;
    }
    
    .btn {
      padding: 12px 6px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 44px;
    }
    
    .btn:active {
      transform: scale(0.95);
    }
    
    .btn-primary {
      background: #22c55e;
    }
    
    .btn-warning {
      background: #f59e0b;
    }
    
    .btn-danger {
      background: #ef4444;
    }
    
    .btn-secondary {
      background: rgba(255,255,255,0.2);
    }
    
    .btn-info {
      background: #3b82f6;
    }
    
    .btn-active {
      box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
    }
    
    .tracking-indicator, .direction-arrow, .distance-badge {
      position: absolute;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 9px;
      z-index: 5;
    }

    .tracking-indicator {
      top: 4px;
      right: 4px;
      display: none;
    }
    
    .tracking-indicator.active {
      display: block;
    }

    .direction-arrow {
      top: 4px;
      left: 4px;
      display: none;
    }
    
    .direction-arrow.active {
      display: block;
    }

    .distance-badge {
      bottom: 4px;
      left: 4px;
    }
    
    .mode-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 6px;
      flex-shrink: 0;
    }

    .mode-btn {
      padding: 10px 6px;
      border: none;
      border-radius: 8px;
      font-size: 11px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      background: rgba(255,255,255,0.2);
      min-height: 40px;
    }

    .mode-btn.active {
      background: #3b82f6;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
    }

    .emergency-section {
      margin-top: 6px;
      flex-shrink: 0;
    }

    .emergency-btn {
      width: 100%;
      padding: 12px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      min-height: 50px;
    }

    .avoidance-indicator {
      position: absolute;
      bottom: 4px;
      right: 4px;
      background: #f59e0b;
      color: white;
      padding: 6px 12px;
      border-radius: 15px;
      font-size: 10px;
      display: none;
      z-index: 5;
    }
    
    .avoidance-indicator.active {
      display: block;
    }

    .path-arrow {
      position: absolute;
      font-size: 40px;
      color: #22c55e;
      text-shadow: 0 0 10px #22c55e;
      font-weight: 900;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 10;
    }
    
    .path-arrow.active {
      opacity: 1;
    }
    
    .path-arrow.left {
      left: 15%;
      top: 50%;
      transform: translateY(-50%) rotate(180deg);
    }
    
    .path-arrow.right {
      right: 15%;
      top: 50%;
      transform: translateY(-50%) rotate(0deg);
    }
    
    .path-arrow.forward {
      left: 50%;
      top: 20%;
      transform: translateX(-50%) rotate(0deg);
    }

    #bboxCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
    }

    .control-section {
      flex-shrink: 0;
    }

    .debug-info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px;
      border-radius: 6px;
      font-size: 10px;
      z-index: 20;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🧭 盲人導航助手</h1>
      <div class="subtitle">智能避障 · AI 視覺分析</div>
    </div>
    
    <div class="main-content">
      <div class="mode-selector">
        <button class="mode-btn active" id="btnOutdoorMode">室外導航 (GPS)</button>
        <button class="mode-btn" id="btnIndoorMode">室內避障 (AI 視覺)</button>
      </div>

      <div class="camera-view">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="bboxCanvas"></canvas>
        <div class="overlay">
          <div id="obstacleMarkers"></div>
          
          <div class="path-arrow left" id="arrowLeft">👈</div>
          <div class="path-arrow right" id="arrowRight">👉</div>
          <div class="path-arrow forward" id="arrowForward">👆</div>
        </div>
        
        <div class="tracking-indicator" id="trackingIndicator">
          👤 跟隨中 <span id="trackingDistance">0m</span>
        </div>
        <div class="direction-arrow" id="directionArrow">
          🏠 <span id="homeDirection">--</span>
        </div>
        <div class="distance-badge" id="distanceBadge">
          📍 距家: <span id="homeDistance">--</span>
        </div>
        <div class="avoidance-indicator" id="avoidanceIndicator">
          ⚠️ AI 模型載入中...
        </div>
        <div class="debug-info" id="debugInfo"></div>
      </div>
      
      <div class="control-section">
        <div class="status-panel">
          <div class="status-grid">
            <div class="status-item">
              <div class="status-label">系統狀態</div>
              <div class="status-value" id="systemStatus">載入模型中...</div>
            </div>
            <div class="status-item">
              <div class="status-label">避障建議</div>
              <div class="status-value" id="avoidanceAdvice">--</div>
            </div>
            <div class="status-item">
              <div class="status-label">最近障礙物</div>
              <div class="status-value" id="closestObstacle">-- 公尺</div>
            </div>
            <div class="status-item">
              <div class="status-label">AI 幀率</div>
              <div class="status-value" id="safetyScore">-- FPS</div>
            </div>
          </div>
          
          <div class="voice-alert" id="voiceAlert">
            AI 模型載入中，請稍候...
          </div>
        </div>
        
        <div class="controls">
          <button class="btn btn-primary" id="btnStart" disabled>開始導航</button>
          <button class="btn btn-warning" id="btnFollow" disabled>人員跟隨</button>
          <button class="btn btn-info" id="btnSetHome">📍 設定家的位置</button>
          <button class="btn btn-danger" id="btnStop" disabled>停止</button>
        </div>

        <div class="emergency-section">
          <button class="emergency-btn" id="btnEmergency">🆘 緊急求助</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // YOLOv8 物件類別名稱 (COCO dataset)
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorbike', 'aeroplane', 'bus', 'train', 'truck', 'boat', 
      'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 
      'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 
      'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 
      'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 
      'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 
      'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 
      'sofa', 'pottedplant', 'bed', 'diningtable', 'toilet', 'tvmonitor', 'laptop', 'mouse', 
      'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 
      'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];
    
    const MODEL_INPUT_SIZE = 640;

    /**
     * @class YOLOv8Detector
     * 修復版 YOLOv8 檢測器 - 完全使用真實模型
     */
    class YOLOv8Detector {
      constructor(modelPath = 'yolov8n.onnx') {
        this.modelPath = modelPath;
        this.session = null;
        this.isReady = false;
        this.videoElement = document.getElementById('video');
        this.canvasElement = document.getElementById('bboxCanvas');
        this.canvasCtx = this.canvasElement.getContext('2d');
        this.lastInferenceTime = Date.now();
        this.frameCount = 0;
        this.fps = 0;
        
        // 禁用模擬模式，強制使用真實模型
        this.useSimulation = false;
      }

      async loadModel() {
        document.getElementById('systemStatus').textContent = '嘗試載入 AI 模型...';
        document.getElementById('voiceAlert').textContent = `正在從 ${this.modelPath} 載入模型...`;
        
        try {
          if (typeof ort === 'undefined' || !ort.InferenceSession) {
            throw new Error("ONNX Runtime Web 函式庫未載入。");
          }

          // 嘗試使用 WebGL 加速
          this.session = await ort.InferenceSession.create(this.modelPath, {
            executionProviders: ['webgl'],
            graphOptimizationLevel: 'all'
          });

          console.log('YOLOv8 模型載入成功');
          console.log('輸入名稱:', this.session.inputNames);
          console.log('輸出名稱:', this.session.outputNames);
          
          this.isReady = true;
          document.getElementById('systemStatus').textContent = 'AI 視覺準備就緒';
          document.getElementById('voiceAlert').textContent = 'AI 模型載入成功，可以開始導航';
          document.getElementById('avoidanceIndicator').textContent = '✅ AI 視覺準備就緒';
          document.getElementById('avoidanceIndicator').classList.add('active');
          document.getElementById('btnStart').disabled = false;
          document.getElementById('btnStop').disabled = false;
          
          return true;
          
        } catch (error) {
          console.error('模型載入失敗:', error);
          document.getElementById('systemStatus').textContent = 'AI 模型載入失敗';
          document.getElementById('voiceAlert').textContent = 'AI 模型載入失敗: ' + error.message;
          document.getElementById('avoidanceIndicator').textContent = '❌ AI 模型錯誤';
          return false;
        }
      }

      async detect(video) {
        if (!this.isReady || !this.session) {
          console.log('模型未準備好');
          return [];
        }

        const startTime = performance.now();

        try {
          // 1. 圖像預處理 - 修復張量轉換邏輯
          const inputTensor = this.preprocessImage(video);
          
          // 2. 模型推理
          const feeds = {};
          feeds[this.session.inputNames[0]] = inputTensor;
          
          const results = await this.session.run(feeds);
          const outputTensor = results[this.session.outputNames[0]];
          
          // 3. 後處理
          const detections = this.postprocessOutput(outputTensor, video.videoWidth, video.videoHeight);
          
          // 4. 計算 FPS
          const endTime = performance.now();
          const inferenceTime = endTime - startTime;
          this.updateFPS(inferenceTime);
          
          return detections;
          
        } catch (error) {
          console.error('檢測過程中發生錯誤:', error);
          return [];
        }
      }

      preprocessImage(video) {
        return tf.tidy(() => {
          // 1. 從影片元素獲取張量
          let tensor = tf.browser.fromPixels(video);
          
          // 2. 調整大小到 640x640
          tensor = tf.image.resizeBilinear(tensor, [MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
          
          // 3. 歸一化: [0, 255] -> [0, 1]
          tensor = tensor.div(255.0);
          
          // 4. 變換通道: (H, W, C) -> (C, H, W)
          tensor = tensor.transpose([2, 0, 1]);
          
          // 5. 增加 Batch 維度: (C, H, W) -> (1, C, H, W)
          tensor = tensor.expandDims(0);
          
          // 6. 確保數據類型為 float32
          const data = tensor.dataSync();
          
          return new ort.Tensor('float32', data, [1, 3, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
        });
      }

      postprocessOutput(outputTensor, originalWidth, originalHeight, confThreshold = 0.25, iouThreshold = 0.45) {
        const detections = [];
        const outputData = outputTensor.data;
        const outputDims = outputTensor.dims;
        
        console.log('輸出維度:', outputDims);
        console.log('輸出數據長度:', outputData.length);
        
        // YOLOv8 輸出格式通常是 [1, 84, 8400]
        if (outputDims.length === 3 && outputDims[0] === 1) {
          const numClasses = outputDims[1] - 4; // 84 - 4 = 80 classes
          const numBoxes = outputDims[2]; // 8400 boxes
          
          for (let i = 0; i < numBoxes; i++) {
            const classScores = [];
            let maxScore = -1;
            let classId = -1;
            
            // 獲取類別分數
            for (let j = 0; j < numClasses; j++) {
              const score = outputData[(j + 4) * numBoxes + i];
              classScores.push(score);
              if (score > maxScore) {
                maxScore = score;
                classId = j;
              }
            }
            
            // 應用信心度門檻
            if (maxScore > confThreshold) {
              // 獲取邊界框座標
              const cx = outputData[0 * numBoxes + i] * originalWidth / MODEL_INPUT_SIZE;
              const cy = outputData[1 * numBoxes + i] * originalHeight / MODEL_INPUT_SIZE;
              const w = outputData[2 * numBoxes + i] * originalWidth / MODEL_INPUT_SIZE;
              const h = outputData[3 * numBoxes + i] * originalHeight / MODEL_INPUT_SIZE;
              
              const x1 = cx - w / 2;
              const y1 = cy - h / 2;
              const x2 = cx + w / 2;
              const y2 = cy + h / 2;
              
              detections.push({
                x1: Math.max(0, x1),
                y1: Math.max(0, y1),
                x2: Math.min(originalWidth, x2),
                y2: Math.min(originalHeight, y2),
                w: w,
                h: h,
                score: maxScore,
                classId: classId,
                className: CLASS_NAMES[classId],
                distance: this.estimateDistance(h, originalHeight)
              });
            }
          }
        }
        
        // 應用 NMS (非極大值抑制)
        const nmsDetections = this.nonMaxSuppression(detections, iouThreshold);
        
        console.log(`檢測到 ${nmsDetections.length} 個物件`);
        return nmsDetections.slice(0, 10); // 返回前10個檢測結果
      }

      nonMaxSuppression(detections, iouThreshold) {
        detections.sort((a, b) => b.score - a.score);
        const selected = [];
        
        while (detections.length > 0) {
          const best = detections[0];
          selected.push(best);
          detections = detections.slice(1);
          
          detections = detections.filter(det => {
            const iou = this.calculateIOU(best, det);
            return iou < iouThreshold;
          });
        }
        
        return selected;
      }

      calculateIOU(box1, box2) {
        const x1 = Math.max(box1.x1, box2.x1);
        const y1 = Math.max(box1.y1, box2.y1);
        const x2 = Math.min(box1.x2, box2.x2);
        const y2 = Math.min(box1.y2, box2.y2);
        
        const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
        const area1 = (box1.x2 - box1.x1) * (box1.y2 - box1.y1);
        const area2 = (box2.x2 - box2.x1) * (box2.y2 - box2.y1);
        const union = area1 + area2 - intersection;
        
        return intersection / union;
      }

      estimateDistance(height, imageHeight) {
        if (height <= 0) return 999;
        const normalizedHeight = height / imageHeight;
        // 簡化的距離估計：物體越大，距離越近
        return Math.min(20, 3 / normalizedHeight);
      }

      updateFPS(inferenceTime) {
        this.frameCount++;
        const now = Date.now();
        
        if (now - this.lastInferenceTime >= 1000) {
          this.fps = this.frameCount;
          this.frameCount = 0;
          this.lastInferenceTime = now;
          document.getElementById('safetyScore').textContent = this.fps + ' FPS';
        }
      }

      draw(detections) {
        if (!this.canvasElement || !this.canvasCtx) return;
        
        const width = this.videoElement.videoWidth || 640;
        const height = this.videoElement.videoHeight || 480;
        
        this.canvasElement.width = width;
        this.canvasElement.height = height;
        this.canvasCtx.clearRect(0, 0, width, height);

        // 顯示除錯資訊
        const debugInfo = document.getElementById('debugInfo');
        debugInfo.textContent = `解析度: ${width}x${height}\n檢測到: ${detections.length} 個物件`;
        debugInfo.style.display = 'block';

        detections.forEach((box, index) => {
          const { x1, y1, w, h, className, distance, score } = box;
          
          // 根據距離設置顏色
          let color = '#22c55e'; // 綠色 (遠)
          if (distance < 3.0) color = '#f59e0b'; // 黃色 (中)
          if (distance < 1.5) color = '#ef4444'; // 紅色 (近)

          // 繪製邊界框
          this.canvasCtx.strokeStyle = color;
          this.canvasCtx.lineWidth = 3;
          this.canvasCtx.strokeRect(x1, y1, w, h);

          // 繪製標籤背景
          this.canvasCtx.fillStyle = color;
          this.canvasCtx.font = '14px Arial';
          const label = `${className} ${distance.toFixed(1)}m (${score.toFixed(2)})`;
          const textWidth = this.canvasCtx.measureText(label).width;
          
          const labelY = y1 > 20 ? y1 - 5 : y1 + h + 15;
          this.canvasCtx.fillRect(x1, labelY - 15, textWidth + 10, 18);
          
          // 繪製文字
          this.canvasCtx.fillStyle = '#000';
          this.canvasCtx.fillText(label, x1 + 5, labelY);
        });
      }
    }

    // --- 智能避障導航系統 ---
    class ObstacleAvoidanceSystem {
      constructor() {
        this.yoloDetector = new YOLOv8Detector('yolov8n.onnx');
        this.detectionLoopId = null;
        this.voiceEnabled = true;
        this.isNavigating = false;
        this.isFollowing = false;
        this.isIndoorMode = false;
        this.homePosition = null;
        this.currentPosition = null;
        this.gpsWatchId = null;
        
        this.lastSpeakTime = 0;
        this.speakCooldown = 3000;
        this.lastSpokenAdvice = '';
        
        this.loadHomePosition();
        this.initButtons();
      }

      initButtons() {
        document.getElementById('btnStart').disabled = true;
        document.getElementById('btnFollow').disabled = true;
        document.getElementById('btnStop').disabled = true;
      }

      async initializeSystem() {
        this.updateSystemStatus('載入 AI 模型...');
        const success = await this.yoloDetector.loadModel();
        
        if (success) {
          this.updateSystemStatus('準備就緒');
        } else {
          this.updateSystemStatus('載入失敗');
        }
      }

      switchMode(isIndoor) {
        this.isIndoorMode = isIndoor;
        
        document.getElementById('btnOutdoorMode').classList.toggle('active', !isIndoor);
        document.getElementById('btnIndoorMode').classList.toggle('active', isIndoor);
        
        if (isIndoor) {
          this.speak('已切換到室內避障模式');
          document.getElementById('avoidanceIndicator').classList.add('active');
          document.getElementById('btnFollow').disabled = true;
          
          // 如果正在導航，重新啟動 AI 檢測
          if (this.isNavigating) {
            this.startAIDetection();
          }
        } else {
          this.speak('已切換到室外導航模式');
          document.getElementById('avoidanceIndicator').classList.remove('active');
          this.stopAIDetection();
          this.hideAllArrows();
        }
        this.updateUI();
      }

      startAIDetection() {
        // 清除現有的檢測循環
        if (this.detectionLoopId) {
          cancelAnimationFrame(this.detectionLoopId);
          this.detectionLoopId = null;
        }

        console.log('啟動 AI 檢測循環...');

        const detectFrame = async () => {
          if (!this.isNavigating || !this.isIndoorMode || !this.yoloDetector.isReady) {
            this.detectionLoopId = requestAnimationFrame(detectFrame);
            return;
          }

          try {
            // 確保影片元素已準備好
            if (this.yoloDetector.videoElement.readyState === 4) {
              const detections = await this.yoloDetector.detect(this.yoloDetector.videoElement);
              this.yoloDetector.draw(detections);
              this.provideAvoidanceGuidance(detections);
            }
          } catch (error) {
            console.error('檢測循環錯誤:', error);
          }

          this.detectionLoopId = requestAnimationFrame(detectFrame);
        };

        this.detectionLoopId = requestAnimationFrame(detectFrame);
      }

      stopAIDetection() {
        if (this.detectionLoopId) {
          cancelAnimationFrame(this.detectionLoopId);
          this.detectionLoopId = null;
        }
        if (this.yoloDetector.canvasCtx) {
          const canvas = this.yoloDetector.canvasElement;
          this.yoloDetector.canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // 隱藏除錯資訊
        document.getElementById('debugInfo').style.display = 'none';
      }

      provideAvoidanceGuidance(detections) {
        if (!this.isNavigating || !this.isIndoorMode) return;
        
        let closestDistance = Infinity;
        let advice = '路徑安全，請直行';
        let safeDirection = 'forward';
        this.hideAllArrows();

        const width = this.yoloDetector.videoElement.videoWidth || 640;
        const leftArea = width * 0.3;
        const rightArea = width * 0.7;

        let dangerLeft = 999;
        let dangerRight = 999;
        let dangerFront = 999;

        detections.forEach(box => {
          const centerX = (box.x1 + box.x2) / 2;
          
          if (box.distance < closestDistance) {
            closestDistance = box.distance;
          }

          if (box.distance < 4.0) {
            if (centerX < leftArea) {
              dangerLeft = Math.min(dangerLeft, box.distance);
            } else if (centerX > rightArea) {
              dangerRight = Math.min(dangerRight, box.distance);
            } else {
              dangerFront = Math.min(dangerFront, box.distance);
            }
          }
        });

        document.getElementById('closestObstacle').textContent = 
          closestDistance !== Infinity ? closestDistance.toFixed(1) + ' 公尺' : '-- 公尺';

        const STOP_THRESHOLD = 1.0;
        const YIELD_THRESHOLD = 2.0;

        if (closestDistance < STOP_THRESHOLD) {
          advice = '緊急！前方有障礙物，請立即停止！';
          safeDirection = 'stop';
        } else if (dangerFront < YIELD_THRESHOLD) {
          if (dangerLeft > dangerRight + 0.5) {
            advice = `前方障礙物 ${dangerFront.toFixed(1)}m，請向左`;
            safeDirection = 'left';
          } else if (dangerRight > dangerLeft + 0.5) {
            advice = `前方障礙物 ${dangerFront.toFixed(1)}m，請向右`;
            safeDirection = 'right';
          } else {
            advice = `前方有障礙物 ${dangerFront.toFixed(1)}m，請稍候`;
            safeDirection = 'stop';
          }
        } else if (dangerLeft < YIELD_THRESHOLD && dangerLeft < dangerRight) {
          advice = `左側障礙物 ${dangerLeft.toFixed(1)}m，請向右`;
          safeDirection = 'right';
        } else if (dangerRight < YIELD_THRESHOLD && dangerRight < dangerLeft) {
          advice = `右側障礙物 ${dangerRight.toFixed(1)}m，請向左`;
          safeDirection = 'left';
        } else {
          advice = '路徑安全，請直行';
          safeDirection = 'forward';
        }
        
        document.getElementById('avoidanceAdvice').textContent = advice;
        
        // 顯示方向箭頭
        document.getElementById('arrowLeft').classList.toggle('active', safeDirection === 'left');
        document.getElementById('arrowRight').classList.toggle('active', safeDirection === 'right');
        document.getElementById('arrowForward').classList.toggle('active', safeDirection === 'forward');

        // 語音頻率控制
        const now = Date.now();
        let shouldSpeak = false;

        if (safeDirection === 'stop' && closestDistance < STOP_THRESHOLD) {
          shouldSpeak = true;
        } else if (safeDirection !== 'forward' && closestDistance < YIELD_THRESHOLD) {
          if (now - this.lastSpeakTime > this.speakCooldown || this.lastSpokenAdvice !== advice) {
            shouldSpeak = true;
          }
        }

        if (shouldSpeak) {
          this.speak(advice);
          this.lastSpeakTime = now;
          this.lastSpokenAdvice = advice;
        }
      }
      
      hideAllArrows() {
        document.getElementById('arrowLeft').classList.remove('active');
        document.getElementById('arrowRight').classList.remove('active');
        document.getElementById('arrowForward').classList.remove('active');
      }

      async startNavigation() {
        this.isNavigating = true;
        this.updateSystemStatus('導航中');
        
        try {
          await this.initializeCamera();
          if (this.isIndoorMode) {
            this.speak('室內避障模式啟動，開始 AI 視覺分析');
            this.startAIDetection();
          } else {
            this.speak('室外導航啟動');
            this.startGPSTracking();
          }
        } catch (error) {
          console.warn('導航啟動失敗:', error);
          this.speak('啟動失敗: ' + error.message);
          this.isNavigating = false;
          this.updateSystemStatus('啟動失敗');
        }
        
        this.updateUI();
      }

      stopNavigation() {
        this.isNavigating = false;
        this.isFollowing = false;
        
        if (this.gpsWatchId) {
          navigator.geolocation.clearWatch(this.gpsWatchId);
          this.gpsWatchId = null;
        }
        
        this.stopAIDetection();
        this.updateSystemStatus('已停止');
        this.speak('導航已停止');
        this.hideTrackingIndicator();
        this.hideAllArrows();
        this.updateUI();
      }

      loadHomePosition() {
        const savedHome = localStorage.getItem('homePosition');
        if (savedHome) {
          this.homePosition = JSON.parse(savedHome);
          this.updateHomeInfo();
        }
      }

      updateSystemStatus(status) {
        document.getElementById('systemStatus').textContent = status;
      }

      updateHomeInfo() {
        // 簡化的家庭位置更新
      }

      showTrackingIndicator() {
        document.getElementById('trackingIndicator').classList.add('active');
      }

      hideTrackingIndicator() {
        document.getElementById('trackingIndicator').classList.remove('active');
      }

      updateUI() {
        const startBtn = document.getElementById('btnStart');
        const followBtn = document.getElementById('btnFollow');
        const stopBtn = document.getElementById('btnStop');
        
        startBtn.textContent = this.isNavigating ? '停止導航' : '開始導航';
        startBtn.classList.toggle('btn-danger', this.isNavigating);
        startBtn.classList.toggle('btn-primary', !this.isNavigating);
        
        followBtn.textContent = this.isFollowing ? '停止跟隨' : '人員跟隨';
        followBtn.disabled = !this.isNavigating || this.isIndoorMode;

        stopBtn.disabled = !this.isNavigating;
      }
      
      speak(message) {
        if (this.voiceEnabled && window.speechSynthesis) {
          window.speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(message);
          utterance.lang = 'zh-TW';
          utterance.rate = 0.8;
          window.speechSynthesis.speak(utterance);
        }
        document.getElementById('voiceAlert').textContent = message;
      }
      
      toggleNavigation() {
        if (this.isNavigating) {
          this.stopNavigation();
        } else {
          this.startNavigation();
        }
      }

      togglePersonFollowing() {
        if (!this.isNavigating) {
          this.speak('請先啟動導航');
          return;
        }
        
        if (this.isIndoorMode) {
          this.speak('室內模式下無法使用人員跟隨');
          return;
        }
        
        this.isFollowing = !this.isFollowing;
        
        if (this.isFollowing) {
          this.speak('人員跟隨啟動');
          this.showTrackingIndicator();
        } else {
          this.speak('人員跟隨停止');
          this.hideTrackingIndicator();
        }
        
        this.updateUI();
      }

      emergencyAlert() {
        this.speak('緊急求助已發送！位置信息已傳送給緊急聯絡人');
      }

      showHomeSetup() {
        this.speak('設定家的位置功能');
      }

      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      async initializeCamera() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('您的瀏覽器不支援相機功能');
        }
        
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'environment',
              width: { ideal: 640 },
              height: { ideal: 480 }
            }
          });
          
          const video = document.getElementById('video');
          video.srcObject = stream;
          
          return new Promise((resolve) => {
            video.onloadedmetadata = () => {
              video.play();
              console.log('相機初始化完成，解析度:', video.videoWidth, 'x', video.videoHeight);
              resolve();
            };
          });
        } catch (error) {
          throw new Error(`無法啟動相機: ${error.message}`);
        }
      }

      startGPSTracking() {
        if (!navigator.geolocation) {
          this.speak('您的裝置不支援 GPS 定位');
          return;
        }
        
        this.speak('GPS 定位已啟動');
      }
    }

    // 初始化系統
    const navSystem = new ObstacleAvoidanceSystem();

    // 事件監聽器
    document.getElementById('btnOutdoorMode').addEventListener('click', () => {
      navSystem.switchMode(false);
    });
    
    document.getElementById('btnIndoorMode').addEventListener('click', () => {
      navSystem.switchMode(true);
    });
    
    document.getElementById('btnStart').addEventListener('click', () => {
      navSystem.toggleNavigation();
    });
    
    document.getElementById('btnFollow').addEventListener('click', () => {
      navSystem.togglePersonFollowing();
    });
    
    document.getElementById('btnSetHome').addEventListener('click', () => {
      navSystem.showHomeSetup();
    });
    
    document.getElementById('btnStop').addEventListener('click', () => {
      navSystem.stopNavigation();
    });
    
    document.getElementById('btnEmergency').addEventListener('click', () => {
      navSystem.emergencyAlert();
    });

    // 啟動模型載入
    window.addEventListener('DOMContentLoaded', () => {
      navSystem.initializeSystem();
    });
  </script>
</body>
</html>