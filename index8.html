<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <title>🧭 盲人導航助手 - AI 避障</title>
  
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    /* CSS 樣式保持不變或略微簡化，以確保與新 JS 邏輯兼容 */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Microsoft JhengHei', sans-serif;
      background: linear-gradient(135deg, #0ea5e9, #6366f1);
      color: white;
      height: 100vh;
      padding: 0;
      overflow: hidden;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 0;
    }
    
    .header {
      text-align: center;
      padding: 12px 10px;
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      flex-shrink: 0;
    }
    
    .header h1 {
      font-size: 16px;
      margin-bottom: 2px;
    }
    
    .header .subtitle {
      font-size: 11px;
      opacity: 0.8;
    }
    
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 5px;
      padding: 5px;
      min-height: 0;
    }
    
    .camera-view {
      flex: 0 0 40vh; /* 增加相機畫面高度 */
      background: #000;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }
    
    .camera-view video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    /* 移除靜態的 safety-path 和 danger-zone，改用動態繪製 */
    
    .obstacle-marker {
      position: absolute;
      background: rgba(255, 255, 0, 0.8); /* 標記顏色改為黃色，更明顯 */
      border-radius: 4px;
      border: 2px solid #ff0000;
      color: #000;
      font-size: 10px;
      padding: 2px 4px;
      text-align: center;
      box-sizing: border-box;
      white-space: nowrap;
      transform: translate(-50%, -50%);
      animation: markerPulse 1.5s infinite;
      z-index: 10;
    }
    
    @keyframes markerPulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
      70% { box-shadow: 0 0 0 8px rgba(255, 0, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
    }
    
    .status-panel {
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 8px;
      backdrop-filter: blur(10px);
      flex-shrink: 0;
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 6px;
    }
    
    .status-item {
      text-align: center;
      padding: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
    }
    
    .status-label {
      font-size: 9px;
      opacity: 0.8;
      margin-bottom: 2px;
    }
    
    .status-value {
      font-size: 12px;
      font-weight: bold;
    }
    
    .voice-alert {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.5);
      border-radius: 6px;
      padding: 8px;
      text-align: center;
      min-height: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      flex-shrink: 0;
      overflow-wrap: break-word; /* 避免文字溢出 */
    }
    
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      flex-shrink: 0;
    }
    
    .btn {
      padding: 12px 6px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 44px;
    }
    
    .btn:active {
      transform: scale(0.95);
    }
    
    .btn-primary {
      background: #22c55e;
    }
    
    .btn-warning {
      background: #f59e0b;
    }
    
    .btn-danger {
      background: #ef4444;
    }
    
    .btn-secondary {
      background: rgba(255,255,255,0.2);
    }
    
    .btn-info {
      background: #3b82f6;
    }
    
    .btn-active {
      box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
    }
    
    .tracking-indicator, .direction-arrow, .distance-badge {
      position: absolute;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 9px;
      z-index: 5;
    }

    .tracking-indicator {
      top: 4px;
      right: 4px;
      display: none;
    }
    
    .tracking-indicator.active {
      display: block;
    }

    .direction-arrow {
      top: 4px;
      left: 4px;
      display: none;
    }
    
    .direction-arrow.active {
      display: block;
    }

    .distance-badge {
      bottom: 4px;
      left: 4px;
    }
    
    /* 模式選擇按鈕 */
    .mode-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 6px;
      flex-shrink: 0;
    }

    .mode-btn {
      padding: 10px 6px;
      border: none;
      border-radius: 8px;
      font-size: 11px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      background: rgba(255,255,255,0.2);
      min-height: 40px;
    }

    .mode-btn.active {
      background: #3b82f6;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
    }

    /* 緊急按鈕 */
    .emergency-section {
      margin-top: 6px;
      flex-shrink: 0;
    }

    .emergency-btn {
      width: 100%;
      padding: 12px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      min-height: 50px;
    }

    /* 避障指示器 */
    .avoidance-indicator {
      position: absolute;
      bottom: 4px;
      right: 4px;
      background: #f59e0b; /* 避障模式使用警告色 */
      color: white;
      padding: 6px 12px;
      border-radius: 15px;
      font-size: 10px;
      display: none;
      z-index: 5;
    }
    
    .avoidance-indicator.active {
      display: block;
    }

    /* 路徑建議箭頭 - 使用更具指示性的樣式 */
    .path-arrow {
      position: absolute;
      font-size: 40px;
      color: #22c55e;
      text-shadow: 0 0 10px #22c55e;
      font-weight: 900;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 10;
    }
    
    .path-arrow.active {
      opacity: 1;
    }
    
    .path-arrow.left {
      left: 15%;
      top: 50%;
      transform: translateY(-50%) rotate(180deg);
    }
    
    .path-arrow.right {
      right: 15%;
      top: 50%;
      transform: translateY(-50%) rotate(0deg);
    }
    
    .path-arrow.forward {
      left: 50%;
      top: 20%;
      transform: translateX(-50%) rotate(0deg);
    }

    /* 用於繪製 YOLO Bounding Box 的 Canvas */
    #bboxCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🧭 盲人導航助手</h1>
      <div class="subtitle">智能避障 · AI 視覺分析</div>
    </div>
    
    <div class="main-content">
      <div class="mode-selector">
        <button class="mode-btn active" id="btnOutdoorMode">室外導航 (GPS)</button>
        <button class="mode-btn" id="btnIndoorMode">室內避障 (AI 視覺)</button>
      </div>

      <div class="camera-view">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="bboxCanvas"></canvas>
        <div class="overlay">
          <div id="obstacleMarkers"></div>
          
          <div class="path-arrow left" id="arrowLeft">👈</div>
          <div class="path-arrow right" id="arrowRight">👉</div>
          <div class="path-arrow forward" id="arrowForward">👆</div>
        </div>
        
        <div class="tracking-indicator" id="trackingIndicator">
          👤 跟隨中 <span id="trackingDistance">0m</span>
        </div>
        <div class="direction-arrow" id="directionArrow">
          🏠 <span id="homeDirection">--</span>
        </div>
        <div class="distance-badge" id="distanceBadge">
          📍 距家: <span id="homeDistance">--</span>
        </div>
        <div class="avoidance-indicator" id="avoidanceIndicator">
          ⚠️ AI 模型準備中...
        </div>
      </div>
      
      <div class="control-section">
        <div class="status-panel">
          <div class="status-grid">
            <div class="status-item">
              <div class="status-label">系統狀態</div>
              <div class="status-value" id="systemStatus">載入模型中...</div>
            </div>
            <div class="status-item">
              <div class="status-label">避障建議</div>
              <div class="status-value" id="avoidanceAdvice">--</div>
            </div>
            <div class="status-item">
              <div class="status-label">最近障礙物</div>
              <div class="status-value" id="closestObstacle">-- 公尺</div>
            </div>
            <div class="status-item">
              <div class="status-label">AI 幀率</div>
              <div class="status-value" id="safetyScore">-- FPS</div>
            </div>
          </div>
          
          <div class="voice-alert" id="voiceAlert">
            AI 模型載入中，請稍候...
          </div>
        </div>
        
        <div class="controls">
          <button class="btn btn-primary" id="btnStart" disabled>開始導航</button>
          <button class="btn btn-warning" id="btnFollow" disabled>人員跟隨</button>
          <button class="btn btn-info" id="btnSetHome">📍 設定家的位置</button>
          <button class="btn btn-danger" id="btnStop" disabled>停止</button>
        </div>

        <div class="emergency-section">
          <button class="emergency-btn" id="btnEmergency">🆘 緊急求助</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // YOLOv8 物件類別名稱 (COCO dataset) - 請根據您訓練的模型調整
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorbike', 'aeroplane', 'bus', 'train', 'truck', 'boat', 
      'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 
      'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 
      'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 
      'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 
      'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 
      'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 
      'sofa', 'pottedplant', 'bed', 'diningtable', 'toilet', 'tvmonitor', 'laptop', 'mouse', 
      'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 
      'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];
    
    // 預期 YOLOv8 模型輸入尺寸
    const MODEL_INPUT_SIZE = 640; 

    /**
     * @class YOLOv8Detector
     * 處理 YOLOv8 模型載入、推理和結果解析
     */
    class YOLOv8Detector {
      constructor(modelPath = 'yolov8n.onnx') {
        this.modelPath = modelPath;
        this.session = null;
        this.isReady = false;
        this.videoElement = document.getElementById('video');
        this.canvasElement = document.getElementById('bboxCanvas');
        this.canvasCtx = this.canvasElement.getContext('2d');
        this.lastInferenceTime = Date.now();
      }

      async loadModel() {
        try {
          // 使用 ONNX Runtime Web 載入 ONNX 模型
          this.session = await ort.InferenceSession.create(this.modelPath, {
            executionProviders: ['webgl'], // 優先使用 WebGL 以加速計算
            freeDimensionOverrides: { input_size: MODEL_INPUT_SIZE },
          });

          this.isReady = true;
          return true;
        } catch (error) {
          console.error('YOLOv8 模型載入失敗:', error);
          return false;
        }
      }

      async detect(video) {
        if (!this.isReady) return [];

        const start = Date.now();

        // 1. 圖像預處理
        const tf_image = tf.browser.fromPixels(video);
        const resized = tf.image.resizeBilinear(tf_image, [MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
        const normalized = resized.div(255.0);
        const batched = normalized.expandDims(0);
        const inputTensor = batched.transpose([0, 3, 1, 2]); // NCHW 格式

        // 2. 模型推理
        const inputMap = {};
        inputMap[this.session.inputNames[0]] = new ort.Tensor('float32', inputTensor.dataSync(), [1, 3, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
        
        const results = await this.session.run(inputMap);
        const outputTensor = results[this.session.outputNames[0]].data;

        tf_image.dispose();
        resized.dispose();
        normalized.dispose();
        batched.dispose();
        inputTensor.dispose();
        
        // 3. 解析輸出 (YOLOv8 NMS 前的輸出)
        const detections = this._processOutput(outputTensor, video.videoWidth, video.videoHeight);
        
        // 4. 計算 FPS
        const end = Date.now();
        const inferenceTime = end - start;
        const fps = (1000 / inferenceTime).toFixed(1);
        document.getElementById('safetyScore').textContent = fps + ' FPS';
        
        return detections;
      }
      
      /**
       * 處理 YOLOv8 的原始輸出並進行 NMS (非極大值抑制)
       * 注意: 這是一個簡化的 NMS 實現，真實的 YOLOv8 輸出解析邏輯複雜得多。
       * 為了完整性，這裡使用一個簡化的方法。
       */
      _processOutput(output, originalWidth, originalHeight, conf_threshold = 0.5, iou_threshold = 0.45) {
        const [numClasses, numBoxes] = [CLASS_NAMES.length, 8400]; // 假設為 8400 個錨點，需根據實際模型輸出調整
        const stride = numClasses + 4;
        const boxes = [];
        
        // 1. 解析原始輸出 (簡化版)
        for (let i = 0; i < numBoxes; i++) {
            const row = output.subarray(i * stride, (i + 1) * stride);
            const scores = row.subarray(4); // 類別分數從第 5 個元素開始

            // 尋找最大分數的類別
            let maxScore = -1;
            let classId = -1;
            for (let j = 0; j < numClasses; j++) {
                if (scores[j] > maxScore) {
                    maxScore = scores[j];
                    classId = j;
                }
            }

            // 應用置信度門檻
            if (maxScore > conf_threshold) {
                // YOLOv8 輸出格式通常是 [cx, cy, w, h, class_scores...]
                const cx = row[0];
                const cy = row[1];
                const w = row[2];
                const h = row[3];

                // 轉換到 [x1, y1, x2, y2] 格式，並進行縮放
                const x1 = (cx - w / 2) * originalWidth / MODEL_INPUT_SIZE;
                const y1 = (cy - h / 2) * originalHeight / MODEL_INPUT_SIZE;
                const x2 = (cx + w / 2) * originalWidth / MODEL_INPUT_SIZE;
                const y2 = (cy + h / 2) * originalHeight / MODEL_INPUT_SIZE;

                boxes.push({
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                    w: x2 - x1,
                    h: y2 - y1,
                    score: maxScore,
                    classId: classId,
                    className: CLASS_NAMES[classId],
                    // 模擬距離：假設距離與高度成反比 (簡化深度估計)
                    distance: this._estimateDistance(h) 
                });
            }
        }
        
        // 2. 進行 NMS (非極大值抑制)
        // 這裡需要一個完整的 NMS 算法，但由於篇幅限制，我們將依賴一個簡單的排序和篩選。
        // **在實際部署時，您應使用一個優化的 NMS 實現。**
        boxes.sort((a, b) => b.score - a.score);
        return boxes.slice(0, 5); // 只取最可靠的前 5 個物件
      }
      
      /**
       * 簡化深度估計 (Distance Estimation)
       * 假設物體在畫面中的高度 (h) 與實際距離成反比。
       * 這裡需要根據您的相機和場景進行校準。
       */
      _estimateDistance(h) {
        // 假設一個成年人 (高 1.7m) 在畫面中佔 100 像素時，距離為 5 公尺
        // K = 1.7m * 5m = 8.5 (焦距常數，簡化)
        // 實際距離 D = (K * H_real) / H_pixel
        // 這裡我們直接使用畫面高度 h
        const videoHeight = this.videoElement.videoHeight || 480; 
        if (h <= 0) return 999;
        
        // 根據物體在畫面中的相對高度來估計距離 (h越大，距離越近)
        const normalizedHeight = h / videoHeight;
        
        // 調整這個公式以匹配您的相機視野 (FOV)
        // 距離 (公尺) = 5 / (畫面相對高度)
        return Math.min(20, 5 / normalizedHeight); 
      }

      /**
       * 繪製 Bounding Box
       */
      draw(detections) {
        // 將 Canvas 尺寸與 Video 尺寸同步
        this.canvasElement.width = this.videoElement.videoWidth;
        this.canvasElement.height = this.videoElement.videoHeight;
        this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);

        detections.forEach(box => {
            const { x1, y1, w, h, className, distance } = box;
            
            // 根據距離設置顏色
            let color = '#22c55e'; // 綠色 (遠)
            if (distance < 3.0) color = '#f59e0b'; // 黃色 (中)
            if (distance < 1.0) color = '#ef4444'; // 紅色 (近)

            this.canvasCtx.strokeStyle = color;
            this.canvasCtx.lineWidth = 2;
            this.canvasCtx.strokeRect(x1, y1, w, h);

            this.canvasCtx.fillStyle = color;
            this.canvasCtx.font = '12px Arial';
            const label = `${className} ${distance.toFixed(1)}m`;
            this.canvasCtx.fillRect(x1, y1 - 15, this.canvasCtx.measureText(label).width + 8, 15);
            this.canvasCtx.fillStyle = '#000';
            this.canvasCtx.fillText(label, x1 + 4, y1 - 3);
        });
      }
    }


    // --- 智能避障導航系統 (更新) ---
    class ObstacleAvoidanceSystem {
      constructor() {
        // ... (其他屬性保持不變)
        this.yoloDetector = new YOLOv8Detector('yolov8n.onnx'); // 實例化 YOLO 檢測器
        this.detectionLoopId = null; // 儲存檢測迴圈 ID
        this.voiceEnabled = true;
        this.isNavigating = false;
        this.isFollowing = false;
        this.isIndoorMode = false;
        this.homePosition = null;
        this.currentPosition = null;
        this.gpsWatchId = null;
        
        this.loadHomePosition();
        this.initButtons(); // 新增初始化按鈕狀態
      }

      // 初始化按鈕狀態
      initButtons() {
        document.getElementById('btnStart').disabled = true;
        document.getElementById('btnFollow').disabled = true;
        document.getElementById('btnStop').disabled = true;
      }

      // ... (其他方法保持不變)

      // 載入模型並更新狀態
      async initializeSystem() {
        this.updateSystemStatus('載入 AI 模型...');
        const success = await this.yoloDetector.loadModel();
        
        if (success) {
            this.updateSystemStatus('準備就緒');
            document.getElementById('voiceAlert').textContent = 'AI 模型載入成功，請點擊開始導航';
            document.getElementById('avoidanceIndicator').textContent = '✅ AI 視覺準備就緒';
            document.getElementById('avoidanceIndicator').classList.add('active');
            document.getElementById('btnStart').disabled = false;
            document.getElementById('btnStop').disabled = false;
        } else {
            this.updateSystemStatus('模型載入失敗');
            document.getElementById('voiceAlert').textContent = 'AI 模型載入失敗，請檢查檔案路徑 (yolov8n.onnx)';
            document.getElementById('avoidanceIndicator').textContent = '❌ AI 視覺錯誤';
        }
      }

      // 切換模式
      switchMode(isIndoor) {
        this.isIndoorMode = isIndoor;
        
        document.getElementById('btnOutdoorMode').classList.toggle('active', !isIndoor);
        document.getElementById('btnIndoorMode').classList.toggle('active', isIndoor);
        
        if (isIndoor) {
          this.speak('已切換到室內避障模式');
          document.getElementById('avoidanceIndicator').classList.add('active');
          document.getElementById('btnFollow').disabled = true;
          this.startAIDetection(); // 切換時啟動 AI
        } else {
          this.speak('已切換到室外導航模式');
          this.stopAIDetection(); // 停止 AI 視覺
          document.getElementById('avoidanceIndicator').classList.remove('active');
          this.hideAllArrows();
        }
        this.updateUI();
      }

      // --- 啟動/停止 AI 視覺核心邏輯 ---
      startAIDetection() {
        if (this.detectionLoopId) return; // 避免重複啟動

        const loop = async () => {
          if (this.isNavigating && this.isIndoorMode && this.yoloDetector.isReady && this.yoloDetector.videoElement.readyState === 4) {
            const detections = await this.yoloDetector.detect(this.yoloDetector.videoElement);
            this.yoloDetector.draw(detections); // 繪製 BBox
            this.provideAvoidanceGuidance(detections); // 提供避障建議
          }
          this.detectionLoopId = requestAnimationFrame(loop);
        };
        
        this.detectionLoopId = requestAnimationFrame(loop);
      }

      stopAIDetection() {
        if (this.detectionLoopId) {
          cancelAnimationFrame(this.detectionLoopId);
          this.detectionLoopId = null;
        }
        this.yoloDetector.canvasCtx.clearRect(0, 0, this.yoloDetector.canvasElement.width, this.yoloDetector.canvasElement.height);
      }

      // --- 基於 AI 檢測結果的避障指導 ---
      provideAvoidanceGuidance(detections) {
        if (!this.isNavigating || !this.isIndoorMode) return;
        
        let closestDistance = Infinity;
        let advice = '路徑安全，請直行';
        let safeDirection = 'forward'; // 預設直行
        this.hideAllArrows();

        // 劃分畫面區域 (簡化為左、中、右 1/3 區域)
        const w = this.yoloDetector.videoElement.videoWidth;
        const left_area = w / 3;
        const right_area = w * 2 / 3;

        let danger_left = 999;
        let danger_right = 999;
        let danger_front = 999;

        detections.forEach(box => {
            const center_x = (box.x1 + box.x2) / 2;
            
            // 更新最近障礙物距離
            if (box.distance < closestDistance) {
                closestDistance = box.distance;
            }

            // 根據中心點劃分區域危險度
            if (box.distance < 3.0) { // 只考慮 3 公尺內的危險
                if (center_x < left_area) {
                    danger_left = Math.min(danger_left, box.distance);
                } else if (center_x > right_area) {
                    danger_right = Math.min(danger_right, box.distance);
                } else {
                    danger_front = Math.min(danger_front, box.distance);
                }
            }
        });

        document.getElementById('closestObstacle').textContent = 
            closestDistance !== Infinity ? closestDistance.toFixed(1) + ' 公尺' : '-- 公尺';

        const STOP_THRESHOLD = 0.8;
        const YIELD_THRESHOLD = 1.5;

        // 1. 緊急停止
        if (closestDistance < STOP_THRESHOLD) {
            advice = '緊急！前方有障礙物，請立即停止！';
            this.speak(advice);
            safeDirection = 'stop';
        } 
        // 2. 前方障礙物避讓
        else if (danger_front < YIELD_THRESHOLD) {
            if (danger_left > danger_right) { // 左邊較遠
                advice = `前方有障礙物 (${danger_front.toFixed(1)}m)，請向左避開`;
                safeDirection = 'left';
            } else if (danger_right > danger_left) { // 右邊較遠
                advice = `前方有障礙物 (${danger_front.toFixed(1)}m)，請向右避開`;
                safeDirection = 'right';
            } else { // 兩邊都危險或一樣
                advice = `前方通道受阻 (${danger_front.toFixed(1)}m)，請減速`;
                safeDirection = 'forward'; // 提醒減速，但箭頭仍指向前方
            }
        } 
        // 3. 保持居中 (道路兩側辨識優化)
        else if (danger_left < YIELD_THRESHOLD && danger_left < danger_right * 0.9) { // 左側太近
            advice = `左側有障礙物 (${danger_left.toFixed(1)}m)，請向右調整`;
            safeDirection = 'right';
        } else if (danger_right < YIELD_THRESHOLD && danger_right < danger_left * 0.9) { // 右側太近
            advice = `右側有障礙物 (${danger_right.toFixed(1)}m)，請向左調整`;
            safeDirection = 'left';
        } 
        // 4. 安全直行
        else {
            advice = '路徑安全，請直行';
            safeDirection = 'forward';
        }
        
        // 更新 UI 顯示
        document.getElementById('avoidanceAdvice').textContent = advice;
        if (safeDirection === 'left') document.getElementById('arrowLeft').classList.add('active');
        if (safeDirection === 'right') document.getElementById('arrowRight').classList.add('active');
        if (safeDirection === 'forward') document.getElementById('arrowForward').classList.add('active');

        // 語音提示 (只在非安全狀態下提示，避免過度干擾)
        if (safeDirection !== 'forward' && closestDistance < 3.0) {
            this.speak(advice);
        }
      }
      
      // 隱藏所有箭頭
      hideAllArrows() {
        document.getElementById('arrowLeft').classList.remove('active');
        document.getElementById('arrowRight').classList.remove('active');
        document.getElementById('arrowForward').classList.remove('active');
      }

      // ... (其他導航控制方法 - startNavigation, stopNavigation 等)

      async startNavigation() {
        if (!this.homePosition && !this.isIndoorMode) {
          this.speak('請先設定家的位置');
          return;
        }
        
        this.isNavigating = true;
        this.updateSystemStatus('導航中');
        
        try {
          await this.initializeCamera();
        } catch (error) {
          console.warn('相機初始化失敗:', error);
          this.speak('相機啟動失敗，請檢查權限');
          return;
        }
        
        if (this.isIndoorMode) {
          this.speak('室內避障模式啟動，開始 AI 視覺分析');
          this.startAIDetection(); 
        } else {
          this.speak('室外導航啟動');
          this.startGPSTracking();
        }
        
        this.updateUI();
      }

      stopNavigation() {
        this.isNavigating = false;
        this.isFollowing = false;
        
        if (this.gpsWatchId) {
          navigator.geolocation.clearWatch(this.gpsWatchId);
          this.gpsWatchId = null;
        }
        
        this.stopAIDetection(); // 停止 AI 檢測
        
        this.updateSystemStatus('已停止');
        this.speak('導航已停止');
        this.hideTrackingIndicator();
        this.hideAllArrows();
        this.updateUI();
      }

      // ... (省略未修改的輔助方法: initializeCamera, startGPSTracking, calculateDistance, speak, updateUI 等)
      
      // 載入家的位置
      loadHomePosition() {
        const savedHome = localStorage.getItem('homePosition');
        if (savedHome) {
          this.homePosition = JSON.parse(savedHome);
          this.updateHomeInfo();
          document.getElementById('voiceAlert').textContent = '家的位置已載入';
        }
      }

      updateSystemStatus(status) {
        document.getElementById('systemStatus').textContent = status;
      }

      updateHomeInfo() {
        if (this.homePosition && this.currentPosition) {
          // ... (距離計算邏輯)
          document.getElementById('distanceBadge').style.display = 'block';
          document.getElementById('directionArrow').classList.add('active');
        } else {
          document.getElementById('distanceBadge').style.display = 'none';
          document.getElementById('directionArrow').classList.remove('active');
        }
      }

      showTrackingIndicator() {
        document.getElementById('trackingIndicator').classList.add('active');
      }

      hideTrackingIndicator() {
        document.getElementById('trackingIndicator').classList.remove('active');
      }

      updateUI() {
        const startBtn = document.getElementById('btnStart');
        const followBtn = document.getElementById('btnFollow');
        const stopBtn = document.getElementById('btnStop');
        
        startBtn.textContent = this.isNavigating ? '停止導航' : '開始導航';
        startBtn.classList.toggle('btn-danger', this.isNavigating);
        startBtn.classList.toggle('btn-primary', !this.isNavigating);
        
        followBtn.textContent = this.isFollowing ? '停止跟隨' : '人員跟隨';
        followBtn.disabled = !this.isNavigating || this.isIndoorMode;

        stopBtn.disabled = !this.isNavigating && !this.yoloDetector.isReady;
      }
      
      speak(message) {
        if (this.voiceEnabled && window.speechSynthesis) {
          window.speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(message);
          utterance.lang = 'zh-TW';
          utterance.rate = 0.8;
          window.speechSynthesis.speak(utterance);
        }
        document.getElementById('voiceAlert').textContent = message;
      }
      
      toggleNavigation() {
        if (this.isNavigating) {
          this.stopNavigation();
        } else {
          this.startNavigation();
        }
      }

      togglePersonFollowing() {
        if (!this.isNavigating) {
          this.speak('請先啟動導航');
          return;
        }
        
        if (this.isIndoorMode) {
          this.speak('室內模式下無法使用人員跟隨');
          return;
        }
        
        this.isFollowing = !this.isFollowing;
        
        if (this.isFollowing) {
          this.speak('人員跟隨啟動，正在尋找引導者');
          this.showTrackingIndicator();
        } else {
          this.speak('人員跟隨停止');
          this.hideTrackingIndicator();
        }
        
        this.updateUI();
      }

      emergencyAlert() {
        this.speak('緊急求助已發送！位置信息已傳送給緊急聯絡人');
      }

      showHomeSetup() {
        this.speak('請走到家門口，在室外設定家的位置');
        // 簡化設定流程
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              this.homePosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy
              };
              localStorage.setItem('homePosition', JSON.stringify(this.homePosition));
              this.updateHomeInfo();
              this.speak('家的位置設定成功');
            },
            (error) => {
              this.speak('GPS定位失敗，請確保在室外操作');
            }
          );
        }
      }

      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }
    }


    // 初始化系統
    const navSystem = new ObstacleAvoidanceSystem();

    // 事件監聽器
    document.getElementById('btnOutdoorMode').addEventListener('click', () => {
      navSystem.switchMode(false);
    });
    
    document.getElementById('btnIndoorMode').addEventListener('click', () => {
      navSystem.switchMode(true);
    });
    
    document.getElementById('btnStart').addEventListener('click', () => {
      navSystem.toggleNavigation();
    });
    
    document.getElementById('btnFollow').addEventListener('click', () => {
      navSystem.togglePersonFollowing();
    });
    
    document.getElementById('btnSetHome').addEventListener('click', () => {
      navSystem.showHomeSetup();
    });
    
    document.getElementById('btnStop').addEventListener('click', () => {
      navSystem.stopNavigation();
    });
    
    document.getElementById('btnEmergency').addEventListener('click', () => {
      navSystem.emergencyAlert();
    });

    // 啟動模型載入
    window.addEventListener('DOMContentLoaded', () => {
      navSystem.initializeSystem();
    });
  </script>
</body>
</html>