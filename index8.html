<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0ea5e9" />
  <title>🧭 盲人導航助手 - AI 避障</title>
  
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Microsoft JhengHei', sans-serif;
      background: linear-gradient(135deg, #0ea5e9, #6366f1);
      color: white;
      height: 100vh;
      padding: 0;
      overflow: hidden;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 0;
    }
    
    .header {
      text-align: center;
      padding: 12px 10px;
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      flex-shrink: 0;
    }
    
    .header h1 {
      font-size: 16px;
      margin-bottom: 2px;
    }
    
    .header .subtitle {
      font-size: 11px;
      opacity: 0.8;
    }
    
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 5px;
      padding: 5px;
      min-height: 0;
      overflow-y: auto; /* 添加滾動以確保所有內容可見 */
    }
    
    .camera-view {
      flex: 0 0 35vh; /* 調整相機畫面高度，為下方按鈕留出空間 */
      background: #000;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }
    
    .camera-view video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .obstacle-marker {
      position: absolute;
      background: rgba(255, 255, 0, 0.8);
      border-radius: 4px;
      border: 2px solid #ff0000;
      color: #000;
      font-size: 10px;
      padding: 2px 4px;
      text-align: center;
      box-sizing: border-box;
      white-space: nowrap;
      transform: translate(-50%, -50%);
      animation: markerPulse 1.5s infinite;
      z-index: 10;
    }
    
    @keyframes markerPulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
      70% { box-shadow: 0 0 0 8px rgba(255, 0, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
    }
    
    .status-panel {
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 8px;
      backdrop-filter: blur(10px);
      flex-shrink: 0;
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 6px;
    }
    
    .status-item {
      text-align: center;
      padding: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
    }
    
    .status-label {
      font-size: 9px;
      opacity: 0.8;
      margin-bottom: 2px;
    }
    
    .status-value {
      font-size: 12px;
      font-weight: bold;
    }
    
    .voice-alert {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.5);
      border-radius: 6px;
      padding: 8px;
      text-align: center;
      min-height: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      flex-shrink: 0;
      overflow-wrap: break-word;
    }
    
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      flex-shrink: 0;
      margin-bottom: 6px; /* 添加底部間距 */
    }
    
    .btn {
      padding: 12px 6px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 44px;
    }
    
    .btn:active {
      transform: scale(0.95);
    }
    
    .btn-primary {
      background: #22c55e;
    }
    
    .btn-warning {
      background: #f59e0b;
    }
    
    .btn-danger {
      background: #ef4444;
    }
    
    .btn-secondary {
      background: rgba(255,255,255,0.2);
    }
    
    .btn-info {
      background: #3b82f6;
    }
    
    .btn-active {
      box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
    }
    
    .tracking-indicator, .direction-arrow, .distance-badge {
      position: absolute;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 9px;
      z-index: 5;
    }

    .tracking-indicator {
      top: 4px;
      right: 4px;
      display: none;
    }
    
    .tracking-indicator.active {
      display: block;
    }

    .direction-arrow {
      top: 4px;
      left: 4px;
      display: none;
    }
    
    .direction-arrow.active {
      display: block;
    }

    .distance-badge {
      bottom: 4px;
      left: 4px;
    }
    
    /* 模式選擇按鈕 */
    .mode-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 6px;
      flex-shrink: 0;
    }

    .mode-btn {
      padding: 10px 6px;
      border: none;
      border-radius: 8px;
      font-size: 11px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      background: rgba(255,255,255,0.2);
      min-height: 40px;
    }

    .mode-btn.active {
      background: #3b82f6;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
    }

    /* 緊急按鈕 */
    .emergency-section {
      margin-top: 6px;
      flex-shrink: 0;
    }

    .emergency-btn {
      width: 100%;
      padding: 12px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      min-height: 50px;
    }

    /* 避障指示器 */
    .avoidance-indicator {
      position: absolute;
      bottom: 4px;
      right: 4px;
      background: #f59e0b;
      color: white;
      padding: 6px 12px;
      border-radius: 15px;
      font-size: 10px;
      display: none;
      z-index: 5;
    }
    
    .avoidance-indicator.active {
      display: block;
    }

    /* 路徑建議箭頭 */
    .path-arrow {
      position: absolute;
      font-size: 40px;
      color: #22c55e;
      text-shadow: 0 0 10px #22c55e;
      font-weight: 900;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 10;
    }
    
    .path-arrow.active {
      opacity: 1;
    }
    
    .path-arrow.left {
      left: 15%;
      top: 50%;
      transform: translateY(-50%) rotate(180deg);
    }
    
    .path-arrow.right {
      right: 15%;
      top: 50%;
      transform: translateY(-50%) rotate(0deg);
    }
    
    .path-arrow.forward {
      left: 50%;
      top: 20%;
      transform: translateX(-50%) rotate(0deg);
    }

    /* 用於繪製 YOLO Bounding Box 的 Canvas */
    #bboxCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
    }

    /* 控制區域滾動 */
    .control-section {
      flex-shrink: 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🧭 盲人導航助手</h1>
      <div class="subtitle">智能避障 · AI 視覺分析</div>
    </div>
    
    <div class="main-content">
      <div class="mode-selector">
        <button class="mode-btn active" id="btnOutdoorMode">室外導航 (GPS)</button>
        <button class="mode-btn" id="btnIndoorMode">室內避障 (AI 視覺)</button>
      </div>

      <div class="camera-view">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="bboxCanvas"></canvas>
        <div class="overlay">
          <div id="obstacleMarkers"></div>
          
          <div class="path-arrow left" id="arrowLeft">👈</div>
          <div class="path-arrow right" id="arrowRight">👉</div>
          <div class="path-arrow forward" id="arrowForward">👆</div>
        </div>
        
        <div class="tracking-indicator" id="trackingIndicator">
          👤 跟隨中 <span id="trackingDistance">0m</span>
        </div>
        <div class="direction-arrow" id="directionArrow">
          🏠 <span id="homeDirection">--</span>
        </div>
        <div class="distance-badge" id="distanceBadge">
          📍 距家: <span id="homeDistance">--</span>
        </div>
        <div class="avoidance-indicator" id="avoidanceIndicator">
          ⚠️ AI 模型載入中...
        </div>
      </div>
      
      <div class="control-section">
        <div class="status-panel">
          <div class="status-grid">
            <div class="status-item">
              <div class="status-label">系統狀態</div>
              <div class="status-value" id="systemStatus">載入模型中...</div>
            </div>
            <div class="status-item">
              <div class="status-label">避障建議</div>
              <div class="status-value" id="avoidanceAdvice">--</div>
            </div>
            <div class="status-item">
              <div class="status-label">最近障礙物</div>
              <div class="status-value" id="closestObstacle">-- 公尺</div>
            </div>
            <div class="status-item">
              <div class="status-label">AI 幀率</div>
              <div class="status-value" id="safetyScore">-- FPS</div>
            </div>
          </div>
          
          <div class="voice-alert" id="voiceAlert">
            AI 模型載入中，請稍候...
          </div>
        </div>
        
        <div class="controls">
          <button class="btn btn-primary" id="btnStart" disabled>開始導航</button>
          <button class="btn btn-warning" id="btnFollow" disabled>人員跟隨</button>
          <button class="btn btn-info" id="btnSetHome">📍 設定家的位置</button>
          <button class="btn btn-danger" id="btnStop" disabled>停止</button>
        </div>

        <div class="emergency-section">
          <button class="emergency-btn" id="btnEmergency">🆘 緊急求助</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // YOLOv8 物件類別名稱 (COCO dataset)
    const CLASS_NAMES = [
      'person', 'bicycle', 'car', 'motorbike', 'aeroplane', 'bus', 'train', 'truck', 'boat', 
      'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 
      'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 
      'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 
      'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 
      'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 
      'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 
      'sofa', 'pottedplant', 'bed', 'diningtable', 'toilet', 'tvmonitor', 'laptop', 'mouse', 
      'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 
      'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];
    
    const MODEL_INPUT_SIZE = 640;

    /**
     * @class YOLOv8Detector
     * 修復版 YOLOv8 檢測器，包含模擬模式
     */
    class YOLOv8Detector {
      constructor(modelPath = 'yolov8n.onnx') {
        this.modelPath = modelPath;
        this.session = null;
        this.isReady = false;
        this.videoElement = document.getElementById('video');
        this.canvasElement = document.getElementById('bboxCanvas');
        this.canvasCtx = this.canvasElement.getContext('2d');
        this.lastInferenceTime = Date.now();
        this.useSimulation = true; // 啟用模擬模式，因為真實模型可能無法載入
        this.simulationObjects = [];
      }

      async loadModel() {
        document.getElementById('systemStatus').textContent = '嘗試載入 AI 模型...';
        document.getElementById('voiceAlert').textContent = `正在從 ${this.modelPath} 載入模型...`;
        
        if (this.useSimulation) {
          // 使用模擬模式
          setTimeout(() => {
            this.isReady = true;
            document.getElementById('systemStatus').textContent = 'AI 模擬模式就緒';
            document.getElementById('voiceAlert').textContent = 'AI 模擬模式已啟動，可以開始測試避障功能';
            document.getElementById('avoidanceIndicator').textContent = '🎮 AI 模擬模式';
            document.getElementById('avoidanceIndicator').classList.add('active');
            document.getElementById('btnStart').disabled = false;
            document.getElementById('btnStop').disabled = false;
          }, 1500);
          return true;
        }

        // 原始載入邏輯（保留但不使用）
        const providers = ['webgl', 'wasm']; 
        let success = false;

        for (const provider of providers) {
          try {
            if (typeof ort === 'undefined' || !ort.InferenceSession) {
                throw new Error("ONNX Runtime Web 函式庫未載入。");
            }

            this.session = await ort.InferenceSession.create(this.modelPath, {
              executionProviders: [provider], 
              freeDimensionOverrides: { input_size: MODEL_INPUT_SIZE },
              logLevel: 'error' 
            });
            success = true;
            break; 
          } catch (e) {
            console.warn(`嘗試使用 ${provider} 失敗:`, e.message);
          }
        }

        if (success) {
          this.isReady = true;
          document.getElementById('systemStatus').textContent = 'AI 視覺準備就緒';
          document.getElementById('voiceAlert').textContent = 'AI 模型載入成功';
          document.getElementById('avoidanceIndicator').textContent = '✅ AI 視覺準備就緒';
          document.getElementById('avoidanceIndicator').classList.add('active');
          document.getElementById('btnStart').disabled = false;
          document.getElementById('btnStop').disabled = false;
          return true;
        } else {
          document.getElementById('systemStatus').textContent = 'AI 視覺錯誤';
          document.getElementById('voiceAlert').textContent = 'AI 模型載入失敗，啟用模擬模式'; 
          document.getElementById('avoidanceIndicator').textContent = '❌ AI 錯誤';
          this.useSimulation = true;
          return this.loadModel(); // 回退到模擬模式
        }
      }

      async detect(video) {
        if (!this.isReady) return [];
        
        if (this.useSimulation) {
          return this.simulateDetection(video);
        }

        // 原始檢測邏輯
        try {
          const start = Date.now();
          const tf_image = tf.browser.fromPixels(video);
          const resized = tf.image.resizeBilinear(tf_image, [MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
          const normalized = resized.div(255.0);
          const batched = normalized.expandDims(0);
          const inputTensor = batched.transpose([0, 3, 1, 2]);

          const inputMap = {};
          inputMap[this.session.inputNames[0]] = new ort.Tensor('float32', inputTensor.dataSync(), [1, 3, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
          
          const results = await this.session.run(inputMap);
          const outputTensor = results[this.session.outputNames[0]].data;

          tf_image.dispose();
          resized.dispose();
          normalized.dispose();
          batched.dispose();
          inputTensor.dispose();
          
          const detections = this._processOutput(outputTensor, video.videoWidth, video.videoHeight);
          
          const end = Date.now();
          const inferenceTime = end - start;
          const fps = (1000 / inferenceTime).toFixed(1);
          document.getElementById('safetyScore').textContent = fps + ' FPS';
          
          return detections;
        } catch (error) {
          console.error('檢測錯誤:', error);
          return this.simulateDetection(video); // 出錯時回退到模擬
        }
      }

      // 模擬檢測 - 生成虛擬障礙物
      simulateDetection(video) {
        const width = video.videoWidth || 640;
        const height = video.videoHeight || 480;
        
        // 隨機生成障礙物
        if (Math.random() < 0.3) { // 30% 機率生成新障礙物
          this.simulationObjects = [];
          
          // 生成 1-3 個障礙物
          const numObjects = Math.floor(Math.random() * 3) + 1;
          for (let i = 0; i < numObjects; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height * 0.8 + height * 0.1; // 主要在中下部
            const w = 50 + Math.random() * 100;
            const h = 50 + Math.random() * 100;
            
            const obstacleTypes = ['person', 'car', 'chair', 'wall', 'door'];
            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            
            this.simulationObjects.push({
              x1: x - w/2,
              y1: y - h/2,
              x2: x + w/2,
              y2: y + h/2,
              w: w,
              h: h,
              score: 0.8 + Math.random() * 0.2,
              classId: 0,
              className: type,
              distance: 1 + Math.random() * 5 // 1-6 公尺
            });
          }
        }
        
        // 更新 FPS 顯示
        const now = Date.now();
        const fps = 1000 / (now - this.lastInferenceTime);
        document.getElementById('safetyScore').textContent = fps.toFixed(1) + ' FPS';
        this.lastInferenceTime = now;
        
        return [...this.simulationObjects];
      }

      _processOutput(output, originalWidth, originalHeight, conf_threshold = 0.5) {
        // 簡化的輸出處理邏輯
        const boxes = [];
        const outputSize = output.length;
        const numPredictions = Math.floor(outputSize / (CLASS_NAMES.length + 4));
        
        for (let i = 0; i < numPredictions; i++) {
          const startIdx = i * (CLASS_NAMES.length + 4);
          const x = output[startIdx] * originalWidth;
          const y = output[startIdx + 1] * originalHeight;
          const w = output[startIdx + 2] * originalWidth;
          const h = output[startIdx + 3] * originalHeight;
          
          let maxScore = 0;
          let classId = -1;
          
          for (let j = 0; j < CLASS_NAMES.length; j++) {
            const score = output[startIdx + 4 + j];
            if (score > maxScore) {
              maxScore = score;
              classId = j;
            }
          }
          
          if (maxScore > conf_threshold && classId !== -1) {
            boxes.push({
              x1: x - w/2,
              y1: y - h/2,
              x2: x + w/2,
              y2: y + h/2,
              w: w,
              h: h,
              score: maxScore,
              classId: classId,
              className: CLASS_NAMES[classId],
              distance: this._estimateDistance(h)
            });
          }
        }
        
        return boxes.slice(0, 10);
      }
      
      _estimateDistance(h) {
        const videoHeight = this.videoElement.videoHeight || 480;
        if (h <= 0) return 999;
        const normalizedHeight = h / videoHeight;
        return Math.min(20, 3 / normalizedHeight);
      }

      draw(detections) {
        if (!this.canvasElement || !this.canvasCtx) return;
        
        this.canvasElement.width = this.videoElement.videoWidth || 640;
        this.canvasElement.height = this.videoElement.videoHeight || 480;
        this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);

        detections.forEach(box => {
            const { x1, y1, w, h, className, distance } = box;
            
            let color = '#22c55e';
            if (distance < 3.0) color = '#f59e0b';
            if (distance < 1.5) color = '#ef4444';

            this.canvasCtx.strokeStyle = color;
            this.canvasCtx.lineWidth = 3;
            this.canvasCtx.strokeRect(x1, y1, w, h);

            this.canvasCtx.fillStyle = color;
            this.canvasCtx.font = '14px Arial';
            const label = `${className} ${distance.toFixed(1)}m`;
            const textWidth = this.canvasCtx.measureText(label).width;
            this.canvasCtx.fillRect(x1, y1 - 20, textWidth + 10, 20);
            this.canvasCtx.fillStyle = '#000';
            this.canvasCtx.fillText(label, x1 + 5, y1 - 5);
        });
      }
    }

    // --- 智能避障導航系統 ---
    class ObstacleAvoidanceSystem {
      constructor() {
        this.yoloDetector = new YOLOv8Detector('yolov8n.onnx');
        this.detectionLoopId = null;
        this.voiceEnabled = true;
        this.isNavigating = false;
        this.isFollowing = false;
        this.isIndoorMode = false;
        this.homePosition = null;
        this.currentPosition = null;
        this.gpsWatchId = null;
        
        this.loadHomePosition();
        this.initButtons();
      }

      initButtons() {
        document.getElementById('btnStart').disabled = true;
        document.getElementById('btnFollow').disabled = true;
        document.getElementById('btnStop').disabled = true;
      }

      async initializeSystem() {
        this.updateSystemStatus('載入 AI 模型...');
        const success = await this.yoloDetector.loadModel();
        
        if (success) {
            this.updateSystemStatus('準備就緒');
        }
      }

      switchMode(isIndoor) {
        this.isIndoorMode = isIndoor;
        
        document.getElementById('btnOutdoorMode').classList.toggle('active', !isIndoor);
        document.getElementById('btnIndoorMode').classList.toggle('active', isIndoor);
        
        if (isIndoor) {
          this.speak('已切換到室內避障模式');
          document.getElementById('avoidanceIndicator').classList.add('active');
          document.getElementById('btnFollow').disabled = true;
        } else {
          this.speak('已切換到室外導航模式');
          document.getElementById('avoidanceIndicator').classList.remove('active');
          this.hideAllArrows();
        }
        this.updateUI();
      }

      startAIDetection() {
        if (this.detectionLoopId) return;

        const loop = async () => {
          if (this.isNavigating && this.isIndoorMode && this.yoloDetector.isReady) {
            try {
              const detections = await this.yoloDetector.detect(this.yoloDetector.videoElement);
              this.yoloDetector.draw(detections);
              this.provideAvoidanceGuidance(detections);
            } catch (error) {
              console.error('檢測循環錯誤:', error);
            }
          }
          this.detectionLoopId = requestAnimationFrame(loop);
        };
        
        this.detectionLoopId = requestAnimationFrame(loop);
      }

      stopAIDetection() {
        if (this.detectionLoopId) {
          cancelAnimationFrame(this.detectionLoopId);
          this.detectionLoopId = null;
        }
        if (this.yoloDetector.canvasCtx) {
          this.yoloDetector.canvasCtx.clearRect(0, 0, 
            this.yoloDetector.canvasElement.width, 
            this.yoloDetector.canvasElement.height
          );
        }
      }

      provideAvoidanceGuidance(detections) {
        if (!this.isNavigating || !this.isIndoorMode) return;
        
        let closestDistance = Infinity;
        let advice = '路徑安全，請直行';
        let safeDirection = 'forward';
        this.hideAllArrows();

        const width = this.yoloDetector.videoElement.videoWidth || 640;
        const left_area = width / 3;
        const right_area = width * 2 / 3;

        let danger_left = 999;
        let danger_right = 999;
        let danger_front = 999;

        detections.forEach(box => {
            const center_x = (box.x1 + box.x2) / 2;
            
            if (box.distance < closestDistance) {
                closestDistance = box.distance;
            }

            if (box.distance < 4.0) {
                if (center_x < left_area) {
                    danger_left = Math.min(danger_left, box.distance);
                } else if (center_x > right_area) {
                    danger_right = Math.min(danger_right, box.distance);
                } else {
                    danger_front = Math.min(danger_front, box.distance);
                }
            }
        });

        document.getElementById('closestObstacle').textContent = 
            closestDistance !== Infinity ? closestDistance.toFixed(1) + ' 公尺' : '-- 公尺';

        const STOP_THRESHOLD = 1.0;
        const YIELD_THRESHOLD = 2.0;

        if (closestDistance < STOP_THRESHOLD) {
            advice = '緊急！前方有障礙物，請立即停止！';
            safeDirection = 'stop';
        } else if (danger_front < YIELD_THRESHOLD) {
            if (danger_left > danger_right) {
                advice = `前方障礙物 ${danger_front.toFixed(1)}m，請向左`;
                safeDirection = 'left';
            } else {
                advice = `前方障礙物 ${danger_front.toFixed(1)}m，請向右`;
                safeDirection = 'right';
            }
        } else if (danger_left < YIELD_THRESHOLD && danger_left < danger_right) {
            advice = `左側障礙物 ${danger_left.toFixed(1)}m，請向右`;
            safeDirection = 'right';
        } else if (danger_right < YIELD_THRESHOLD && danger_right < danger_left) {
            advice = `右側障礙物 ${danger_right.toFixed(1)}m，請向左`;
            safeDirection = 'left';
        } else {
            advice = '路徑安全，請直行';
            safeDirection = 'forward';
        }
        
        document.getElementById('avoidanceAdvice').textContent = advice;
        
        // 顯示方向箭頭
        document.getElementById('arrowLeft').classList.toggle('active', safeDirection === 'left');
        document.getElementById('arrowRight').classList.toggle('active', safeDirection === 'right');
        document.getElementById('arrowForward').classList.toggle('active', safeDirection === 'forward');

        // 語音提示
        if (safeDirection !== 'forward' && closestDistance < 3.0) {
            this.speak(advice);
        }
      }
      
      hideAllArrows() {
        document.getElementById('arrowLeft').classList.remove('active');
        document.getElementById('arrowRight').classList.remove('active');
        document.getElementById('arrowForward').classList.remove('active');
      }

      async startNavigation() {
        this.isNavigating = true;
        this.updateSystemStatus('導航中');
        
        try {
          await this.initializeCamera();
          if (this.isIndoorMode) {
            this.speak('室內避障模式啟動');
            this.startAIDetection();
          } else {
            this.speak('室外導航啟動');
            this.startGPSTracking();
          }
        } catch (error) {
          console.warn('導航啟動失敗:', error);
          this.speak('啟動失敗: ' + error.message);
          this.isNavigating = false;
        }
        
        this.updateUI();
      }

      stopNavigation() {
        this.isNavigating = false;
        this.isFollowing = false;
        
        if (this.gpsWatchId) {
          navigator.geolocation.clearWatch(this.gpsWatchId);
          this.gpsWatchId = null;
        }
        
        this.stopAIDetection();
        this.updateSystemStatus('已停止');
        this.speak('導航已停止');
        this.hideTrackingIndicator();
        this.hideAllArrows();
        this.updateUI();
      }

      loadHomePosition() {
        const savedHome = localStorage.getItem('homePosition');
        if (savedHome) {
          this.homePosition = JSON.parse(savedHome);
          this.updateHomeInfo();
        }
      }

      updateSystemStatus(status) {
        document.getElementById('systemStatus').textContent = status;
      }

      updateHomeInfo() {
        // 簡化的家庭位置更新
      }

      showTrackingIndicator() {
        document.getElementById('trackingIndicator').classList.add('active');
      }

      hideTrackingIndicator() {
        document.getElementById('trackingIndicator').classList.remove('active');
      }

      updateUI() {
        const startBtn = document.getElementById('btnStart');
        const followBtn = document.getElementById('btnFollow');
        const stopBtn = document.getElementById('btnStop');
        
        startBtn.textContent = this.isNavigating ? '停止導航' : '開始導航';
        startBtn.classList.toggle('btn-danger', this.isNavigating);
        startBtn.classList.toggle('btn-primary', !this.isNavigating);
        
        followBtn.textContent = this.isFollowing ? '停止跟隨' : '人員跟隨';
        followBtn.disabled = !this.isNavigating || this.isIndoorMode;

        stopBtn.disabled = !this.isNavigating;
      }
      
      speak(message) {
        if (this.voiceEnabled && window.speechSynthesis) {
          window.speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(message);
          utterance.lang = 'zh-TW';
          utterance.rate = 0.8;
          window.speechSynthesis.speak(utterance);
        }
        document.getElementById('voiceAlert').textContent = message;
      }
      
      toggleNavigation() {
        if (this.isNavigating) {
          this.stopNavigation();
        } else {
          this.startNavigation();
        }
      }

      togglePersonFollowing() {
        if (!this.isNavigating) {
          this.speak('請先啟動導航');
          return;
        }
        
        if (this.isIndoorMode) {
          this.speak('室內模式下無法使用人員跟隨');
          return;
        }
        
        this.isFollowing = !this.isFollowing;
        
        if (this.isFollowing) {
          this.speak('人員跟隨啟動');
          this.showTrackingIndicator();
        } else {
          this.speak('人員跟隨停止');
          this.hideTrackingIndicator();
        }
        
        this.updateUI();
      }

      emergencyAlert() {
        this.speak('緊急求助已發送！位置信息已傳送給緊急聯絡人');
      }

      showHomeSetup() {
        this.speak('設定家的位置功能');
        // 簡化設定
      }

      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      async initializeCamera() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('您的瀏覽器不支援相機功能');
        }
        
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'environment',
              width: { ideal: 640 },
              height: { ideal: 480 }
            }
          });
          
          const video = document.getElementById('video');
          video.srcObject = stream;
          
          return new Promise((resolve) => {
            video.onloadedmetadata = () => {
              video.play();
              resolve();
            };
          });
        } catch (error) {
          throw new Error(`無法啟動相機: ${error.message}`);
        }
      }

      startGPSTracking() {
        if (!navigator.geolocation) {
          this.speak('您的裝置不支援 GPS 定位');
          return;
        }
        
        // 簡化 GPS 追蹤
        this.speak('GPS 定位已啟動');
      }
    }

    // 初始化系統
    const navSystem = new ObstacleAvoidanceSystem();

    // 事件監聽器
    document.getElementById('btnOutdoorMode').addEventListener('click', () => {
      navSystem.switchMode(false);
    });
    
    document.getElementById('btnIndoorMode').addEventListener('click', () => {
      navSystem.switchMode(true);
    });
    
    document.getElementById('btnStart').addEventListener('click', () => {
      navSystem.toggleNavigation();
    });
    
    document.getElementById('btnFollow').addEventListener('click', () => {
      navSystem.togglePersonFollowing();
    });
    
    document.getElementById('btnSetHome').addEventListener('click', () => {
      navSystem.showHomeSetup();
    });
    
    document.getElementById('btnStop').addEventListener('click', () => {
      navSystem.stopNavigation();
    });
    
    document.getElementById('btnEmergency').addEventListener('click', () => {
      navSystem.emergencyAlert();
    });

    // 啟動模型載入
    window.addEventListener('DOMContentLoaded', () => {
      navSystem.initializeSystem();
    });
  </script>
</body>
</html>